[{"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};. You need to implement the function CreateEntity in the interface. Here are some apis that you can use and remember:\n code of file CreateEntityExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};", "output": "#include \"..\\..\\PublicAPI\\CreateEntityExamples.h\"\n#include \"..\\..\\PublicAPI\\AddGeometryToSceneUtil.h\"\n\nvoid CreateEntityExamples::CreateEntity()\n{\n    //获得当前激活的场景\n    ATSceneRefP pSceneref = atSceneRef_getActive();\n    if (pSceneref == nullptr)\n        return;\n\n    //创建圆台\n    ISolidCoreEntityPtr circularEntityPtr = GetCircularEntity();\n    if (!circularEntityPtr.IsValid())\n        return;\n\n    HEATObject circularObj;\n    GeometryToATObject::ToObject(circularObj, *circularEntityPtr, nullptr, *pSceneref);\n    if (circularObj.IsValid())\n        circularObj.AddToScene();\n\n    //创建长方体\n    ISolidCoreEntityPtr cuboidEntityPtr = GetCuboidEntity();\n    if (!cuboidEntityPtr.IsValid())\n        return;\n\n    HEATObject cuboidObj;\n    GeometryToATObject::ToObject(cuboidObj, *cuboidEntityPtr, nullptr, *pSceneref);\n    if (cuboidObj.IsValid())\n        cuboidObj.AddToScene();\n}\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};. You need to implement the function BooleanIntersectExample in the interface. Here are some apis that you can use and remember:\n code of file CreateEntityExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};", "output": "\nvoid CreateEntityExamples::BooleanIntersectExample()\n{\n    BooleanExample(BooleanEnum::Intersect);\n}\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};. You need to implement the function BooleanUnionExample in the interface. Here are some apis that you can use and remember:\n code of file CreateEntityExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};", "output": "\nvoid CreateEntityExamples::BooleanUnionExample()\n{\n    BooleanExample(BooleanEnum::Union);\n}\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};. You need to implement the function BooleanSubtractExample in the interface. Here are some apis that you can use and remember:\n code of file CreateEntityExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};", "output": "\nvoid CreateEntityExamples::BooleanSubtractExample()\n{\n    BooleanExample(BooleanEnum::Subtract);\n}\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};. You need to implement the function BlendEdgesExample in the interface. Here are some apis that you can use and remember:\n code of file EntityUtl.h: \n\n#pragma once\n\n/**\n* @file EntityUtl.h\n*\n* @author SZEWC\n* @date 2022/04/27\n*/\n\n\n/**\n* @brief 以指定起终点截面的方式拉伸体\n* @details \n* \n* @param ISolidCoreEntityPtr & out \n* @param CurveSetCR startProfile \n* @param CurveSetCR endProfile \n* @param CurveSetCR path \n* @param ATSceneRefR scene \n* @param bool alignParallel \n* @param bool selfRepair \n* @param bool createSheet \n* @param XVec3dCP lockDirection \n* @param double const * twistAngle \n* @param double const * scale \n* @param XPoint3dCP scalePoint \n* @return ATEC \n*\n* @author SZEWEC\n* @since 2022/04/28\n*/\nENTITYUTIL_EXPORT ATEC::ATECStatus atSolid_EntityFromSweep\n(\nATEC::ATDataCore::ISolidCoreEntityPtr& out,\nATEC::CurveSetCR startProfile,\nATEC::CurveSetCR endProfile,\nATEC::CurveSetCR path,\nATEC::ATDataCore::ATSceneRefR scene,\nbool alignParallel,\nbool selfRepair,\nbool createSheet,\nATEC::XVec3dCP lockDirection = NULL,\ndouble const* twistAngle = NULL,\ndouble const* scale = NULL,\nATEC::XPoint3dCP scalePoint = NULL\n);\n\n/**\n* @brief 元件到体\n* @details 将给定元件转换成体\n* \n* @param BODY_TAG * bodyP\n* @param ATEC::TransformP bodyTransformP\n* @param ATEC::ATDataCore::ATObjectDescrP odP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @param UInt32 nodeId\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_elementToBody\n(\nBODY_TAG*       bodyP,          \nATEC::TransformP      bodyTransformP, \nATEC::ATDataCore::ATObjectDescrP odP,            \nATEC::ATDataCore::ATSceneRefP    SceneRef,       \nUInt32          nodeId = 1L     \n);\n\n/**\n* @brief 体到元件\n* @details 将给定体转换成元件\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\n* @param BODY_TAG bodyTag\n* @param bool wireframe\n* @param int uIsoParametrics\n* @param int vIsoParametrics\n* @param unsigned int useSmartIso\n* @param ATEC::ATDataCore::ATObjectP templateP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_bodyToObject\n(\nATEC::ATDataCore::ATObjectDescrH edPP,               \nBODY_TAG        bodyTag,            \nbool            wireframe,          \nint             uIsoParametrics,    \nint             vIsoParametrics,    \nunsigned int    useSmartIso,        \nATEC::ATDataCore::ATObjectP      tempP,          \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 面到元件\n* @details 将给定的面转换成等价的元件\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\n* @param FACE_TAG face\n* @param bool wireframe\n* @param int nIsoparametrics\n* @param ATEC::ATDataCore::ATObjectP templateP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_faceToObject\n(\nATEC::ATDataCore::ATObjectDescrH edPP,               \nFACE_TAG        face,               \nbool            wireframe,          \nint             nIsoparametrics,    \nATEC::ATDataCore::ATObjectP      tempP,          \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 体求减\n* @details 从 b2 中减去 b1\n* \n* @param BODY_TAG b2\n* @param BODY_TAG b1\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_subtract\n(\nBODY_TAG        b2,                \nBODY_TAG        b1                 \n);\n\n/**\n* @brief 面面相交\n* @details 计算两个面的交,结果以线体返回\n* \n* @param BODY_TAG * b\n* @param FACE_TAG f1\n* @param FACE_TAG f2\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_faceFaceIntersect\n(\nBODY_TAG        *b,                \nFACE_TAG        f1,                \nFACE_TAG        f2                 \n);\n\n/**\n* @brief 获取输入实体的面ID\n* \n* @param ATEC::FaceId * faceIdP\n* @param ENTITY_TAG ent\n* @param bool useHighestId\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/27\n*/\nENTITYUTIL_EXPORT int atSolid_idFromEntity\n(\nATEC::FaceId          *faceIdP,\nENTITY_TAG      ent,\nbool            useHighestId\n);\n\n/**\n* @brief 检查体\n* @details 检查输入体的几何、拓扑和尺寸有效性\n* \n* @param BODY_TAG body\n* @param bool checkGeometry\n* @param bool checkTopology\n* @param bool checkSize\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_checkBody\n(\nBODY_TAG        body,\nbool            chkGeometry,\nbool            chkTopology,\nbool            chkSize\n);\n\n/**\n* @brief 创建实体列表\n* @details 创建一个空的实体列表\n* \n* @param TAG_ENTITY_LIST * * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listCreate\n(\nTAG_ENTITY_LIST **lP            \n);\n\n/**\n* @brief 删除实体列表\n* @details 释放给定实体列表分配的内存\n* \n* @param TAG_ENTITY_LIST * * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listDelete\n(\nTAG_ENTITY_LIST **lP            \n);\n\n/**\n* @brief 列表添加元素\n* @details 往实体列表的尾部添加一个元素\n* \n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listAdd\n(\nTAG_ENTITY_LIST *lP,            \nENTITY_TAG      ent             \n);\n\n/**\n* @brief 列表添加元素\n* @details 往实体列表的尾部添加另一个列表的所有元素\n* \n* @param TAG_ENTITY_LIST * lDP\n* @param TAG_ENTITY_LIST * lSP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listAddList\n(\nTAG_ENTITY_LIST *lDP,\nTAG_ENTITY_LIST *lSP\n);\n\n/**\n* @brief 列表移除实体\n* @details 从列表中移除指定的实体\n* \n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listRemove\n(\nTAG_ENTITY_LIST *lP,\nENTITY_TAG      ent\n);\n\n/**\n* @brief 列表计数\n* @details 返回实体列表的元素个数\n* \n* @param int * count\n* @param TAG_ENTITY_LIST * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listCount\n(\nint             *count,         \nTAG_ENTITY_LIST *lP             \n);\n\n/**\n* @brief 列表查询实体\n* @details 在列表中搜索给定的实体并返回中索引,若不存在返回-1\n* \n* @param int * nth\n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listLookup\n(\nint             *nth,           \nTAG_ENTITY_LIST *lP,            \nENTITY_TAG      ent             \n);\n\n/**\n* @brief 查询列表指定位置的元素\n* @details 返回实体列表指定位置的元素\n* \n* @param ENTITY_TAG * entP\n* @param TAG_ENTITY_LIST * lP\n* @param int nth\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listNthEl\n(\nENTITY_TAG      *entP,          \nTAG_ENTITY_LIST *lP,            \nint             nth             \n);\n\n/**\n* @brief 清空列表\n* @details 移除列表中的所有元素\n* \n* @param TAG_ENTITY_LIST * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listEmpty\n(\nTAG_ENTITY_LIST *lP             \n);\n\nENTITYUTIL_EXPORT int atSolid_listCreateNonEntity (NON_ENTITY_LIST** lPP);\nENTITYUTIL_EXPORT int atSolid_listDeleteNonEntity (NON_ENTITY_LIST** lPP);\nENTITYUTIL_EXPORT int atSolid_listAddNonEntity (NON_ENTITY_LIST* lP, void* dataP);\nENTITYUTIL_EXPORT int atSolid_listCountNonEntity (int* countP, NON_ENTITY_LIST* lP);\nENTITYUTIL_EXPORT int atSolid_listNthNonEntity (void** dataPP, NON_ENTITY_LIST* lP, int nth);\n\n/**\n* @brief 偏移面\n* @details 将输入面的集合中所有面偏移指定距离,这些面必须属于同一个体\n* \n* @param TAG_ENTITY_LIST * pFaceList\n* @param double * pOffset\n* @param double tolerance\n* @param bool faceFaceCheck\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_offsetFaces\n(\nTAG_ENTITY_LIST *pFaceList,\ndouble          *pOffset,\ndouble          tolerance,\nbool            faceFaceCheck\n);\n\n/**\n* @brief 偏移线体\n* @details 返回给定线体偏移后的边缘\n* \n* @param TAG_ENTITY_LIST * pOffsetList\n* @param BODY_TAG wireBody\n* @param EDGE_TAG refEdge\n* @param ATEC::XPoint3d * pNormal\n* @param double distance\n* @param double tolerance\n* @param int gapFill\n* @param bool localCheck\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_offsetWire\n(\nTAG_ENTITY_LIST *pOffsetList,\nBODY_TAG        wireBody,\nEDGE_TAG        refEdge,\nATEC::XPoint3d        *pNormal,           \ndouble          distance,\ndouble          tolerance,\nint             gapFill,            \nbool            localCheck\n);\n\n/**\n* @brief 面上最近的点\n* @details 计算给定面上离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * clstPt\n* @param ATEC::XPoint3d * normal\n* @param ATEC::XPoint2d * param\n* @param ATEC::XPoint3d * testPt\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_closestPointToFace\n(\nATEC::XPoint3d        *clstPt,            \nATEC::XPoint3d        *normal,            \nATEC::XPoint2d        *param,             \nATEC::XPoint3d        *testPt,            \nFACE_TAG        face                \n);\n\n/**\n* @brief 边上最近的点\n* @details 计算给定边上离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * clstPt\n* @param double * param\n* @param ATEC::XPoint3d * testPt\n* @param EDGE_TAG edge\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_closestPointToEdge\n(\nATEC::XPoint3d        *clstPt,            \ndouble          *param,             \nATEC::XPoint3d        *testPt,            \nEDGE_TAG        edge               \n);\n\n/**\n* @brief 离点最近的点\n* @details 计算给定点离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * point\n* @param VERTEX_TAG vertex\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_pointFromVertex\n(\nATEC::XPoint3d        *point,             \nVERTEX_TAG      vertex              \n);\n\n/**\n* @brief 获取实体\n* @details 从给定起始点发射射线,返回体上与之相交的所有实体\n* \n* @param TAG_ENTITY_LIST * hits\n* @param double * * params\n* @param ATEC::XPoint3dP origin\n* @param ATEC::XPoint3dP dir\n* @param double radius\n* @param int type\n* @param BODY_TAG b\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getEntities\n(\nTAG_ENTITY_LIST *hits,              \ndouble          **params,           \nATEC::XPoint3dP       origin,             \nATEC::XPoint3dP       dir,                \ndouble          radius,             \nint             type,               \nBODY_TAG        b,                  \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 获取面实体\n* @details 从给定起始点发射射线,返回体上与之相交的第一个面以及相应的交点\n* \n* @param ATEC::XPoint3d * outPointP\n* @param ATEC::XPoint3d * outNormalP\n* @param FACE_TAG * outFaceP\n* @param ATEC::XPoint3d * inPointP\n* @param ATEC::XPoint3d * inNormalP\n* @param BODY_TAG body\n* @param bool backupRayOrigin\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_boresiteToFace\n(\nATEC::XPoint3d        *outPointP,         \nATEC::XPoint3d        *outNormalP,        \nFACE_TAG        *outFaceP,          \nATEC::XPoint3d        *inPointP,          \nATEC::XPoint3d        *inNormalP,         \nBODY_TAG        body,               \nbool            backupRayOrigin,    \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 曲线与面相交\n* @details 将给定部分曲线与给定的面相交,并返回曲线与面之间的交点以及相应的参数\n* \n* @param ATEC::XPoint3dP * pointPP\n* @param ATEC::XPoint2d * * faceUVPP\n* @param double * * curveParamPP\n* @param int * numIntsP\n* @param FACE_TAG face\n* @param CURVE_TAG curve\n* @param double startParam\n* @param double endParam\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_faceIntersectCurve\n(\nATEC::XPoint3dP       *pntPP,\nATEC::XPoint2d        **faceUVPP,\ndouble          **curveParamPP,\nint             *numIntsP,\nFACE_TAG        face,\nCURVE_TAG       curve,\ndouble          startParam,\ndouble          endParam\n);\n\n/**\n* @brief 获取体的包围盒\n* @details 计算给定体的包围盒\n* \n* @param ATEC::XPoint3d * lo\n* @param ATEC::XPoint3d * hi\n* @param BODY_TAG b\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getBodyBox\n(\nATEC::XPoint3d       *lo,             \nATEC::XPoint3d       *hi,             \nBODY_TAG       b                \n);\n\n/**\n* @brief 获取平滑的面列表\n* @details 向面的列表中添加一个面,并添加这个面与列表中的面的平滑连接\n* \n* @param TAG_ENTITY_LIST * listP\n* @param FACE_TAG face\n* @param bool addSmoothFaces\n* @param int allowedFaceTypeMask\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getSmoothFaceList\n(\nTAG_ENTITY_LIST *listP,\nFACE_TAG        face,\nbool            addSmoothFaces,\nint             allowedFaceTypeMask\n);\n\nenum SmoothEdgeType\n    {\n    SMOOTH_TYPE_NONE  = 0,\n    SMOOTH_TYPE_BLEND = 1,\n    SMOOTH_TYPE_TANGENT = 2\n    };\n\n/**\n* @brief 面的所有边\n* @details 返回构成面的所有边\n* \n* @param TAG_ENTITY_LIST * edgeListP\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getEdgeListFromFace\n(\nTAG_ENTITY_LIST *edgeListP,         \nFACE_TAG        face                \n);\n\n/**\n* @brief 线体是否G1连续\n* @details 查询线体是否关于所有点G1连续\n* \n* @param BODY_TAG wire\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_wireIsG1\n(\nBODY_TAG        wire\n);\n\n/**\n* @brief 实体最小距离\n* @details 计算两个实体之间的最小距离\n* \n* @param ATEC::XPoint3dP pPoint1\n* @param ATEC::XPoint3dP pPoint2\n* @param double * pDistance\n* @param ENTITY_TAG entity1\n* @param ENTITY_TAG entity2\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_minimumDistanceBetweenEntities\n(\nATEC::XPoint3dP           pPoint1,\nATEC::XPoint3dP           pPoint2,\ndouble              *pDist,\nENTITY_TAG          entity1,\nENTITY_TAG          entity2\n);\n\n/**\n* @brief 简化体\n* @details 尝试将B样条曲线和曲面简化为分析曲线和曲面\n* \n* @param BODY_TAG * bodyP\n* @param bool local\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_simplifyBody\n(\nBODY_TAG        *bodyP,\nbool            local\n);\n\n/**\n* @brief 开始转换\n* @details 将变换矩阵推入堆栈中\n* \n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_beginCurrTrans (ATEC::ATDataCore::ATSceneRefP SceneRef);\n\n/**\n* @brief 结束转换\n* @details 从堆栈中弹出brSolid_beginCurrTrans推入的变换矩阵\n* \n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_endCurrTrans ();\n\n/**\n* @brief 应用变换\n* @details 对体应用给定变换\n* \n* @param ENTITY_TAG entity\n* @param ATEC::TransformP transformP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_applyTransform\n(\nENTITY_TAG      entity,            \nATEC::TransformP      transformP         \n);\n\n/**\n* @brief 给薄面体加盖\n* @details 通过添加其他面封闭给定的薄面体并转换为体\n* \n* @param TAG_ENTITY_LIST * faces\n* @param BODY_TAG * lamina\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_capSurface\n(\nTAG_ENTITY_LIST *faces,             \nBODY_TAG        *lamina             \n);\n\n/**\n* @brief 逆转体\n* @details 将体中的所有面逆转方向\n* \n* @param BODY_TAG body\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_reverseBody\n(\nBODY_TAG        body               \n);\n\n/**\n* @brief 删除实体\n* @details 删除给定的实体\n* \n* @param ENTITY_TAG e\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_deleteEntity\n(\nENTITY_TAG      e                  \n);\n\n/**\n* @brief 复制体\n* @details 创建给定体的一个复制\n* \n* @param BODY_TAG * copy\n* @param BODY_TAG source\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_copyBody\n(\nBODY_TAG        *copy,\nBODY_TAG        source\n);\n\n/**\n* @brief 删除体\n* @details 释放体所分配的内存\n* \n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_freeBody\n(\nBODY_TAG        body               \n);\n\n/**\n* @brief 释放内存\n* @details 释放列表所分配的内存\n* \n* @param void * v\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_free\n(\nvoid            *v\n);\n\n/**\n* @brief 边缘数据\n* @details 返回边缘的拓扑和几何信息\n* \n* @param VERTEX_TAG * startVertexP\n* @param VERTEX_TAG * endVertexP\n* @param ATEC::XPoint3d * startPointP\n* @param ATEC::XPoint3d * endPointP\n* @param double * startParamP\n* @param double * endParamP\n* @param COEDGE_TAG * coEdgeP\n* @param CURVE_TAG * curveP\n* @param bool * reversedP\n* @param EDGE_TAG edge\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_edgeData\n(\nVERTEX_TAG      *startVertexP,  \nVERTEX_TAG      *endVertexP,    \nATEC::XPoint3d        *startPointP,   \nATEC::XPoint3d        *endPointP,     \ndouble          *startParamP,   \ndouble          *endParamP,     \nCOEDGE_TAG      *coEdgeP,       \nCURVE_TAG       *curveP,        \nbool            *reversedP,     \nEDGE_TAG        edge            \n);\n\n/**\n* @brief 获取所有边\n* @details 返回体的所有边列表\n* \n* @param TAG_ENTITY_LIST * listP\n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getEdgeList\n(\nTAG_ENTITY_LIST *listP,             \nBODY_TAG        body                \n);\n\n/**\n* @brief 获取所有面\n* @details 返回体的所有面列表\n* \n* @param TAG_ENTITY_LIST * listP\n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getFaceList\n(\nTAG_ENTITY_LIST *listP,             \nBODY_TAG        body                \n);\n\n/**\n* @brief 体的首条边\n* @details 返回体的第一条边\n* \n* @param EDGE_TAG * pEdge\n* @param BODY_TAG body\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_bodyAskFirstEdge\n(\nEDGE_TAG        *pEdge,\nBODY_TAG        body\n);\n\n/**\n* @brief 创建空体\n* @details 创建一个最小的仅包含一个点的体\n* \n* @param BODY_TAG * b\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_body\n(\nBODY_TAG        *b                  \n);\n\n/**\n* @brief 面集到薄面体\n* @details 将输入的面拼接并创建一个薄面体,所有的面必须来自同一个体\n* \n* @param BODY_TAG * sheetP\n* @param TAG_ENTITY_LIST * faceListP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sheetFromFaces\n(\nBODY_TAG        *sheetP,            \nTAG_ENTITY_LIST *faceListP          \n);\n\n/**\n* @brief 面到薄面体\n* @details 根据输入的单个面创建一个薄面体\n* \n* @param BODY_TAG * sheetP\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sheetFromFace\n(\nBODY_TAG        *sheetP,          \nFACE_TAG        face              \n);\n\n/**\n* @brief 揭开面\n* @details 将输入的面从所属的薄面体中移除\n* \n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_uncoverFace\n(\nFACE_TAG        face\n);\n\n/**\n* @brief 两个体压印\n* @details 计算两个体的交并把交压印到目标体或两个体上\n* \n* @param TAG_ENTITY_LIST * pTargetEdges\n* @param TAG_ENTITY_LIST * pToolEdges\n* @param BODY_TAG target\n* @param BODY_TAG tool\n* @param double tolerance\n* @param bool imprintTool\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintBodies\n(\nTAG_ENTITY_LIST *pTargetEdges,  \nTAG_ENTITY_LIST *pToolEdges,    \nBODY_TAG        target,         \nBODY_TAG        tool,           \ndouble          tolerance,      \nbool            imprintTool     \n);\n\nENTITYUTIL_EXPORT bool atSolid_isSmartObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetOrSolidObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSceneerObject (ATEC::ATDataCore::ATObjectDescrP odP);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetBody (BODY_TAG bodyTag);\n\nENTITYUTIL_EXPORT bool atSolid_isWireBody (BODY_TAG bodyTag);\n\nENTITYUTIL_EXPORT bool atSolid_isFace (ENTITY_TAG entityTag);\n\nENTITYUTIL_EXPORT bool atSolid_isEdge (ENTITY_TAG entityTag);\n\n/**\n* @brief 获取FACE_TYPE\n* @details 返回FACE_TYPE常数\n* \n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_faceType ();\n\n/**\n* @brief 获取EDGE_TYPE\n* @details 返回EDGE_TYPE常数\n* \n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_edgeType ();\n\nENTITYUTIL_EXPORT void atSolid_moveBoresiteToEyePoint\n(\nATEC::XPoint3d        *pBorePoint,\nATEC::XPoint3d        *pBoreDirection,\nBODY_TAG        pBody\n);\n\nENTITYUTIL_EXPORT void atSolid_displayFace\n(\nTransDescrP     *transientPP,   \nFACE_TAG        faceP,\nbool            display,\nbool            showSmoothFaces,\nint             allowedFaceTypeMask,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             weight,\nint             style\n);\n\nENTITYUTIL_EXPORT void atSolid_displayEdge\n(\nTransDescrP     *transientPP,   \nEDGE_TAG        edgeP,          \nbool            display,        \nSmoothEdgeType  smoothSequence, \nbool            showStart,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             weight,\nint             style\n);\n\nENTITYUTIL_EXPORT int atSolid_createMark\n(\nint             *markP\n);\n\nENTITYUTIL_EXPORT int atSolid_gotoMark\n(\nint             mark\n);\n\nENTITYUTIL_EXPORT int atSolid_deleteMark\n(\nint             mark\n);\n\nENTITYUTIL_EXPORT void atSolid_getBoresiteWithBodyTransform\n(\nATEC::XPoint3dP       borePointP,         \nATEC::XPoint3dP       boreDirectionP,     \nATEC::XPoint3dCP      pntP,             \nint             view,               \nATEC::ATDataCore::ATSceneRefP    SceneRef,           \nATEC::TransformCP     bodyTransformP,     \nbool            useACS,             \nbool            frontClipBorePoint  \n);\n\nENTITYUTIL_EXPORT void atSolid_displayFaceWithBodyTransform\n(\nTransDescrP     *transientPP,       \nFACE_TAG        faceP,\nATEC::TransformP      bodyTransformP,     \nbool            display,\nbool            showSmoothFaces,\nint             nIsoParametrics,    \nint             allowedFaceTypeMask,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             style,\nint             weight\n);\n\nENTITYUTIL_EXPORT void atSolid_displayEdgeWithBodyTransform\n(\nTransDescrP     *transientPP,       \nEDGE_TAG        edgeP,              \nATEC::TransformP      bodyTransformP,     \nbool            display,            \nSmoothEdgeType  smoothSequence,     \nbool            showStart,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nUInt32          color,\nlong            style,\nUInt32          weight,\nbool            showAllEdgesWithSameId\n);\n\nENTITYUTIL_EXPORT int atSolid_getSharedEdgesOfFaces\n(\nTAG_ENTITY_LIST     *edgeListP,\nTAG_ENTITY_LIST     *faceListP\n);\n\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_getBSplineFromSmartSurface\n(\nATEC::ATBsplineSurface*   pBSurface,\nBODY_TAG            bodyP\n);\n\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_getBSplineFromSmartSurface2\n(\nATEC::ATBsplineSurface*   pBSurface,\nBODY_TAG            bodyP,\nATEC::TransformP          bodyTransformP,\nATEC::ATDataCore::ATSceneRefP        SceneRef\n);\n\n#define     SOLIDTEMPLATE_OPTION_None               0\n#define     SOLIDTEMPLATE_OPTION_PreserveElemId     1\n#define     SOLIDTEMPLATE_OPTION_PrimaryClass       2\n\nENTITYUTIL_EXPORT ATEC::ATDataCore::ATObjectP  atSolid_createBrepTemplateForOdP\n(\nATEC::ATDataCore::ATObjectP          objectP,   \nATEC::ATDataCore::ATObjectDescrCP    odP,        \nUInt32              options     \n);\n\n/**\n* @brief 沿线拉伸体\n* @details 沿着输入的线体拉伸线体或薄面体\n* \n* @param BODY_TAG * bodyP\n* @param BODY_TAG wireBody\n* @param ATEC::XPoint3d * pathStartP\n* @param double shell\n* @param bool capped\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sweepBodyWire\n(\n\tBODY_TAG        *bodyP,\n\tBODY_TAG        wireBody,\n\tATEC::XPoint3d        *pathStartP,\n\tdouble          shell,\n\tbool            capped,\n\tATEC::ATDataCore::ATSceneRefP    SceneRef\n);\n\n/**\n* @brief 根据面ID从输入的体中寻找面\n* \n* @param FACE_TAG * faceP \n* @param ATEC::FaceId * faceIdP \n* @param BODY_TAG body \n* @return ENTITYUTIL_EXPORT int \n*\n* @author SZEWEC\n* @since 2022/04/29\n*/\nENTITYUTIL_EXPORT int atSolid_faceFromId\n(\n\tFACE_TAG        *faceP,\n\tATEC::FaceId          *faceIdP,\n\tBODY_TAG        body\n);\n\n/**\n* @brief 使用输入的边生成元素,当元素代表边的一部分的时候该接口接收一个起始和终止参数\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\t\t生成的元素\n* @param ATEC::ATDataCore::ATObjectP templateP\t\t生成元素的模板,传NULL时使用默认样式\n* @param EDGE_TAG edge\t\t\t\t\t\t\t\t边\n* @param double * startParameterP\t\t\t\t\t传NULL时使用边的起点,否则为该参数指定的点（位于边上）作为起点\n* @param double * endParameterP\t\t\t\t\t\t传NULL时使用边的终点,否则为该参数指定的点（位于边上）作为终点\n* @param ATEC::ATDataCore::ATScenesRefP SceneRef\t生成的元素所在的场景\n* @return ENTITYUTIL_EXPORT int\t\t\t\t\t\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/05\n*/\nENTITYUTIL_EXPORT int atSolid_elementFromEdge\n(\n\tATEC::ATDataCore::ATObjectDescrH edPP,\n\tATEC::ATDataCore::ATObjectP      tempP,\n\tEDGE_TAG        edge,\n\tdouble          *startParameterP,\n\tdouble          *endParameterP,\n\tATEC::ATDataCore::ATSceneRefP    SceneRef\n);\n\n/**\n* @brief 将给定的曲线压印到实体上\n*\n* @param TAG_ENTITY_LIST * pImprintList\t\t[out] 压印到实体上的结果曲线,或者NULL\n* @param BODY_TAG body\t\t\t\t\t\t[in ] 实体\n* @param TAG_ENTITY_LIST * pEdgeList\t\t[in ] 待压印的曲线\n* @param ATEC::XPoint3d * pVector\t\t\t[in ] 压印（投影）的方向\n* @param double tolerance\t\t\t\t\t[in ] 容差,用于解决容差问题与计算参数空间曲线需要\n* @return ENTITYUTIL_EXPORT ATEC::StatusInt\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/30\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintCurveSet\n(\n\tTAG_ENTITY_LIST *pImprintList,\n\tBODY_TAG        body,\n\tTAG_ENTITY_LIST *pEdgeList,\n\tATEC::XPoint3d        *pVector,\n\tdouble          tolerance\n);\n\n/**\n* @brief 将给定的曲线沿着面的法线方向压印到实体上\n*\n* @param TAG_ENTITY_LIST * pImprintList\t\t[out] 压印到实体上的结果曲线,或者NULL\n* @param BODY_TAG body\t\t\t\t\t\t[in ] 实体\n* @param TAG_ENTITY_LIST * pEdgeList\t\t[in ] 待压印的曲线\n* @param double tolerance\t\t\t\t\t[in ] 容差,用于解决容差问题与计算参数空间曲线需要\n* @return ENTITYUTIL_EXPORT ATEC::StatusInt\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/30\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintCurveNormal\n(\n\tTAG_ENTITY_LIST *pImprintList,\n\tBODY_TAG        body,\n\tTAG_ENTITY_LIST *pEdgeList,\n\tdouble          tolerance\n);\n\n\n code of file CreateEntityExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};", "output": "\nvoid CreateEntityExamples::BlendEdgesExample()\n{\n    //创建长方体\n    ISolidCoreEntityPtr cuboidEntityPtr = GetCuboidEntity();\n    xvector<ISubEntityPtr> edges;\n    EntityUtl::GetEntityEdges(&edges, *cuboidEntityPtr);//获得所有的边\n    size_t edgesCount = edges.size();\n    xvector<double> radii;\n    for (size_t i = 0; i < edgesCount; ++i)\n    {\n        radii.push_back(1500);\n    }\n\n    EntityUtl::Modify::BlendEdges(cuboidEntityPtr, edges.data(), radii.data(), edges.size(), true);//给每个边倒圆角\n\n    //获得当前激活的场景\n    ATSceneRefP pSceneref = atSceneRef_getActive();\n    if (pSceneref == nullptr)\n        return;\n\n    //添加到场景\n    HEATObject cuboidObj;\n    GeometryToATObject::ToObject(cuboidObj, *cuboidEntityPtr, nullptr, *pSceneref);\n    if (cuboidObj.IsValid())\n        cuboidObj.AddToScene();\n}\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};. You need to implement the function BooleanCutExample in the interface. Here are some apis that you can use and remember:\n code of file EntityUtl.h: \n\n#pragma once\n\n/**\n* @file EntityUtl.h\n*\n* @author SZEWC\n* @date 2022/04/27\n*/\n\n\n/**\n* @brief 以指定起终点截面的方式拉伸体\n* @details \n* \n* @param ISolidCoreEntityPtr & out \n* @param CurveSetCR startProfile \n* @param CurveSetCR endProfile \n* @param CurveSetCR path \n* @param ATSceneRefR scene \n* @param bool alignParallel \n* @param bool selfRepair \n* @param bool createSheet \n* @param XVec3dCP lockDirection \n* @param double const * twistAngle \n* @param double const * scale \n* @param XPoint3dCP scalePoint \n* @return ATEC \n*\n* @author SZEWEC\n* @since 2022/04/28\n*/\nENTITYUTIL_EXPORT ATEC::ATECStatus atSolid_EntityFromSweep\n(\nATEC::ATDataCore::ISolidCoreEntityPtr& out,\nATEC::CurveSetCR startProfile,\nATEC::CurveSetCR endProfile,\nATEC::CurveSetCR path,\nATEC::ATDataCore::ATSceneRefR scene,\nbool alignParallel,\nbool selfRepair,\nbool createSheet,\nATEC::XVec3dCP lockDirection = NULL,\ndouble const* twistAngle = NULL,\ndouble const* scale = NULL,\nATEC::XPoint3dCP scalePoint = NULL\n);\n\n/**\n* @brief 元件到体\n* @details 将给定元件转换成体\n* \n* @param BODY_TAG * bodyP\n* @param ATEC::TransformP bodyTransformP\n* @param ATEC::ATDataCore::ATObjectDescrP odP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @param UInt32 nodeId\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_elementToBody\n(\nBODY_TAG*       bodyP,          \nATEC::TransformP      bodyTransformP, \nATEC::ATDataCore::ATObjectDescrP odP,            \nATEC::ATDataCore::ATSceneRefP    SceneRef,       \nUInt32          nodeId = 1L     \n);\n\n/**\n* @brief 体到元件\n* @details 将给定体转换成元件\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\n* @param BODY_TAG bodyTag\n* @param bool wireframe\n* @param int uIsoParametrics\n* @param int vIsoParametrics\n* @param unsigned int useSmartIso\n* @param ATEC::ATDataCore::ATObjectP templateP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_bodyToObject\n(\nATEC::ATDataCore::ATObjectDescrH edPP,               \nBODY_TAG        bodyTag,            \nbool            wireframe,          \nint             uIsoParametrics,    \nint             vIsoParametrics,    \nunsigned int    useSmartIso,        \nATEC::ATDataCore::ATObjectP      tempP,          \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 面到元件\n* @details 将给定的面转换成等价的元件\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\n* @param FACE_TAG face\n* @param bool wireframe\n* @param int nIsoparametrics\n* @param ATEC::ATDataCore::ATObjectP templateP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_faceToObject\n(\nATEC::ATDataCore::ATObjectDescrH edPP,               \nFACE_TAG        face,               \nbool            wireframe,          \nint             nIsoparametrics,    \nATEC::ATDataCore::ATObjectP      tempP,          \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 体求减\n* @details 从 b2 中减去 b1\n* \n* @param BODY_TAG b2\n* @param BODY_TAG b1\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_subtract\n(\nBODY_TAG        b2,                \nBODY_TAG        b1                 \n);\n\n/**\n* @brief 面面相交\n* @details 计算两个面的交,结果以线体返回\n* \n* @param BODY_TAG * b\n* @param FACE_TAG f1\n* @param FACE_TAG f2\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_faceFaceIntersect\n(\nBODY_TAG        *b,                \nFACE_TAG        f1,                \nFACE_TAG        f2                 \n);\n\n/**\n* @brief 获取输入实体的面ID\n* \n* @param ATEC::FaceId * faceIdP\n* @param ENTITY_TAG ent\n* @param bool useHighestId\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/27\n*/\nENTITYUTIL_EXPORT int atSolid_idFromEntity\n(\nATEC::FaceId          *faceIdP,\nENTITY_TAG      ent,\nbool            useHighestId\n);\n\n/**\n* @brief 检查体\n* @details 检查输入体的几何、拓扑和尺寸有效性\n* \n* @param BODY_TAG body\n* @param bool checkGeometry\n* @param bool checkTopology\n* @param bool checkSize\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_checkBody\n(\nBODY_TAG        body,\nbool            chkGeometry,\nbool            chkTopology,\nbool            chkSize\n);\n\n/**\n* @brief 创建实体列表\n* @details 创建一个空的实体列表\n* \n* @param TAG_ENTITY_LIST * * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listCreate\n(\nTAG_ENTITY_LIST **lP            \n);\n\n/**\n* @brief 删除实体列表\n* @details 释放给定实体列表分配的内存\n* \n* @param TAG_ENTITY_LIST * * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listDelete\n(\nTAG_ENTITY_LIST **lP            \n);\n\n/**\n* @brief 列表添加元素\n* @details 往实体列表的尾部添加一个元素\n* \n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listAdd\n(\nTAG_ENTITY_LIST *lP,            \nENTITY_TAG      ent             \n);\n\n/**\n* @brief 列表添加元素\n* @details 往实体列表的尾部添加另一个列表的所有元素\n* \n* @param TAG_ENTITY_LIST * lDP\n* @param TAG_ENTITY_LIST * lSP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listAddList\n(\nTAG_ENTITY_LIST *lDP,\nTAG_ENTITY_LIST *lSP\n);\n\n/**\n* @brief 列表移除实体\n* @details 从列表中移除指定的实体\n* \n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listRemove\n(\nTAG_ENTITY_LIST *lP,\nENTITY_TAG      ent\n);\n\n/**\n* @brief 列表计数\n* @details 返回实体列表的元素个数\n* \n* @param int * count\n* @param TAG_ENTITY_LIST * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listCount\n(\nint             *count,         \nTAG_ENTITY_LIST *lP             \n);\n\n/**\n* @brief 列表查询实体\n* @details 在列表中搜索给定的实体并返回中索引,若不存在返回-1\n* \n* @param int * nth\n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listLookup\n(\nint             *nth,           \nTAG_ENTITY_LIST *lP,            \nENTITY_TAG      ent             \n);\n\n/**\n* @brief 查询列表指定位置的元素\n* @details 返回实体列表指定位置的元素\n* \n* @param ENTITY_TAG * entP\n* @param TAG_ENTITY_LIST * lP\n* @param int nth\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listNthEl\n(\nENTITY_TAG      *entP,          \nTAG_ENTITY_LIST *lP,            \nint             nth             \n);\n\n/**\n* @brief 清空列表\n* @details 移除列表中的所有元素\n* \n* @param TAG_ENTITY_LIST * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listEmpty\n(\nTAG_ENTITY_LIST *lP             \n);\n\nENTITYUTIL_EXPORT int atSolid_listCreateNonEntity (NON_ENTITY_LIST** lPP);\nENTITYUTIL_EXPORT int atSolid_listDeleteNonEntity (NON_ENTITY_LIST** lPP);\nENTITYUTIL_EXPORT int atSolid_listAddNonEntity (NON_ENTITY_LIST* lP, void* dataP);\nENTITYUTIL_EXPORT int atSolid_listCountNonEntity (int* countP, NON_ENTITY_LIST* lP);\nENTITYUTIL_EXPORT int atSolid_listNthNonEntity (void** dataPP, NON_ENTITY_LIST* lP, int nth);\n\n/**\n* @brief 偏移面\n* @details 将输入面的集合中所有面偏移指定距离,这些面必须属于同一个体\n* \n* @param TAG_ENTITY_LIST * pFaceList\n* @param double * pOffset\n* @param double tolerance\n* @param bool faceFaceCheck\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_offsetFaces\n(\nTAG_ENTITY_LIST *pFaceList,\ndouble          *pOffset,\ndouble          tolerance,\nbool            faceFaceCheck\n);\n\n/**\n* @brief 偏移线体\n* @details 返回给定线体偏移后的边缘\n* \n* @param TAG_ENTITY_LIST * pOffsetList\n* @param BODY_TAG wireBody\n* @param EDGE_TAG refEdge\n* @param ATEC::XPoint3d * pNormal\n* @param double distance\n* @param double tolerance\n* @param int gapFill\n* @param bool localCheck\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_offsetWire\n(\nTAG_ENTITY_LIST *pOffsetList,\nBODY_TAG        wireBody,\nEDGE_TAG        refEdge,\nATEC::XPoint3d        *pNormal,           \ndouble          distance,\ndouble          tolerance,\nint             gapFill,            \nbool            localCheck\n);\n\n/**\n* @brief 面上最近的点\n* @details 计算给定面上离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * clstPt\n* @param ATEC::XPoint3d * normal\n* @param ATEC::XPoint2d * param\n* @param ATEC::XPoint3d * testPt\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_closestPointToFace\n(\nATEC::XPoint3d        *clstPt,            \nATEC::XPoint3d        *normal,            \nATEC::XPoint2d        *param,             \nATEC::XPoint3d        *testPt,            \nFACE_TAG        face                \n);\n\n/**\n* @brief 边上最近的点\n* @details 计算给定边上离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * clstPt\n* @param double * param\n* @param ATEC::XPoint3d * testPt\n* @param EDGE_TAG edge\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_closestPointToEdge\n(\nATEC::XPoint3d        *clstPt,            \ndouble          *param,             \nATEC::XPoint3d        *testPt,            \nEDGE_TAG        edge               \n);\n\n/**\n* @brief 离点最近的点\n* @details 计算给定点离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * point\n* @param VERTEX_TAG vertex\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_pointFromVertex\n(\nATEC::XPoint3d        *point,             \nVERTEX_TAG      vertex              \n);\n\n/**\n* @brief 获取实体\n* @details 从给定起始点发射射线,返回体上与之相交的所有实体\n* \n* @param TAG_ENTITY_LIST * hits\n* @param double * * params\n* @param ATEC::XPoint3dP origin\n* @param ATEC::XPoint3dP dir\n* @param double radius\n* @param int type\n* @param BODY_TAG b\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getEntities\n(\nTAG_ENTITY_LIST *hits,              \ndouble          **params,           \nATEC::XPoint3dP       origin,             \nATEC::XPoint3dP       dir,                \ndouble          radius,             \nint             type,               \nBODY_TAG        b,                  \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 获取面实体\n* @details 从给定起始点发射射线,返回体上与之相交的第一个面以及相应的交点\n* \n* @param ATEC::XPoint3d * outPointP\n* @param ATEC::XPoint3d * outNormalP\n* @param FACE_TAG * outFaceP\n* @param ATEC::XPoint3d * inPointP\n* @param ATEC::XPoint3d * inNormalP\n* @param BODY_TAG body\n* @param bool backupRayOrigin\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_boresiteToFace\n(\nATEC::XPoint3d        *outPointP,         \nATEC::XPoint3d        *outNormalP,        \nFACE_TAG        *outFaceP,          \nATEC::XPoint3d        *inPointP,          \nATEC::XPoint3d        *inNormalP,         \nBODY_TAG        body,               \nbool            backupRayOrigin,    \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 曲线与面相交\n* @details 将给定部分曲线与给定的面相交,并返回曲线与面之间的交点以及相应的参数\n* \n* @param ATEC::XPoint3dP * pointPP\n* @param ATEC::XPoint2d * * faceUVPP\n* @param double * * curveParamPP\n* @param int * numIntsP\n* @param FACE_TAG face\n* @param CURVE_TAG curve\n* @param double startParam\n* @param double endParam\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_faceIntersectCurve\n(\nATEC::XPoint3dP       *pntPP,\nATEC::XPoint2d        **faceUVPP,\ndouble          **curveParamPP,\nint             *numIntsP,\nFACE_TAG        face,\nCURVE_TAG       curve,\ndouble          startParam,\ndouble          endParam\n);\n\n/**\n* @brief 获取体的包围盒\n* @details 计算给定体的包围盒\n* \n* @param ATEC::XPoint3d * lo\n* @param ATEC::XPoint3d * hi\n* @param BODY_TAG b\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getBodyBox\n(\nATEC::XPoint3d       *lo,             \nATEC::XPoint3d       *hi,             \nBODY_TAG       b                \n);\n\n/**\n* @brief 获取平滑的面列表\n* @details 向面的列表中添加一个面,并添加这个面与列表中的面的平滑连接\n* \n* @param TAG_ENTITY_LIST * listP\n* @param FACE_TAG face\n* @param bool addSmoothFaces\n* @param int allowedFaceTypeMask\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getSmoothFaceList\n(\nTAG_ENTITY_LIST *listP,\nFACE_TAG        face,\nbool            addSmoothFaces,\nint             allowedFaceTypeMask\n);\n\nenum SmoothEdgeType\n    {\n    SMOOTH_TYPE_NONE  = 0,\n    SMOOTH_TYPE_BLEND = 1,\n    SMOOTH_TYPE_TANGENT = 2\n    };\n\n/**\n* @brief 面的所有边\n* @details 返回构成面的所有边\n* \n* @param TAG_ENTITY_LIST * edgeListP\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getEdgeListFromFace\n(\nTAG_ENTITY_LIST *edgeListP,         \nFACE_TAG        face                \n);\n\n/**\n* @brief 线体是否G1连续\n* @details 查询线体是否关于所有点G1连续\n* \n* @param BODY_TAG wire\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_wireIsG1\n(\nBODY_TAG        wire\n);\n\n/**\n* @brief 实体最小距离\n* @details 计算两个实体之间的最小距离\n* \n* @param ATEC::XPoint3dP pPoint1\n* @param ATEC::XPoint3dP pPoint2\n* @param double * pDistance\n* @param ENTITY_TAG entity1\n* @param ENTITY_TAG entity2\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_minimumDistanceBetweenEntities\n(\nATEC::XPoint3dP           pPoint1,\nATEC::XPoint3dP           pPoint2,\ndouble              *pDist,\nENTITY_TAG          entity1,\nENTITY_TAG          entity2\n);\n\n/**\n* @brief 简化体\n* @details 尝试将B样条曲线和曲面简化为分析曲线和曲面\n* \n* @param BODY_TAG * bodyP\n* @param bool local\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_simplifyBody\n(\nBODY_TAG        *bodyP,\nbool            local\n);\n\n/**\n* @brief 开始转换\n* @details 将变换矩阵推入堆栈中\n* \n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_beginCurrTrans (ATEC::ATDataCore::ATSceneRefP SceneRef);\n\n/**\n* @brief 结束转换\n* @details 从堆栈中弹出brSolid_beginCurrTrans推入的变换矩阵\n* \n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_endCurrTrans ();\n\n/**\n* @brief 应用变换\n* @details 对体应用给定变换\n* \n* @param ENTITY_TAG entity\n* @param ATEC::TransformP transformP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_applyTransform\n(\nENTITY_TAG      entity,            \nATEC::TransformP      transformP         \n);\n\n/**\n* @brief 给薄面体加盖\n* @details 通过添加其他面封闭给定的薄面体并转换为体\n* \n* @param TAG_ENTITY_LIST * faces\n* @param BODY_TAG * lamina\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_capSurface\n(\nTAG_ENTITY_LIST *faces,             \nBODY_TAG        *lamina             \n);\n\n/**\n* @brief 逆转体\n* @details 将体中的所有面逆转方向\n* \n* @param BODY_TAG body\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_reverseBody\n(\nBODY_TAG        body               \n);\n\n/**\n* @brief 删除实体\n* @details 删除给定的实体\n* \n* @param ENTITY_TAG e\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_deleteEntity\n(\nENTITY_TAG      e                  \n);\n\n/**\n* @brief 复制体\n* @details 创建给定体的一个复制\n* \n* @param BODY_TAG * copy\n* @param BODY_TAG source\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_copyBody\n(\nBODY_TAG        *copy,\nBODY_TAG        source\n);\n\n/**\n* @brief 删除体\n* @details 释放体所分配的内存\n* \n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_freeBody\n(\nBODY_TAG        body               \n);\n\n/**\n* @brief 释放内存\n* @details 释放列表所分配的内存\n* \n* @param void * v\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_free\n(\nvoid            *v\n);\n\n/**\n* @brief 边缘数据\n* @details 返回边缘的拓扑和几何信息\n* \n* @param VERTEX_TAG * startVertexP\n* @param VERTEX_TAG * endVertexP\n* @param ATEC::XPoint3d * startPointP\n* @param ATEC::XPoint3d * endPointP\n* @param double * startParamP\n* @param double * endParamP\n* @param COEDGE_TAG * coEdgeP\n* @param CURVE_TAG * curveP\n* @param bool * reversedP\n* @param EDGE_TAG edge\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_edgeData\n(\nVERTEX_TAG      *startVertexP,  \nVERTEX_TAG      *endVertexP,    \nATEC::XPoint3d        *startPointP,   \nATEC::XPoint3d        *endPointP,     \ndouble          *startParamP,   \ndouble          *endParamP,     \nCOEDGE_TAG      *coEdgeP,       \nCURVE_TAG       *curveP,        \nbool            *reversedP,     \nEDGE_TAG        edge            \n);\n\n/**\n* @brief 获取所有边\n* @details 返回体的所有边列表\n* \n* @param TAG_ENTITY_LIST * listP\n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getEdgeList\n(\nTAG_ENTITY_LIST *listP,             \nBODY_TAG        body                \n);\n\n/**\n* @brief 获取所有面\n* @details 返回体的所有面列表\n* \n* @param TAG_ENTITY_LIST * listP\n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getFaceList\n(\nTAG_ENTITY_LIST *listP,             \nBODY_TAG        body                \n);\n\n/**\n* @brief 体的首条边\n* @details 返回体的第一条边\n* \n* @param EDGE_TAG * pEdge\n* @param BODY_TAG body\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_bodyAskFirstEdge\n(\nEDGE_TAG        *pEdge,\nBODY_TAG        body\n);\n\n/**\n* @brief 创建空体\n* @details 创建一个最小的仅包含一个点的体\n* \n* @param BODY_TAG * b\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_body\n(\nBODY_TAG        *b                  \n);\n\n/**\n* @brief 面集到薄面体\n* @details 将输入的面拼接并创建一个薄面体,所有的面必须来自同一个体\n* \n* @param BODY_TAG * sheetP\n* @param TAG_ENTITY_LIST * faceListP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sheetFromFaces\n(\nBODY_TAG        *sheetP,            \nTAG_ENTITY_LIST *faceListP          \n);\n\n/**\n* @brief 面到薄面体\n* @details 根据输入的单个面创建一个薄面体\n* \n* @param BODY_TAG * sheetP\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sheetFromFace\n(\nBODY_TAG        *sheetP,          \nFACE_TAG        face              \n);\n\n/**\n* @brief 揭开面\n* @details 将输入的面从所属的薄面体中移除\n* \n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_uncoverFace\n(\nFACE_TAG        face\n);\n\n/**\n* @brief 两个体压印\n* @details 计算两个体的交并把交压印到目标体或两个体上\n* \n* @param TAG_ENTITY_LIST * pTargetEdges\n* @param TAG_ENTITY_LIST * pToolEdges\n* @param BODY_TAG target\n* @param BODY_TAG tool\n* @param double tolerance\n* @param bool imprintTool\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintBodies\n(\nTAG_ENTITY_LIST *pTargetEdges,  \nTAG_ENTITY_LIST *pToolEdges,    \nBODY_TAG        target,         \nBODY_TAG        tool,           \ndouble          tolerance,      \nbool            imprintTool     \n);\n\nENTITYUTIL_EXPORT bool atSolid_isSmartObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetOrSolidObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSceneerObject (ATEC::ATDataCore::ATObjectDescrP odP);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetBody (BODY_TAG bodyTag);\n\nENTITYUTIL_EXPORT bool atSolid_isWireBody (BODY_TAG bodyTag);\n\nENTITYUTIL_EXPORT bool atSolid_isFace (ENTITY_TAG entityTag);\n\nENTITYUTIL_EXPORT bool atSolid_isEdge (ENTITY_TAG entityTag);\n\n/**\n* @brief 获取FACE_TYPE\n* @details 返回FACE_TYPE常数\n* \n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_faceType ();\n\n/**\n* @brief 获取EDGE_TYPE\n* @details 返回EDGE_TYPE常数\n* \n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_edgeType ();\n\nENTITYUTIL_EXPORT void atSolid_moveBoresiteToEyePoint\n(\nATEC::XPoint3d        *pBorePoint,\nATEC::XPoint3d        *pBoreDirection,\nBODY_TAG        pBody\n);\n\nENTITYUTIL_EXPORT void atSolid_displayFace\n(\nTransDescrP     *transientPP,   \nFACE_TAG        faceP,\nbool            display,\nbool            showSmoothFaces,\nint             allowedFaceTypeMask,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             weight,\nint             style\n);\n\nENTITYUTIL_EXPORT void atSolid_displayEdge\n(\nTransDescrP     *transientPP,   \nEDGE_TAG        edgeP,          \nbool            display,        \nSmoothEdgeType  smoothSequence, \nbool            showStart,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             weight,\nint             style\n);\n\nENTITYUTIL_EXPORT int atSolid_createMark\n(\nint             *markP\n);\n\nENTITYUTIL_EXPORT int atSolid_gotoMark\n(\nint             mark\n);\n\nENTITYUTIL_EXPORT int atSolid_deleteMark\n(\nint             mark\n);\n\nENTITYUTIL_EXPORT void atSolid_getBoresiteWithBodyTransform\n(\nATEC::XPoint3dP       borePointP,         \nATEC::XPoint3dP       boreDirectionP,     \nATEC::XPoint3dCP      pntP,             \nint             view,               \nATEC::ATDataCore::ATSceneRefP    SceneRef,           \nATEC::TransformCP     bodyTransformP,     \nbool            useACS,             \nbool            frontClipBorePoint  \n);\n\nENTITYUTIL_EXPORT void atSolid_displayFaceWithBodyTransform\n(\nTransDescrP     *transientPP,       \nFACE_TAG        faceP,\nATEC::TransformP      bodyTransformP,     \nbool            display,\nbool            showSmoothFaces,\nint             nIsoParametrics,    \nint             allowedFaceTypeMask,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             style,\nint             weight\n);\n\nENTITYUTIL_EXPORT void atSolid_displayEdgeWithBodyTransform\n(\nTransDescrP     *transientPP,       \nEDGE_TAG        edgeP,              \nATEC::TransformP      bodyTransformP,     \nbool            display,            \nSmoothEdgeType  smoothSequence,     \nbool            showStart,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nUInt32          color,\nlong            style,\nUInt32          weight,\nbool            showAllEdgesWithSameId\n);\n\nENTITYUTIL_EXPORT int atSolid_getSharedEdgesOfFaces\n(\nTAG_ENTITY_LIST     *edgeListP,\nTAG_ENTITY_LIST     *faceListP\n);\n\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_getBSplineFromSmartSurface\n(\nATEC::ATBsplineSurface*   pBSurface,\nBODY_TAG            bodyP\n);\n\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_getBSplineFromSmartSurface2\n(\nATEC::ATBsplineSurface*   pBSurface,\nBODY_TAG            bodyP,\nATEC::TransformP          bodyTransformP,\nATEC::ATDataCore::ATSceneRefP        SceneRef\n);\n\n#define     SOLIDTEMPLATE_OPTION_None               0\n#define     SOLIDTEMPLATE_OPTION_PreserveElemId     1\n#define     SOLIDTEMPLATE_OPTION_PrimaryClass       2\n\nENTITYUTIL_EXPORT ATEC::ATDataCore::ATObjectP  atSolid_createBrepTemplateForOdP\n(\nATEC::ATDataCore::ATObjectP          objectP,   \nATEC::ATDataCore::ATObjectDescrCP    odP,        \nUInt32              options     \n);\n\n/**\n* @brief 沿线拉伸体\n* @details 沿着输入的线体拉伸线体或薄面体\n* \n* @param BODY_TAG * bodyP\n* @param BODY_TAG wireBody\n* @param ATEC::XPoint3d * pathStartP\n* @param double shell\n* @param bool capped\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sweepBodyWire\n(\n\tBODY_TAG        *bodyP,\n\tBODY_TAG        wireBody,\n\tATEC::XPoint3d        *pathStartP,\n\tdouble          shell,\n\tbool            capped,\n\tATEC::ATDataCore::ATSceneRefP    SceneRef\n);\n\n/**\n* @brief 根据面ID从输入的体中寻找面\n* \n* @param FACE_TAG * faceP \n* @param ATEC::FaceId * faceIdP \n* @param BODY_TAG body \n* @return ENTITYUTIL_EXPORT int \n*\n* @author SZEWEC\n* @since 2022/04/29\n*/\nENTITYUTIL_EXPORT int atSolid_faceFromId\n(\n\tFACE_TAG        *faceP,\n\tATEC::FaceId          *faceIdP,\n\tBODY_TAG        body\n);\n\n/**\n* @brief 使用输入的边生成元素,当元素代表边的一部分的时候该接口接收一个起始和终止参数\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\t\t生成的元素\n* @param ATEC::ATDataCore::ATObjectP templateP\t\t生成元素的模板,传NULL时使用默认样式\n* @param EDGE_TAG edge\t\t\t\t\t\t\t\t边\n* @param double * startParameterP\t\t\t\t\t传NULL时使用边的起点,否则为该参数指定的点（位于边上）作为起点\n* @param double * endParameterP\t\t\t\t\t\t传NULL时使用边的终点,否则为该参数指定的点（位于边上）作为终点\n* @param ATEC::ATDataCore::ATScenesRefP SceneRef\t生成的元素所在的场景\n* @return ENTITYUTIL_EXPORT int\t\t\t\t\t\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/05\n*/\nENTITYUTIL_EXPORT int atSolid_elementFromEdge\n(\n\tATEC::ATDataCore::ATObjectDescrH edPP,\n\tATEC::ATDataCore::ATObjectP      tempP,\n\tEDGE_TAG        edge,\n\tdouble          *startParameterP,\n\tdouble          *endParameterP,\n\tATEC::ATDataCore::ATSceneRefP    SceneRef\n);\n\n/**\n* @brief 将给定的曲线压印到实体上\n*\n* @param TAG_ENTITY_LIST * pImprintList\t\t[out] 压印到实体上的结果曲线,或者NULL\n* @param BODY_TAG body\t\t\t\t\t\t[in ] 实体\n* @param TAG_ENTITY_LIST * pEdgeList\t\t[in ] 待压印的曲线\n* @param ATEC::XPoint3d * pVector\t\t\t[in ] 压印（投影）的方向\n* @param double tolerance\t\t\t\t\t[in ] 容差,用于解决容差问题与计算参数空间曲线需要\n* @return ENTITYUTIL_EXPORT ATEC::StatusInt\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/30\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintCurveSet\n(\n\tTAG_ENTITY_LIST *pImprintList,\n\tBODY_TAG        body,\n\tTAG_ENTITY_LIST *pEdgeList,\n\tATEC::XPoint3d        *pVector,\n\tdouble          tolerance\n);\n\n/**\n* @brief 将给定的曲线沿着面的法线方向压印到实体上\n*\n* @param TAG_ENTITY_LIST * pImprintList\t\t[out] 压印到实体上的结果曲线,或者NULL\n* @param BODY_TAG body\t\t\t\t\t\t[in ] 实体\n* @param TAG_ENTITY_LIST * pEdgeList\t\t[in ] 待压印的曲线\n* @param double tolerance\t\t\t\t\t[in ] 容差,用于解决容差问题与计算参数空间曲线需要\n* @return ENTITYUTIL_EXPORT ATEC::StatusInt\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/30\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintCurveNormal\n(\n\tTAG_ENTITY_LIST *pImprintList,\n\tBODY_TAG        body,\n\tTAG_ENTITY_LIST *pEdgeList,\n\tdouble          tolerance\n);\n\n\n code of file XVec3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\nstruct ATGEOSET_EXPORT XVec3d : public XPoint3d\n{\n\tstatic XVec3d FromInterpolate(XVec3dCR vector0, double fraction, XVec3dCR vector1);\n\n\tstatic XVec3d From(double ax, double ay, double az = 0.0);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double  ay);\n\n\tstatic XVec3d From(XPoint3dCR point);\n\n\tvoid Init(XPoint3dCR point);\n\n\tstatic XVec3d FromStartEnd(XPoint3dCR start, XPoint3dCR end);\n\n\tstatic XVec3d FromStartEndNormalize(XPoint3dCR start, XPoint3dCR end);\n\n\tstatic XVec3d FromCCWPerpendicularXY(XVec3d source);\n\n\tstatic XVec3d FromRotate90Towards(XVec3dCR source, XVec3dCR target);\n\n\tstatic XVec3d FromRotate90Around(XVec3dCR source, XVec3dCR axis);\n\n\tstatic ValidatedXVec3d FromRotateVectorAroundVector(XVec3dCR source, XVec3dCR axis, XAngle angle);\n\n\tstatic XVec3d FromZero();\n\n\tstatic XVec3d UnitX();\n\n\tstatic XVec3d UnitY();\n\n\tstatic XVec3d UnitZ();\n\n\tdouble Normalize(XVec3dCR vector);\n\n\tdouble Normalize();\n\n\tdouble ScaleToLength(XVec3dCR vector, double length);\n\n\tdouble ScaleToLength(double length);\n\n\tstatic XVec3d FromXYAngleAndMagnitude\n\t(\n\t\tdouble          theta,\n\t\tdouble          magnitude\n\t);\n\n\tvoid InitFromXYAngleAndMagnitude\n\t(\n\t\tdouble          theta,\n\t\tdouble          magnitude\n\t);\n\n\tstatic XVec3d FromColumn(XRotMatrixCR matrix, int i);\n\n\tvoid InitFromColumn\n\t(\n\t\tXRotMatrixCR     matrix,\n\t\tint             col\n\t);\n\n\tvoid MultiplyTranspose(XRotMatrixCR matrix, XVec3dCR vector);\n\n\tvoid MultiplyTranspose(XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XVec3d FromStartEnd(XPoint4dCR start, XPoint4dCR end);\n\n\tstatic XVec3d FromCrossProduct(XVec3dCR vector0, XVec3dCR vector1);\n\n\tvoid CrossProduct(XVec3dCR vector1, XVec3dCR vector2);\n\n\tvoid CrossProduct(XVec3dCR vector1, XPoint3dCR point2);\n\n\tvoid CrossProduct(XPoint3dCR point1, XVec3dCR vector2);\n\n\tstatic XVec3d FromNormalizedCrossProductToPoints(XPoint3dCR origin, XPoint3dCR target1, XPoint3dCR target2);\n\n\tstatic XVec3d FromNormalizedCrossProduct(XVec3dCR vector0, XVec3dCR vector1);\n\n\tdouble NormalizedCrossProduct(XVec3dCR  vector1, XVec3dCR vector2);\n\n\tstatic XVec3d FromCrossProduct(double x0, double y0, double z0, double x1, double y1, double z1);\n\n\tvoid RotateXY(XVec3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tbool UnitPerpendicularXY(XVec3dCR vector);\n\n\tstatic ValidatedXVec3d FromUnitPerpendicularXY(XVec3dCR vector);\n\n\tstatic XVec3d FromSumOf(XVec3dCR vector0, XVec3dCR vector1);\n\n\tstatic XVec3d FromSumOf(XVec3dCR vector0, double scale0, XVec3dCR vector1, double scale1);\n\n\tvoid SumOf(XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2);\n\n\tstatic XVec3d FromSumOf(XVec3dCR vector0, double scale0, XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2);\n\n\tvoid SumOf(XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2, XVec3dCR vector3, double scale3);\n\n\tvoid SumOf(XVec3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XVec3dCR origin, XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2);\n\n\tvoid SumOf(XVec3dCR origin, XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2, XVec3dCR vector3, double scale3);\n\n\tstatic XVec3d FromScale(XVec3dCR vector, double scale);\n\n\tvoid Scale(XVec3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XVec3dCR vector);\n\n\tvoid Negate();\n\n\tdouble DotProduct(XVec3dCR vector2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n    double DotProductXY(XVec3dCR vector2) const;\n\n\tdouble TripleProduct(XVec3dCR vector2, XVec3dCR vector3) const;\n\n\tdouble Magnitude() const;\n\n\tdouble AngleTo(XVec3dCR vector2) const;\n\n\tdouble AngleToXY(XVec3dCR vector2) const;\n\n\tdouble SignedAngleTo\n\t(\n\t\tXVec3dCR        vector2,\n\t\tXVec3dCR        orientationVector\n\t) const;\n\n\tbool IsParallelTo(XVec3dCR vector2) const;\n\n\tbool IsPerpendicularTo(XVec3dCR vector2) const;\n\n\tbool      IsZero();\n\n\tvoid Multiply(XRotMatrixCR matrix, XVec3dCR vector);\n\n\tvoid Multiply(XRotMatrixCR matrix, double x, double y, double z);\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XPoint3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n /**\n * @brief 3D绌洪棿鐐圭被\n * @author SZEWC\n * @since 2022/04/13\n*/\nstruct ATGEOSET_EXPORT XPoint3d\n{\n\n\tdouble x;\n\n\tdouble y;\n\n\tdouble z;\n\n\tstatic XPoint3d From(double x, double y, double z = 0.0);\n\n\tstatic XPoint3d From(XPoint2dCR xy);\n\n\tstatic XPoint3d FromZero();\n\n\tstatic XPoint3d FromOne();\n\n\tstatic XPoint3d FromXYZ(double x, double y, double z);\n\n\tvoid Swap(XPoint3dR other);\n\n\tdouble DotDifference(XPoint3dCR origin, XVec3dCR vector) const;\n\n\tvoid Zero();\n\n\tvoid Init(XPoint2dCR source);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double ay);\n\n\tvoid SetComponent(double a, int index);\n\n\tdouble GetComponent(int index) const;\n\n\tvoid Interpolate(XPoint3dCR pnt0, double fractionParameter, XPoint3dCR point1);\n\n\tdouble Distance(XPoint3dCR point2) const;\n\n\tdouble DistanceXY(XPoint3dCR point2) const;\n\n\tbool DistanceXY(XPoint3dCR otherPoint, XMatrix4dCP matrix, double &distance) const;\n\n\tbool IsEqual(XPoint3dCR point2) const;\n\n\tbool IsEqual(XPoint3dCR point2, double tolerance) const;\n\n\tbool IsDisconnect() const;\n\n\tvoid InitDisconnect();\n\n\tvoid Init(XVec3dCR vector);\n\n\tvoid Subtract(XPoint3dCR base, XVec3dCR vector);\n\n\tvoid Add(XVec3dCR vector);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2, XVec3dCR point3, double scale3);\n\n\tvoid CrossProduct(XPoint3dCR point1, XPoint3dCR point2);\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble AngleTo(XPoint3dCR point2) const;\n\n\tvoid RotateXY(XPoint3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tdouble MagnitudeXY() const;\n\n\tvoid Scale(XPoint3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XPoint3dCR vector);\n\n\tvoid Negate();\n\n\tdouble Normalize(XPoint3dCR vector);\n\n\tdouble Normalize();\n\n\tvoid Subtract(XPoint3dCR point2);\n\n\tvoid DifferenceOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2, XPoint3dCR point3, double scale3);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2, XPoint3dCR point3, double a3);\n\n\tvoid Add(XPoint3dCR vector);\n\n\tvoid SumOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, XPoint3dCR point);\n\n\tstatic XPoint3d FromInterpolate(XPoint3dCR pntA, double fraction, XPoint3dCR pntB);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector, double scaleFactor);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1, XPoint3dCR point2, double scaleFactor2);\n\n\tstatic XPoint3d FromScale(XPoint3d point, double scale);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, XVec3dCR vector);\n\n\tbool AlmostEqual(XPoint3d const & dataB) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB) const;\n\n\tbool AlmostEqual(XPoint3d const & dataB, double abstol) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB, double abstol) const;\n\n\tstatic bool AlmostEqual(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tstatic bool AlmostEqualXY(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tdouble DistanceSquared(XPoint3dCR point2) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XRay3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 三维的射线\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct ATGEOSET_EXPORT XRay3d\n{\n\n\tXPoint3d origin;\n\n\tXVec3d   direction;\n\n\tXRay3d();\n\tXRay3d(XPoint3dCR o, XVec3dCR d);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由起点和向量创建一条射线\n\t* \n\t* @param XPoint3dCR origin\n\t* @param XVec3dCR vector\n\t* @return XRay3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic XRay3d FromOriginAndVector(XPoint3dCR origin, XVec3dCR vector);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由2D的起点和另一个点创建一条射线\n\t* \n\t* @param XPoint2dCR point0\n\t* @param XPoint2dCR point1\n\t* @return XRay3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic XRay3d FromOriginAndTarget(XPoint2dCR pnt0, XPoint2dCR point1);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由3D的起点和另一个点创建一条射线\n\t* \n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point1\n\t* @return XRay3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic XRay3d FromOriginAndTarget(XPoint3dCR pnt0, XPoint3dCR point1);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由起点和向量初始化数据\n\t* \n\t* @param XPoint3dCR origin\n\t* @param XVec3dCR vector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid InitFromOriginAndVector(XPoint3dCR origin, XVec3dCR vector);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由两个平面相交初始化数据\n\t* \n\t* @param XPlane3dCR planeA\n\t* @param XPlane3dCR planeB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tbool InitFromPlanePlaneIntersection(XPlane3dCR planeA, XPlane3dCR planeB);\n\n\t/**\n\t* @brief 两条射线最接近的点\n\t* @details 计算（无界）射线 rayA 和（有界）射线 rayB 最接近的点,当两条射线平行返回false\n\t* \n\t* @param double & fractionA\n\t* @param double & fractionB\n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @param XRay3dCR rayA\n\t* @param XRay3dCR rayB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic bool ClosestApproachUnboundedRayUnboundedRay\n\t(\n\t\tdouble &fractionA,\n\t\tdouble &fractionB,\n\t\tXPoint3dR pntA,\n\t\tXPoint3dR pntB,\n\t\tXRay3dCR rayA,\n\t\tXRay3dCR rayB\n\t);\n\n\t/**\n\t* @brief 与平面相交\n\t* @details 计算(无界)射线与平面的交点,当射线与平面平行返回false\n\t* \n\t* @param XPoint3dR intPoint\n\t* @param double & intParam\n\t* @param XPlane3dCR plane\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tbool Intersect\n\t(\n\t\tXPoint3dR       intPoint,\n\t\tdouble          &intParam,\n\t\tXPlane3dCR      plane\n\t) const;\n\n\t/**\n\t* @brief 将点投影到射线上（无范围限制）\n\t*\n\t* @param XPoint3dR closestPoint\t投影点\n\t* @param double &closestParam\t最近点的参数\n\t* @param XPoint3dCR point\t\t空间点\n\t* @return bool\t\t\t\t\t是否成功\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tbool ProjectPointUnbounded\n\t(\n\t\tXPoint3dR       closestPoint,\n\t\tdouble          &closestParam,\n\t\tXPoint3dCR      point\n\t) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file CreateEntityExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};\n code of file CurveSet.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 线串类\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct CurveSet : RefCountedBase, xvector<IBasicCurvePtr>\n{\n\n\tenum BoundaryType\n\t{\n\n\t\tBOUNDARY_TYPE_None = 0,\n\n\t\tBOUNDARY_TYPE_Open = 1,\n\n\t\tBOUNDARY_TYPE_Outer = 2,\n\n\t\tBOUNDARY_TYPE_Inner = 3,\n\n\t\tBOUNDARY_TYPE_ParityRegion = 4,\n\n\t\tBOUNDARY_TYPE_UnionRegion = 5,\n\t};\n\n\tenum InOutClassification\n\t{\n\t\tINOUT_Unknown = 0,\n\t\tINOUT_In = 1,\n\t\tINOUT_Out = 2,\n\t\tINOUT_On = 3\n\t};\n\nprotected:\n\tBoundaryType    m_boundaryType;\n\npublic:\n\t/**\n\t* @brief 设定边界\n\t* @details 设定曲线的边界类型\n\t* \n\t* @param BoundaryType BoundaryType\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void SetBoundaryType(BoundaryType BoundaryType);\n\n\t/**\n\t* @brief 获取叶节点\n\t* @details 通过只计算叶节点的索引深度搜索以获取目标叶节点\n\t* \n\t* @param size_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr FindIndexedLeaf(size_t index) const;\n\n\t/**\n\t* @brief 获取索引值\n\t* @details 深度搜索以获取给定叶节点的索引值\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @param size_t & index\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool LeafToIndex(IBasicCurveCP primitive, size_t &index) const;\n\n\t/**\n\t* @brief 获取叶节点个数\n\t* @details 获取曲线的叶节点个数\n\t* \n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesBelow() const;\n\n\texplicit CurveSet(BoundaryType boundaryType) { m_boundaryType = boundaryType; }\n\n\t/**\n\t* @brief 是否单元素曲线\n\t* @details 查询曲线是否只有一个基本元素\n\t* \n\t* @return IBasicCurve\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurve::BasicCurveType HasSingleBasicCurve() const;\n\n\t/**\n\t* @brief 获取边界类型\n\t* @details 获取曲线的边界类型\n\t* \n\t* @return BoundaryType\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT BoundaryType GetBoundaryType() const;\n\n\t/**\n\t* @brief 查询是否开\n\t* @details 查询是否开路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsOpenPath() const;\n\n\t/**\n\t* @brief 查询是否闭\n\t* @details 查询是否闭路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsClosedPath() const;\n\n\t/**\n\t* @brief 查询实际开闭\n\t* @details 查询是否名义上是开路径但起点和终点连接\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsPhysicallyClosedPath() const;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个带有给定边界类型没有成员的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个具有单个基本元素和给定边界类型的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @param IBasicCurvePtr primitive\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType, IBasicCurvePtr primitive);\n\n\t/**\n\t* @brief 拷贝\n\t* @details 返回一个深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr Clone() const;\n\n\t/**\n\t* @brief 倒角拷贝\n\t* @details 返回一个深度拷贝,在连续曲线之间插入圆角\n\t* \n\t* @param double radius\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithFillets(double radius) const;\n\n\t/**\n\t* @brief 闭合拷贝\n\t* @details 返回一个深度拷贝,闭合终端点的间隙\n\t* \n\t* @param CurveGapOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithGapsClosed(CurveGapOptionsCR options) const;\n\n\t/**\n\t* @brief 添加元素\n\t* @details 递归遍历source, 将所有叶节点添加到this, 返回添加的数量\n\t* \n\t* @param CurveSetCR source\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t AddPrimitives(CurveSetCR source);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 添加单个基本曲线\n\t* \n\t* @param IBasicCurvePtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(IBasicCurvePtr child);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 将chile的所有元素作为曲线成员添加\n\t* \n\t* @param CurveSetPtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(CurveSetPtr child);\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过XY方向的偏移后的深度拷贝\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneOffsetCurvesXY(CurveOffsetOptionsCR options);\n\n\t/**\n\t* @brief 获取叶节点数量\n\t* @details 计算指定类型的叶节点数量\n\t* \n\t* @param IBasicCurve::BasicCurveType targetType\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesOfType(IBasicCurve::BasicCurveType targetType) const;\n\n\t/**\n\t* @brief 用区域分割曲线\n\t* @details 用指定区域分割曲线,分别返回区域内、外和区域上的曲线\n\t* \n\t* @param CurveSetCR region\n\t* @param CurveSetP insideCollector\n\t* @param CurveSetP outsideCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByRegion(CurveSetCR region, CurveSetP insideCollector, CurveSetP outsideCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 用平面分割曲线\n\t* @details 用指定平面分割曲线,分别返回平面上方、下方和平面内的曲线\n\t* \n\t* @param XPlane3dCR plane\n\t* @param CurveSetP belowCollector\n\t* @param CurveSetP aboveCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByPlane(XPlane3dCR plane, CurveSetP belowCollector, CurveSetP aboveCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 拆分拷贝\n\t* @details 返回一个深度拷贝,但所有的多线段被拆分成单条线段\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithExplodedLinestrings() const;\n\n\t/**\n\t* @brief 获取质心\n\t* @details 返回包含曲线的质心(不考虑孤立点)\n\t* \n\t* @param double & length\n\t* @param XPoint3dR centroid\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  WireCentroid(double &length, XPoint3dR centroid) const;\n\n\t/**\n\t* @brief 获取质心、法向量和面积\n\t* @details 返回质心、法向量和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param XVec3dR normal\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CentroidNormalArea(XPoint3dR centroid, XVec3dR normal, double &area) const;\n\n\t/**\n\t* @brief 获取质心和面积\n\t* @details 返回XY平面方向上的质心和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  CentroidAreaXY(XPoint3dR centroid, double &area) const;\n\n\t/**\n\t* @brief 投影范围\n\t* @details 当投影到射线的时候,返回射线参数的范围\n\t* \n\t* @param XRay3dCR ray\n\t* @return XRange1d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT XRange1d ProjectedParameterRange(XRay3dCR ray) const;\n\n    /**\n    * @brief 局部坐标拷贝\n    * @details 返回曲线的深度复制并转换为与曲线相关联的局部坐标系统。\n    * \n    * @param LocalCoordinateSelect frameType\n    * @param TransformR localToWorld\n    * @param TransformR worldToLocal\n    * @param XRange3dR localRange\n    * @return CurveSetPtr\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT CurveSetPtr CloneInLocalCoordinates\n    (\n    LocalCoordinateSelect frameType,\n    TransformR localToWorld,\n    TransformR worldToLocal,\n    XRange3dR localRange\n    ) const;\n\n\t/**\n    * @brief 获取有坐标系的元素\n    * @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame) const;\n\n\t/**\n\t* @brief 获取有坐标系的元素\n\t* @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @param int searchPreference\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame, int srchPref) const;\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param xvector<XPoint3d> const & points\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(xvector<XPoint3d> const&points,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint3dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint3dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建多边形\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint2dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint2dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建矩形\n\t* @details 根据 XY 坐标创建矩形\n\t* \n\t* @param double x0\n\t* @param double y0\n\t* @param double x1\n\t* @param double y1\n\t* @param double z\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateRectangle(double x0, double y0, double x1, double y1, double z,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由给定线段创建边界类型为 BOUNDARY_TYPE_None 的曲线\n\t* \n\t* @param xvector<XSegment3d> const & segments\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(xvector<XSegment3d> const &segs);\n\n\t/**\n\t* @brief 创建圆盘\n\t* @details 为一个完整的椭圆(圆)盘创建一个曲线向量结构\n\t* \n\t* @param XEllipse3dCR arc\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateDisk(XEllipse3dCR arc, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer, bool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个仅有单一元素的曲线结构\n\t* \n\t* @param IBasicCurvePtr child\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(IBasicCurvePtr child, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open);\n\n\t/**\n\t* @brief B样条拷贝\n\t* @details 返回一个深度拷贝,作为B样条曲线\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneAsBsplines() const;\n\n\t/**\n\t* @brief 添加边缘点\n\t* @details 为所有的子节点添加边缘点\n\t* \n\t* @param xvector <XPoint3d> & points\n\t* @param IFacetOptionsR options\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AddStrokePoints(xvector <XPoint3d> &points, IFacetOptionsR options) const;\n\n    /**\n\t* @brief 添加面点\n\t* @details 沿着曲线计算指定距离的点\n\t* \n\t* @param xvector<double> const & distances\n\t* @param xvector<CurveDescInfo> & locations\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool AddSpacedPoints(xvector<double> const &distances, xvector<CurveDescInfo> &locations) const;\n\n\t/**\n\t* @brief 添加边缘\n\t* @details 在结构中添加所有边缘\n\t* \n\t* @param xvector <xvector<xvector<XPoint3d>>> & regionsPoints\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CollectLinearGeometry(xvector <xvector<xvector<XPoint3d>> > &regionsPoints) const;\n\n\t/**\n\t* @brief 获取B样条曲线\n\t* @details 将一个表示开放或闭合路径作为单个B样条曲线\n\t* \n\t* @return ATBsplineCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetBsplineCurve() const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n    /**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索最接近曲线的点。如果曲线是一个区域类型,同时要在该区域的内部寻找投影\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XPoint3dR curveOrRegionPoint\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification ClosestCurveOrRegionPoint(XPoint3dCR spacePoint, XPoint3dR curveOrRegionPoint) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点和终点\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点终点和他们的正切值\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @param XVec3dR unitTangentA\n\t* @param XVec3dR unitTangentB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\t/**\n\t* @brief 获取起点\n\t* @details 返回曲线的起点\n\t* \n\t* @param XPoint3dR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线总长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length() const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线经过变换后的总长度\n\t* \n\t* @param XRotMatrixCP worldToLocal\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length(XRotMatrixCP worldToLocal) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线的xyz范围\n\t* \n\t* @param XRange3dR range\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线经过变换后的范围\n\t* \n\t* @param XRange3dR range\n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\t/**\n\t* @brief 查询索引\n\t* @details 返回指定元素的索引\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t FindIndexOfPrimitive(IBasicCurveCP primitive) const;\n\n\t/**\n\t* @brief 复制曲线指定范围的曲线\n\t* @details 复制曲线指定索引和比例参数范围内的部分\n\t* \n\t* @param int index0\n\t* @param double fraction0\n\t* @param int index1\n\t* @param double fraction1\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n    ATGEOSET_EXPORT CurveSetPtr CloneBetweenCyclicIndexedFractions(int index0, double fraction0, int index1, double fraction1) const;\n\n\t/**\n\t* @brief 反转拷贝\n\t* @details 返回一个所有元素都被反转的深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneReversed() const;\n\n\t/**\n\t* @brief 查询是否包含非线性元素\n\t* @details 如果曲线有一个不非线性元素,则返回true。\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ContainsNonLinearPrimitive() const;\n\n\t/**\n\t* @brief 计算交点\n\t* @details 计算曲线与给定平面的交点\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 平面选中\n\t* @details 计算封闭曲线与平面的交叉点,并以奇偶性规则为设为起始对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param double tolerance\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr PlaneSection(XPlane3dCR plane, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 空间点位置情况\n\t* @details 当以XY平面视角看,测试给定点在曲线内、曲线上还是曲线外\n\t* \n\t* @param XPoint3dCR xyz\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification PointInOnOutXY(XPoint3dCR xyz) const;\n\n\t/**\n\t* @brief 射线击中情况\n\t* @details 测试射线击中曲线在区域内、区域上还是区域外\n\t* \n\t* @param XRay3dCR ray\n\t* @param SolidDescInfoR hitDetail\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification RayPierceInOnOut\n\t(\n\t\tXRay3dCR ray,\n\t\tSolidDescInfoR hitDetail\n\t) const;\n\n\t/**\n\t* @brief 原地变换\n\t* @details 应用给定变换并修改曲线\n\t* \n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\t/**\n\t* @brief 原地反转\n\t* @details 将所有元素进行反转\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串内的单个点被消除,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串相邻的空间点被消除（可选）,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @param bool doSimplifyLinestrings\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives(bool doSimplifyLinestrings);\n\n\t/**\n\t* @brief 原地修改以简化线串\n\t* @details 消除线串相邻的空间点\n\t* \n\t* @param double distanceTol\n\t* @param bool eliminateOverdraw\n\t* @param bool wrap\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void SimplifyLinestrings(double distTol, bool eliminateOverdraw, bool wrap);\n\n\t/**\n\t* @brief 重排元素\n\t* @details 将曲线元素重新排序以缩小元素首尾相连的间隙\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT double ReorderForSmallGaps();\n\n\t/**\n\t* @brief 链接元素\n\t* @details 将曲线的元素首尾相连\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AssembleChains();\n\n\t/**\n\t* @brief 区域相并\n\t* @details 返回给定两个区域的并\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaUnion(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相减\n\t* @details 返回给定两个区域的减\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaDifference(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相交\n\t* @details 返回给定两个区域的交\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaIntersection(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 循环索引\n\t* @details 返回给定索引值关于集合大小的模\n\t* \n\t* @param int index\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT size_t CyclicIndex(int index) const;\n\n\t/**\n\t* @brief 循环获取值\n\t* @details 根据给定索引的循环索引获取元素\n\t* \n\t* @param ptrdiff_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr GetCyclic(ptrdiff_t index) const;\n\n    /**\n    * @brief 获取索引\n    * @details 返回给定曲线元素的详细细节所对应的元素索引\n    * \n    * @param CurveDescInfo const & location\n    * @return size_t\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT size_t CurveDescInfoIndex(CurveDescInfo const& location) const;\n\n\t/**\n\t* @brief 与平面相交\n\t* @details 计算封闭曲线与平面的交叉点,返回以奇偶性规则构造的起止点对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool AppendClosedCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过给定偏移后的深度拷贝.\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AreaOffset(CurveOffsetOptionsCR options) const;\n\n\t/**\n\t* @brief 返回从index0,fraction0到index1,fraction1的曲线段\n\t* \n\t* @param int index0 \n\t* @param double fraction0 \n\t* @param int index1 \n\t* @param double fraction1 \n\t* @param bool allowExtrapolation \n\t* @return ATGEOSET_EXPORT CurveSetPtr \n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/17\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneBetweenDirectedFractions(int index0, double fraction0, int index1, double fraction1, bool allowExtrapolation) const;\n\n\t/**\n\t* @brief 返回输入的曲线的布尔奇运算结果（区域）\n\t*\n\t* @param CurveSetCR regionA\t\t\t\t\t左操作数\n\t* @param CurveSetCR regionB\t\t\t\t\t右操作数\n\t* @param BasicCurvePtrPairVector * newToOld\t（可选）包含新旧曲线的数组指针\n\t* @return ATGEOSET_EXPORT CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/07/22\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaParity(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n};\n\nstruct CurveCurve\n{\nprivate: CurveCurve();\npublic:\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tCurveSetR curveA,\n\t\tCurveSetR curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB,\n\t\tXMatrix4dCP    pWorldToLocal,\n\t\tbool         extend = false\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveR curveA,\n\t\tCurveSetR     curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tCurveSetCR chainA,\n\t\tCurveSetCR chainB\n\t);\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            double &fractionA,\n            XPoint3dR pntA,\n            double &fractionB,\n            XPoint3dR pntB\n            );\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            CurveDescInfoR detailA,\n            CurveDescInfoR detailB\n            );\n};\n\nstruct PathLocationDetail\n{\nprivate:\n\tCurveDescInfo m_curveDetail;\n\tint32_t m_pathIndex;\n\tdouble m_pathDistance;\npublic:\n\n\tATGEOSET_EXPORT PathLocationDetail();\n\n\tATGEOSET_EXPORT PathLocationDetail(PathLocationDetail const &other);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, int pathIndex = -1, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, size_t pathIndex, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(double distance);\n\n\tATGEOSET_EXPORT XPoint3d Point() const;\n\n\tATGEOSET_EXPORT CurveDescInfo GetCurveDescInfo() const;\n\n    ATGEOSET_EXPORT double DistanceFromPathStart() const;\n};\n\nstruct CurveSetWithDistanceIndex : RefCountedBase\n{\nprivate:\n\n\tstruct PathEntry : PathLocationDetail\n\t{\n\t\tdouble             m_projectedDistance;\n\t\tXRange3d           m_range;\n\t\tPathEntry(PathLocationDetail const &pathDetail, double projectedDist, XRange3dCR range)\n\t\t\t: PathLocationDetail(pathDetail),\n\t\t\tm_projectedDistance(projectedDist),\n\t\t\tm_range(range)\n\t\t{\n\t\t}\n\t\tPathEntry(double distance) : PathLocationDetail(distance), m_projectedDistance(distance) {}\n\n\t\tdouble GetDistance(bool projected) const;\n\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistanceXY(PathEntry const &dataA, PathEntry const &dataB);\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistance(PathEntry const &dataA, PathEntry const &dataB);\n\t};\n\n\tCurveSetPtr m_curveVector;\n\txvector<PathEntry> m_locations;\n\tCurveSetPtr m_savedPrimitives;\n\n\tXRotMatrix m_worldToViewRotMatrix;\n\tXRotMatrix m_viewToWorldRotMatrix;\n\tXRotMatrix m_flattenToView;\n\tXMatrix4d m_worldToView;\n\n\texplicit CurveSetWithDistanceIndex(XRotMatrix worldToView);\n\n\tCurveSetWithDistanceIndex();\n\npublic:\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create(XRotMatrix worldToView);\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create();\n\n\tATGEOSET_EXPORT void SetPath(CurveSetPtr &path);\n\n\tATGEOSET_EXPORT bool SearchByDistanceFromPathStart\n\t(\n\t\tdouble targetDist,\n\t\tPathLocationDetail &detail\n\t) const;\n\n    ATGEOSET_EXPORT PathLocationDetail SearchClosestPointBounded\n    (\n    XPoint3dCR spacePoint,\n    bool computeDistAlong\n    ) const;\n};\n\nEND_ATEC_NAMESPACE\n\n", "output": "\nvoid CreateEntityExamples::BooleanCutExample()\n{\n    //创建剪切面\n  /*\n              pt4--------<---------pt3\n               |                   |\n               |         0         |\n               |                   |\n              pt1-------->---------pt2\n   */\n    XPoint3d pt1 = XPoint3d::FromXYZ(-25000, -25000, 0);\n    XPoint3d pt2 = XPoint3d::FromXYZ(25000, -25000, 0);\n    XPoint3d pt3 = XPoint3d::FromXYZ(25000, 25000, 0);\n    XPoint3d pt4 = XPoint3d::FromXYZ(-25000, 25000, 0);\n    xvector<XPoint3d> pts = { pt1, pt2, pt3, pt4, pt1 };\n    CurveSetPtr profilePtr = CurveSet::CreateLinear(pts, CurveSet::BOUNDARY_TYPE_Outer);\n    XRay3d rayY = XRay3d::FromOriginAndVector(XPoint3d::FromZero(), XVec3d::UnitY());\n    \n    Transform rotTrans = Transform::FromAxisAndRotationAngle(rayY, - PI * 0.25);\n    Transform translation = Transform::From(XPoint3d::FromXYZ(0, 0, 5000));\n    Transform trans = Transform::FromProduct(translation, rotTrans);\n    profilePtr->TransformInPlace(trans);\n\n    //获得当前激活的场景\n    ATSceneRefP pSceneref = atSceneRef_getActive();\n    if (pSceneref == nullptr)\n        return;\n\n    //添加到场景\n    HEATObject profileObject;\n    GeometryToATObject::ToObject(profileObject, *profilePtr, nullptr, pSceneref->Is3d(), *pSceneref);\n    if(profileObject.IsValid())\n        profileObject.AddToScene();\n\n    //创建长方体\n    ISolidCoreEntityPtr cuboidEntityPtr = GetCuboidEntity();\n    HEATObject cuboidObj;\n    GeometryToATObject::ToObject(cuboidObj, *cuboidEntityPtr, nullptr, *pSceneref);\n    if (cuboidObj.IsValid())\n        cuboidObj.AddToScene();\n\n    //剪切\n    EntityUtl::Modify::BooleanCut(cuboidEntityPtr, *profilePtr, EntityUtl::Modify::CutDirectionMode::Forward,\n        EntityUtl::Modify::CutDepthMode::All, 0, false, nullptr, 0);\n\n    //偏移,方便对比查看结果\n    Transform xTranslation = Transform::From(XPoint3d::FromXYZ(40000, 0, 0));\n    EntityUtl::Modify::TransformEntity(cuboidEntityPtr, xTranslation);\n    GeometryToATObject::ToObject(cuboidObj, *cuboidEntityPtr, nullptr, *pSceneref);\n    if (cuboidObj.IsValid())\n        cuboidObj.AddToScene();\n}\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};. You need to implement the function SewBodiesExample in the interface. Here are some apis that you can use and remember:\n code of file EntityUtl.h: \n\n#pragma once\n\n/**\n* @file EntityUtl.h\n*\n* @author SZEWC\n* @date 2022/04/27\n*/\n\n\n/**\n* @brief 以指定起终点截面的方式拉伸体\n* @details \n* \n* @param ISolidCoreEntityPtr & out \n* @param CurveSetCR startProfile \n* @param CurveSetCR endProfile \n* @param CurveSetCR path \n* @param ATSceneRefR scene \n* @param bool alignParallel \n* @param bool selfRepair \n* @param bool createSheet \n* @param XVec3dCP lockDirection \n* @param double const * twistAngle \n* @param double const * scale \n* @param XPoint3dCP scalePoint \n* @return ATEC \n*\n* @author SZEWEC\n* @since 2022/04/28\n*/\nENTITYUTIL_EXPORT ATEC::ATECStatus atSolid_EntityFromSweep\n(\nATEC::ATDataCore::ISolidCoreEntityPtr& out,\nATEC::CurveSetCR startProfile,\nATEC::CurveSetCR endProfile,\nATEC::CurveSetCR path,\nATEC::ATDataCore::ATSceneRefR scene,\nbool alignParallel,\nbool selfRepair,\nbool createSheet,\nATEC::XVec3dCP lockDirection = NULL,\ndouble const* twistAngle = NULL,\ndouble const* scale = NULL,\nATEC::XPoint3dCP scalePoint = NULL\n);\n\n/**\n* @brief 元件到体\n* @details 将给定元件转换成体\n* \n* @param BODY_TAG * bodyP\n* @param ATEC::TransformP bodyTransformP\n* @param ATEC::ATDataCore::ATObjectDescrP odP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @param UInt32 nodeId\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_elementToBody\n(\nBODY_TAG*       bodyP,          \nATEC::TransformP      bodyTransformP, \nATEC::ATDataCore::ATObjectDescrP odP,            \nATEC::ATDataCore::ATSceneRefP    SceneRef,       \nUInt32          nodeId = 1L     \n);\n\n/**\n* @brief 体到元件\n* @details 将给定体转换成元件\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\n* @param BODY_TAG bodyTag\n* @param bool wireframe\n* @param int uIsoParametrics\n* @param int vIsoParametrics\n* @param unsigned int useSmartIso\n* @param ATEC::ATDataCore::ATObjectP templateP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_bodyToObject\n(\nATEC::ATDataCore::ATObjectDescrH edPP,               \nBODY_TAG        bodyTag,            \nbool            wireframe,          \nint             uIsoParametrics,    \nint             vIsoParametrics,    \nunsigned int    useSmartIso,        \nATEC::ATDataCore::ATObjectP      tempP,          \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 面到元件\n* @details 将给定的面转换成等价的元件\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\n* @param FACE_TAG face\n* @param bool wireframe\n* @param int nIsoparametrics\n* @param ATEC::ATDataCore::ATObjectP templateP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_faceToObject\n(\nATEC::ATDataCore::ATObjectDescrH edPP,               \nFACE_TAG        face,               \nbool            wireframe,          \nint             nIsoparametrics,    \nATEC::ATDataCore::ATObjectP      tempP,          \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 体求减\n* @details 从 b2 中减去 b1\n* \n* @param BODY_TAG b2\n* @param BODY_TAG b1\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_subtract\n(\nBODY_TAG        b2,                \nBODY_TAG        b1                 \n);\n\n/**\n* @brief 面面相交\n* @details 计算两个面的交,结果以线体返回\n* \n* @param BODY_TAG * b\n* @param FACE_TAG f1\n* @param FACE_TAG f2\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_faceFaceIntersect\n(\nBODY_TAG        *b,                \nFACE_TAG        f1,                \nFACE_TAG        f2                 \n);\n\n/**\n* @brief 获取输入实体的面ID\n* \n* @param ATEC::FaceId * faceIdP\n* @param ENTITY_TAG ent\n* @param bool useHighestId\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/27\n*/\nENTITYUTIL_EXPORT int atSolid_idFromEntity\n(\nATEC::FaceId          *faceIdP,\nENTITY_TAG      ent,\nbool            useHighestId\n);\n\n/**\n* @brief 检查体\n* @details 检查输入体的几何、拓扑和尺寸有效性\n* \n* @param BODY_TAG body\n* @param bool checkGeometry\n* @param bool checkTopology\n* @param bool checkSize\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_checkBody\n(\nBODY_TAG        body,\nbool            chkGeometry,\nbool            chkTopology,\nbool            chkSize\n);\n\n/**\n* @brief 创建实体列表\n* @details 创建一个空的实体列表\n* \n* @param TAG_ENTITY_LIST * * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listCreate\n(\nTAG_ENTITY_LIST **lP            \n);\n\n/**\n* @brief 删除实体列表\n* @details 释放给定实体列表分配的内存\n* \n* @param TAG_ENTITY_LIST * * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listDelete\n(\nTAG_ENTITY_LIST **lP            \n);\n\n/**\n* @brief 列表添加元素\n* @details 往实体列表的尾部添加一个元素\n* \n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listAdd\n(\nTAG_ENTITY_LIST *lP,            \nENTITY_TAG      ent             \n);\n\n/**\n* @brief 列表添加元素\n* @details 往实体列表的尾部添加另一个列表的所有元素\n* \n* @param TAG_ENTITY_LIST * lDP\n* @param TAG_ENTITY_LIST * lSP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listAddList\n(\nTAG_ENTITY_LIST *lDP,\nTAG_ENTITY_LIST *lSP\n);\n\n/**\n* @brief 列表移除实体\n* @details 从列表中移除指定的实体\n* \n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listRemove\n(\nTAG_ENTITY_LIST *lP,\nENTITY_TAG      ent\n);\n\n/**\n* @brief 列表计数\n* @details 返回实体列表的元素个数\n* \n* @param int * count\n* @param TAG_ENTITY_LIST * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listCount\n(\nint             *count,         \nTAG_ENTITY_LIST *lP             \n);\n\n/**\n* @brief 列表查询实体\n* @details 在列表中搜索给定的实体并返回中索引,若不存在返回-1\n* \n* @param int * nth\n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listLookup\n(\nint             *nth,           \nTAG_ENTITY_LIST *lP,            \nENTITY_TAG      ent             \n);\n\n/**\n* @brief 查询列表指定位置的元素\n* @details 返回实体列表指定位置的元素\n* \n* @param ENTITY_TAG * entP\n* @param TAG_ENTITY_LIST * lP\n* @param int nth\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listNthEl\n(\nENTITY_TAG      *entP,          \nTAG_ENTITY_LIST *lP,            \nint             nth             \n);\n\n/**\n* @brief 清空列表\n* @details 移除列表中的所有元素\n* \n* @param TAG_ENTITY_LIST * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listEmpty\n(\nTAG_ENTITY_LIST *lP             \n);\n\nENTITYUTIL_EXPORT int atSolid_listCreateNonEntity (NON_ENTITY_LIST** lPP);\nENTITYUTIL_EXPORT int atSolid_listDeleteNonEntity (NON_ENTITY_LIST** lPP);\nENTITYUTIL_EXPORT int atSolid_listAddNonEntity (NON_ENTITY_LIST* lP, void* dataP);\nENTITYUTIL_EXPORT int atSolid_listCountNonEntity (int* countP, NON_ENTITY_LIST* lP);\nENTITYUTIL_EXPORT int atSolid_listNthNonEntity (void** dataPP, NON_ENTITY_LIST* lP, int nth);\n\n/**\n* @brief 偏移面\n* @details 将输入面的集合中所有面偏移指定距离,这些面必须属于同一个体\n* \n* @param TAG_ENTITY_LIST * pFaceList\n* @param double * pOffset\n* @param double tolerance\n* @param bool faceFaceCheck\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_offsetFaces\n(\nTAG_ENTITY_LIST *pFaceList,\ndouble          *pOffset,\ndouble          tolerance,\nbool            faceFaceCheck\n);\n\n/**\n* @brief 偏移线体\n* @details 返回给定线体偏移后的边缘\n* \n* @param TAG_ENTITY_LIST * pOffsetList\n* @param BODY_TAG wireBody\n* @param EDGE_TAG refEdge\n* @param ATEC::XPoint3d * pNormal\n* @param double distance\n* @param double tolerance\n* @param int gapFill\n* @param bool localCheck\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_offsetWire\n(\nTAG_ENTITY_LIST *pOffsetList,\nBODY_TAG        wireBody,\nEDGE_TAG        refEdge,\nATEC::XPoint3d        *pNormal,           \ndouble          distance,\ndouble          tolerance,\nint             gapFill,            \nbool            localCheck\n);\n\n/**\n* @brief 面上最近的点\n* @details 计算给定面上离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * clstPt\n* @param ATEC::XPoint3d * normal\n* @param ATEC::XPoint2d * param\n* @param ATEC::XPoint3d * testPt\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_closestPointToFace\n(\nATEC::XPoint3d        *clstPt,            \nATEC::XPoint3d        *normal,            \nATEC::XPoint2d        *param,             \nATEC::XPoint3d        *testPt,            \nFACE_TAG        face                \n);\n\n/**\n* @brief 边上最近的点\n* @details 计算给定边上离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * clstPt\n* @param double * param\n* @param ATEC::XPoint3d * testPt\n* @param EDGE_TAG edge\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_closestPointToEdge\n(\nATEC::XPoint3d        *clstPt,            \ndouble          *param,             \nATEC::XPoint3d        *testPt,            \nEDGE_TAG        edge               \n);\n\n/**\n* @brief 离点最近的点\n* @details 计算给定点离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * point\n* @param VERTEX_TAG vertex\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_pointFromVertex\n(\nATEC::XPoint3d        *point,             \nVERTEX_TAG      vertex              \n);\n\n/**\n* @brief 获取实体\n* @details 从给定起始点发射射线,返回体上与之相交的所有实体\n* \n* @param TAG_ENTITY_LIST * hits\n* @param double * * params\n* @param ATEC::XPoint3dP origin\n* @param ATEC::XPoint3dP dir\n* @param double radius\n* @param int type\n* @param BODY_TAG b\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getEntities\n(\nTAG_ENTITY_LIST *hits,              \ndouble          **params,           \nATEC::XPoint3dP       origin,             \nATEC::XPoint3dP       dir,                \ndouble          radius,             \nint             type,               \nBODY_TAG        b,                  \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 获取面实体\n* @details 从给定起始点发射射线,返回体上与之相交的第一个面以及相应的交点\n* \n* @param ATEC::XPoint3d * outPointP\n* @param ATEC::XPoint3d * outNormalP\n* @param FACE_TAG * outFaceP\n* @param ATEC::XPoint3d * inPointP\n* @param ATEC::XPoint3d * inNormalP\n* @param BODY_TAG body\n* @param bool backupRayOrigin\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_boresiteToFace\n(\nATEC::XPoint3d        *outPointP,         \nATEC::XPoint3d        *outNormalP,        \nFACE_TAG        *outFaceP,          \nATEC::XPoint3d        *inPointP,          \nATEC::XPoint3d        *inNormalP,         \nBODY_TAG        body,               \nbool            backupRayOrigin,    \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 曲线与面相交\n* @details 将给定部分曲线与给定的面相交,并返回曲线与面之间的交点以及相应的参数\n* \n* @param ATEC::XPoint3dP * pointPP\n* @param ATEC::XPoint2d * * faceUVPP\n* @param double * * curveParamPP\n* @param int * numIntsP\n* @param FACE_TAG face\n* @param CURVE_TAG curve\n* @param double startParam\n* @param double endParam\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_faceIntersectCurve\n(\nATEC::XPoint3dP       *pntPP,\nATEC::XPoint2d        **faceUVPP,\ndouble          **curveParamPP,\nint             *numIntsP,\nFACE_TAG        face,\nCURVE_TAG       curve,\ndouble          startParam,\ndouble          endParam\n);\n\n/**\n* @brief 获取体的包围盒\n* @details 计算给定体的包围盒\n* \n* @param ATEC::XPoint3d * lo\n* @param ATEC::XPoint3d * hi\n* @param BODY_TAG b\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getBodyBox\n(\nATEC::XPoint3d       *lo,             \nATEC::XPoint3d       *hi,             \nBODY_TAG       b                \n);\n\n/**\n* @brief 获取平滑的面列表\n* @details 向面的列表中添加一个面,并添加这个面与列表中的面的平滑连接\n* \n* @param TAG_ENTITY_LIST * listP\n* @param FACE_TAG face\n* @param bool addSmoothFaces\n* @param int allowedFaceTypeMask\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getSmoothFaceList\n(\nTAG_ENTITY_LIST *listP,\nFACE_TAG        face,\nbool            addSmoothFaces,\nint             allowedFaceTypeMask\n);\n\nenum SmoothEdgeType\n    {\n    SMOOTH_TYPE_NONE  = 0,\n    SMOOTH_TYPE_BLEND = 1,\n    SMOOTH_TYPE_TANGENT = 2\n    };\n\n/**\n* @brief 面的所有边\n* @details 返回构成面的所有边\n* \n* @param TAG_ENTITY_LIST * edgeListP\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getEdgeListFromFace\n(\nTAG_ENTITY_LIST *edgeListP,         \nFACE_TAG        face                \n);\n\n/**\n* @brief 线体是否G1连续\n* @details 查询线体是否关于所有点G1连续\n* \n* @param BODY_TAG wire\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_wireIsG1\n(\nBODY_TAG        wire\n);\n\n/**\n* @brief 实体最小距离\n* @details 计算两个实体之间的最小距离\n* \n* @param ATEC::XPoint3dP pPoint1\n* @param ATEC::XPoint3dP pPoint2\n* @param double * pDistance\n* @param ENTITY_TAG entity1\n* @param ENTITY_TAG entity2\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_minimumDistanceBetweenEntities\n(\nATEC::XPoint3dP           pPoint1,\nATEC::XPoint3dP           pPoint2,\ndouble              *pDist,\nENTITY_TAG          entity1,\nENTITY_TAG          entity2\n);\n\n/**\n* @brief 简化体\n* @details 尝试将B样条曲线和曲面简化为分析曲线和曲面\n* \n* @param BODY_TAG * bodyP\n* @param bool local\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_simplifyBody\n(\nBODY_TAG        *bodyP,\nbool            local\n);\n\n/**\n* @brief 开始转换\n* @details 将变换矩阵推入堆栈中\n* \n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_beginCurrTrans (ATEC::ATDataCore::ATSceneRefP SceneRef);\n\n/**\n* @brief 结束转换\n* @details 从堆栈中弹出brSolid_beginCurrTrans推入的变换矩阵\n* \n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_endCurrTrans ();\n\n/**\n* @brief 应用变换\n* @details 对体应用给定变换\n* \n* @param ENTITY_TAG entity\n* @param ATEC::TransformP transformP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_applyTransform\n(\nENTITY_TAG      entity,            \nATEC::TransformP      transformP         \n);\n\n/**\n* @brief 给薄面体加盖\n* @details 通过添加其他面封闭给定的薄面体并转换为体\n* \n* @param TAG_ENTITY_LIST * faces\n* @param BODY_TAG * lamina\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_capSurface\n(\nTAG_ENTITY_LIST *faces,             \nBODY_TAG        *lamina             \n);\n\n/**\n* @brief 逆转体\n* @details 将体中的所有面逆转方向\n* \n* @param BODY_TAG body\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_reverseBody\n(\nBODY_TAG        body               \n);\n\n/**\n* @brief 删除实体\n* @details 删除给定的实体\n* \n* @param ENTITY_TAG e\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_deleteEntity\n(\nENTITY_TAG      e                  \n);\n\n/**\n* @brief 复制体\n* @details 创建给定体的一个复制\n* \n* @param BODY_TAG * copy\n* @param BODY_TAG source\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_copyBody\n(\nBODY_TAG        *copy,\nBODY_TAG        source\n);\n\n/**\n* @brief 删除体\n* @details 释放体所分配的内存\n* \n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_freeBody\n(\nBODY_TAG        body               \n);\n\n/**\n* @brief 释放内存\n* @details 释放列表所分配的内存\n* \n* @param void * v\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_free\n(\nvoid            *v\n);\n\n/**\n* @brief 边缘数据\n* @details 返回边缘的拓扑和几何信息\n* \n* @param VERTEX_TAG * startVertexP\n* @param VERTEX_TAG * endVertexP\n* @param ATEC::XPoint3d * startPointP\n* @param ATEC::XPoint3d * endPointP\n* @param double * startParamP\n* @param double * endParamP\n* @param COEDGE_TAG * coEdgeP\n* @param CURVE_TAG * curveP\n* @param bool * reversedP\n* @param EDGE_TAG edge\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_edgeData\n(\nVERTEX_TAG      *startVertexP,  \nVERTEX_TAG      *endVertexP,    \nATEC::XPoint3d        *startPointP,   \nATEC::XPoint3d        *endPointP,     \ndouble          *startParamP,   \ndouble          *endParamP,     \nCOEDGE_TAG      *coEdgeP,       \nCURVE_TAG       *curveP,        \nbool            *reversedP,     \nEDGE_TAG        edge            \n);\n\n/**\n* @brief 获取所有边\n* @details 返回体的所有边列表\n* \n* @param TAG_ENTITY_LIST * listP\n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getEdgeList\n(\nTAG_ENTITY_LIST *listP,             \nBODY_TAG        body                \n);\n\n/**\n* @brief 获取所有面\n* @details 返回体的所有面列表\n* \n* @param TAG_ENTITY_LIST * listP\n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getFaceList\n(\nTAG_ENTITY_LIST *listP,             \nBODY_TAG        body                \n);\n\n/**\n* @brief 体的首条边\n* @details 返回体的第一条边\n* \n* @param EDGE_TAG * pEdge\n* @param BODY_TAG body\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_bodyAskFirstEdge\n(\nEDGE_TAG        *pEdge,\nBODY_TAG        body\n);\n\n/**\n* @brief 创建空体\n* @details 创建一个最小的仅包含一个点的体\n* \n* @param BODY_TAG * b\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_body\n(\nBODY_TAG        *b                  \n);\n\n/**\n* @brief 面集到薄面体\n* @details 将输入的面拼接并创建一个薄面体,所有的面必须来自同一个体\n* \n* @param BODY_TAG * sheetP\n* @param TAG_ENTITY_LIST * faceListP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sheetFromFaces\n(\nBODY_TAG        *sheetP,            \nTAG_ENTITY_LIST *faceListP          \n);\n\n/**\n* @brief 面到薄面体\n* @details 根据输入的单个面创建一个薄面体\n* \n* @param BODY_TAG * sheetP\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sheetFromFace\n(\nBODY_TAG        *sheetP,          \nFACE_TAG        face              \n);\n\n/**\n* @brief 揭开面\n* @details 将输入的面从所属的薄面体中移除\n* \n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_uncoverFace\n(\nFACE_TAG        face\n);\n\n/**\n* @brief 两个体压印\n* @details 计算两个体的交并把交压印到目标体或两个体上\n* \n* @param TAG_ENTITY_LIST * pTargetEdges\n* @param TAG_ENTITY_LIST * pToolEdges\n* @param BODY_TAG target\n* @param BODY_TAG tool\n* @param double tolerance\n* @param bool imprintTool\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintBodies\n(\nTAG_ENTITY_LIST *pTargetEdges,  \nTAG_ENTITY_LIST *pToolEdges,    \nBODY_TAG        target,         \nBODY_TAG        tool,           \ndouble          tolerance,      \nbool            imprintTool     \n);\n\nENTITYUTIL_EXPORT bool atSolid_isSmartObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetOrSolidObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSceneerObject (ATEC::ATDataCore::ATObjectDescrP odP);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetBody (BODY_TAG bodyTag);\n\nENTITYUTIL_EXPORT bool atSolid_isWireBody (BODY_TAG bodyTag);\n\nENTITYUTIL_EXPORT bool atSolid_isFace (ENTITY_TAG entityTag);\n\nENTITYUTIL_EXPORT bool atSolid_isEdge (ENTITY_TAG entityTag);\n\n/**\n* @brief 获取FACE_TYPE\n* @details 返回FACE_TYPE常数\n* \n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_faceType ();\n\n/**\n* @brief 获取EDGE_TYPE\n* @details 返回EDGE_TYPE常数\n* \n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_edgeType ();\n\nENTITYUTIL_EXPORT void atSolid_moveBoresiteToEyePoint\n(\nATEC::XPoint3d        *pBorePoint,\nATEC::XPoint3d        *pBoreDirection,\nBODY_TAG        pBody\n);\n\nENTITYUTIL_EXPORT void atSolid_displayFace\n(\nTransDescrP     *transientPP,   \nFACE_TAG        faceP,\nbool            display,\nbool            showSmoothFaces,\nint             allowedFaceTypeMask,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             weight,\nint             style\n);\n\nENTITYUTIL_EXPORT void atSolid_displayEdge\n(\nTransDescrP     *transientPP,   \nEDGE_TAG        edgeP,          \nbool            display,        \nSmoothEdgeType  smoothSequence, \nbool            showStart,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             weight,\nint             style\n);\n\nENTITYUTIL_EXPORT int atSolid_createMark\n(\nint             *markP\n);\n\nENTITYUTIL_EXPORT int atSolid_gotoMark\n(\nint             mark\n);\n\nENTITYUTIL_EXPORT int atSolid_deleteMark\n(\nint             mark\n);\n\nENTITYUTIL_EXPORT void atSolid_getBoresiteWithBodyTransform\n(\nATEC::XPoint3dP       borePointP,         \nATEC::XPoint3dP       boreDirectionP,     \nATEC::XPoint3dCP      pntP,             \nint             view,               \nATEC::ATDataCore::ATSceneRefP    SceneRef,           \nATEC::TransformCP     bodyTransformP,     \nbool            useACS,             \nbool            frontClipBorePoint  \n);\n\nENTITYUTIL_EXPORT void atSolid_displayFaceWithBodyTransform\n(\nTransDescrP     *transientPP,       \nFACE_TAG        faceP,\nATEC::TransformP      bodyTransformP,     \nbool            display,\nbool            showSmoothFaces,\nint             nIsoParametrics,    \nint             allowedFaceTypeMask,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             style,\nint             weight\n);\n\nENTITYUTIL_EXPORT void atSolid_displayEdgeWithBodyTransform\n(\nTransDescrP     *transientPP,       \nEDGE_TAG        edgeP,              \nATEC::TransformP      bodyTransformP,     \nbool            display,            \nSmoothEdgeType  smoothSequence,     \nbool            showStart,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nUInt32          color,\nlong            style,\nUInt32          weight,\nbool            showAllEdgesWithSameId\n);\n\nENTITYUTIL_EXPORT int atSolid_getSharedEdgesOfFaces\n(\nTAG_ENTITY_LIST     *edgeListP,\nTAG_ENTITY_LIST     *faceListP\n);\n\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_getBSplineFromSmartSurface\n(\nATEC::ATBsplineSurface*   pBSurface,\nBODY_TAG            bodyP\n);\n\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_getBSplineFromSmartSurface2\n(\nATEC::ATBsplineSurface*   pBSurface,\nBODY_TAG            bodyP,\nATEC::TransformP          bodyTransformP,\nATEC::ATDataCore::ATSceneRefP        SceneRef\n);\n\n#define     SOLIDTEMPLATE_OPTION_None               0\n#define     SOLIDTEMPLATE_OPTION_PreserveElemId     1\n#define     SOLIDTEMPLATE_OPTION_PrimaryClass       2\n\nENTITYUTIL_EXPORT ATEC::ATDataCore::ATObjectP  atSolid_createBrepTemplateForOdP\n(\nATEC::ATDataCore::ATObjectP          objectP,   \nATEC::ATDataCore::ATObjectDescrCP    odP,        \nUInt32              options     \n);\n\n/**\n* @brief 沿线拉伸体\n* @details 沿着输入的线体拉伸线体或薄面体\n* \n* @param BODY_TAG * bodyP\n* @param BODY_TAG wireBody\n* @param ATEC::XPoint3d * pathStartP\n* @param double shell\n* @param bool capped\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sweepBodyWire\n(\n\tBODY_TAG        *bodyP,\n\tBODY_TAG        wireBody,\n\tATEC::XPoint3d        *pathStartP,\n\tdouble          shell,\n\tbool            capped,\n\tATEC::ATDataCore::ATSceneRefP    SceneRef\n);\n\n/**\n* @brief 根据面ID从输入的体中寻找面\n* \n* @param FACE_TAG * faceP \n* @param ATEC::FaceId * faceIdP \n* @param BODY_TAG body \n* @return ENTITYUTIL_EXPORT int \n*\n* @author SZEWEC\n* @since 2022/04/29\n*/\nENTITYUTIL_EXPORT int atSolid_faceFromId\n(\n\tFACE_TAG        *faceP,\n\tATEC::FaceId          *faceIdP,\n\tBODY_TAG        body\n);\n\n/**\n* @brief 使用输入的边生成元素,当元素代表边的一部分的时候该接口接收一个起始和终止参数\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\t\t生成的元素\n* @param ATEC::ATDataCore::ATObjectP templateP\t\t生成元素的模板,传NULL时使用默认样式\n* @param EDGE_TAG edge\t\t\t\t\t\t\t\t边\n* @param double * startParameterP\t\t\t\t\t传NULL时使用边的起点,否则为该参数指定的点（位于边上）作为起点\n* @param double * endParameterP\t\t\t\t\t\t传NULL时使用边的终点,否则为该参数指定的点（位于边上）作为终点\n* @param ATEC::ATDataCore::ATScenesRefP SceneRef\t生成的元素所在的场景\n* @return ENTITYUTIL_EXPORT int\t\t\t\t\t\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/05\n*/\nENTITYUTIL_EXPORT int atSolid_elementFromEdge\n(\n\tATEC::ATDataCore::ATObjectDescrH edPP,\n\tATEC::ATDataCore::ATObjectP      tempP,\n\tEDGE_TAG        edge,\n\tdouble          *startParameterP,\n\tdouble          *endParameterP,\n\tATEC::ATDataCore::ATSceneRefP    SceneRef\n);\n\n/**\n* @brief 将给定的曲线压印到实体上\n*\n* @param TAG_ENTITY_LIST * pImprintList\t\t[out] 压印到实体上的结果曲线,或者NULL\n* @param BODY_TAG body\t\t\t\t\t\t[in ] 实体\n* @param TAG_ENTITY_LIST * pEdgeList\t\t[in ] 待压印的曲线\n* @param ATEC::XPoint3d * pVector\t\t\t[in ] 压印（投影）的方向\n* @param double tolerance\t\t\t\t\t[in ] 容差,用于解决容差问题与计算参数空间曲线需要\n* @return ENTITYUTIL_EXPORT ATEC::StatusInt\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/30\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintCurveSet\n(\n\tTAG_ENTITY_LIST *pImprintList,\n\tBODY_TAG        body,\n\tTAG_ENTITY_LIST *pEdgeList,\n\tATEC::XPoint3d        *pVector,\n\tdouble          tolerance\n);\n\n/**\n* @brief 将给定的曲线沿着面的法线方向压印到实体上\n*\n* @param TAG_ENTITY_LIST * pImprintList\t\t[out] 压印到实体上的结果曲线,或者NULL\n* @param BODY_TAG body\t\t\t\t\t\t[in ] 实体\n* @param TAG_ENTITY_LIST * pEdgeList\t\t[in ] 待压印的曲线\n* @param double tolerance\t\t\t\t\t[in ] 容差,用于解决容差问题与计算参数空间曲线需要\n* @return ENTITYUTIL_EXPORT ATEC::StatusInt\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/30\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintCurveNormal\n(\n\tTAG_ENTITY_LIST *pImprintList,\n\tBODY_TAG        body,\n\tTAG_ENTITY_LIST *pEdgeList,\n\tdouble          tolerance\n);\n\n\n code of file XPoint3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n /**\n * @brief 3D绌洪棿鐐圭被\n * @author SZEWC\n * @since 2022/04/13\n*/\nstruct ATGEOSET_EXPORT XPoint3d\n{\n\n\tdouble x;\n\n\tdouble y;\n\n\tdouble z;\n\n\tstatic XPoint3d From(double x, double y, double z = 0.0);\n\n\tstatic XPoint3d From(XPoint2dCR xy);\n\n\tstatic XPoint3d FromZero();\n\n\tstatic XPoint3d FromOne();\n\n\tstatic XPoint3d FromXYZ(double x, double y, double z);\n\n\tvoid Swap(XPoint3dR other);\n\n\tdouble DotDifference(XPoint3dCR origin, XVec3dCR vector) const;\n\n\tvoid Zero();\n\n\tvoid Init(XPoint2dCR source);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double ay);\n\n\tvoid SetComponent(double a, int index);\n\n\tdouble GetComponent(int index) const;\n\n\tvoid Interpolate(XPoint3dCR pnt0, double fractionParameter, XPoint3dCR point1);\n\n\tdouble Distance(XPoint3dCR point2) const;\n\n\tdouble DistanceXY(XPoint3dCR point2) const;\n\n\tbool DistanceXY(XPoint3dCR otherPoint, XMatrix4dCP matrix, double &distance) const;\n\n\tbool IsEqual(XPoint3dCR point2) const;\n\n\tbool IsEqual(XPoint3dCR point2, double tolerance) const;\n\n\tbool IsDisconnect() const;\n\n\tvoid InitDisconnect();\n\n\tvoid Init(XVec3dCR vector);\n\n\tvoid Subtract(XPoint3dCR base, XVec3dCR vector);\n\n\tvoid Add(XVec3dCR vector);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2, XVec3dCR point3, double scale3);\n\n\tvoid CrossProduct(XPoint3dCR point1, XPoint3dCR point2);\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble AngleTo(XPoint3dCR point2) const;\n\n\tvoid RotateXY(XPoint3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tdouble MagnitudeXY() const;\n\n\tvoid Scale(XPoint3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XPoint3dCR vector);\n\n\tvoid Negate();\n\n\tdouble Normalize(XPoint3dCR vector);\n\n\tdouble Normalize();\n\n\tvoid Subtract(XPoint3dCR point2);\n\n\tvoid DifferenceOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2, XPoint3dCR point3, double scale3);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2, XPoint3dCR point3, double a3);\n\n\tvoid Add(XPoint3dCR vector);\n\n\tvoid SumOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, XPoint3dCR point);\n\n\tstatic XPoint3d FromInterpolate(XPoint3dCR pntA, double fraction, XPoint3dCR pntB);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector, double scaleFactor);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1, XPoint3dCR point2, double scaleFactor2);\n\n\tstatic XPoint3d FromScale(XPoint3d point, double scale);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, XVec3dCR vector);\n\n\tbool AlmostEqual(XPoint3d const & dataB) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB) const;\n\n\tbool AlmostEqual(XPoint3d const & dataB, double abstol) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB, double abstol) const;\n\n\tstatic bool AlmostEqual(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tstatic bool AlmostEqualXY(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tdouble DistanceSquared(XPoint3dCR point2) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file CreateEntityExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};\n code of file CurveSet.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 线串类\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct CurveSet : RefCountedBase, xvector<IBasicCurvePtr>\n{\n\n\tenum BoundaryType\n\t{\n\n\t\tBOUNDARY_TYPE_None = 0,\n\n\t\tBOUNDARY_TYPE_Open = 1,\n\n\t\tBOUNDARY_TYPE_Outer = 2,\n\n\t\tBOUNDARY_TYPE_Inner = 3,\n\n\t\tBOUNDARY_TYPE_ParityRegion = 4,\n\n\t\tBOUNDARY_TYPE_UnionRegion = 5,\n\t};\n\n\tenum InOutClassification\n\t{\n\t\tINOUT_Unknown = 0,\n\t\tINOUT_In = 1,\n\t\tINOUT_Out = 2,\n\t\tINOUT_On = 3\n\t};\n\nprotected:\n\tBoundaryType    m_boundaryType;\n\npublic:\n\t/**\n\t* @brief 设定边界\n\t* @details 设定曲线的边界类型\n\t* \n\t* @param BoundaryType BoundaryType\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void SetBoundaryType(BoundaryType BoundaryType);\n\n\t/**\n\t* @brief 获取叶节点\n\t* @details 通过只计算叶节点的索引深度搜索以获取目标叶节点\n\t* \n\t* @param size_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr FindIndexedLeaf(size_t index) const;\n\n\t/**\n\t* @brief 获取索引值\n\t* @details 深度搜索以获取给定叶节点的索引值\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @param size_t & index\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool LeafToIndex(IBasicCurveCP primitive, size_t &index) const;\n\n\t/**\n\t* @brief 获取叶节点个数\n\t* @details 获取曲线的叶节点个数\n\t* \n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesBelow() const;\n\n\texplicit CurveSet(BoundaryType boundaryType) { m_boundaryType = boundaryType; }\n\n\t/**\n\t* @brief 是否单元素曲线\n\t* @details 查询曲线是否只有一个基本元素\n\t* \n\t* @return IBasicCurve\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurve::BasicCurveType HasSingleBasicCurve() const;\n\n\t/**\n\t* @brief 获取边界类型\n\t* @details 获取曲线的边界类型\n\t* \n\t* @return BoundaryType\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT BoundaryType GetBoundaryType() const;\n\n\t/**\n\t* @brief 查询是否开\n\t* @details 查询是否开路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsOpenPath() const;\n\n\t/**\n\t* @brief 查询是否闭\n\t* @details 查询是否闭路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsClosedPath() const;\n\n\t/**\n\t* @brief 查询实际开闭\n\t* @details 查询是否名义上是开路径但起点和终点连接\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsPhysicallyClosedPath() const;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个带有给定边界类型没有成员的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个具有单个基本元素和给定边界类型的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @param IBasicCurvePtr primitive\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType, IBasicCurvePtr primitive);\n\n\t/**\n\t* @brief 拷贝\n\t* @details 返回一个深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr Clone() const;\n\n\t/**\n\t* @brief 倒角拷贝\n\t* @details 返回一个深度拷贝,在连续曲线之间插入圆角\n\t* \n\t* @param double radius\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithFillets(double radius) const;\n\n\t/**\n\t* @brief 闭合拷贝\n\t* @details 返回一个深度拷贝,闭合终端点的间隙\n\t* \n\t* @param CurveGapOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithGapsClosed(CurveGapOptionsCR options) const;\n\n\t/**\n\t* @brief 添加元素\n\t* @details 递归遍历source, 将所有叶节点添加到this, 返回添加的数量\n\t* \n\t* @param CurveSetCR source\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t AddPrimitives(CurveSetCR source);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 添加单个基本曲线\n\t* \n\t* @param IBasicCurvePtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(IBasicCurvePtr child);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 将chile的所有元素作为曲线成员添加\n\t* \n\t* @param CurveSetPtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(CurveSetPtr child);\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过XY方向的偏移后的深度拷贝\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneOffsetCurvesXY(CurveOffsetOptionsCR options);\n\n\t/**\n\t* @brief 获取叶节点数量\n\t* @details 计算指定类型的叶节点数量\n\t* \n\t* @param IBasicCurve::BasicCurveType targetType\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesOfType(IBasicCurve::BasicCurveType targetType) const;\n\n\t/**\n\t* @brief 用区域分割曲线\n\t* @details 用指定区域分割曲线,分别返回区域内、外和区域上的曲线\n\t* \n\t* @param CurveSetCR region\n\t* @param CurveSetP insideCollector\n\t* @param CurveSetP outsideCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByRegion(CurveSetCR region, CurveSetP insideCollector, CurveSetP outsideCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 用平面分割曲线\n\t* @details 用指定平面分割曲线,分别返回平面上方、下方和平面内的曲线\n\t* \n\t* @param XPlane3dCR plane\n\t* @param CurveSetP belowCollector\n\t* @param CurveSetP aboveCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByPlane(XPlane3dCR plane, CurveSetP belowCollector, CurveSetP aboveCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 拆分拷贝\n\t* @details 返回一个深度拷贝,但所有的多线段被拆分成单条线段\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithExplodedLinestrings() const;\n\n\t/**\n\t* @brief 获取质心\n\t* @details 返回包含曲线的质心(不考虑孤立点)\n\t* \n\t* @param double & length\n\t* @param XPoint3dR centroid\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  WireCentroid(double &length, XPoint3dR centroid) const;\n\n\t/**\n\t* @brief 获取质心、法向量和面积\n\t* @details 返回质心、法向量和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param XVec3dR normal\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CentroidNormalArea(XPoint3dR centroid, XVec3dR normal, double &area) const;\n\n\t/**\n\t* @brief 获取质心和面积\n\t* @details 返回XY平面方向上的质心和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  CentroidAreaXY(XPoint3dR centroid, double &area) const;\n\n\t/**\n\t* @brief 投影范围\n\t* @details 当投影到射线的时候,返回射线参数的范围\n\t* \n\t* @param XRay3dCR ray\n\t* @return XRange1d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT XRange1d ProjectedParameterRange(XRay3dCR ray) const;\n\n    /**\n    * @brief 局部坐标拷贝\n    * @details 返回曲线的深度复制并转换为与曲线相关联的局部坐标系统。\n    * \n    * @param LocalCoordinateSelect frameType\n    * @param TransformR localToWorld\n    * @param TransformR worldToLocal\n    * @param XRange3dR localRange\n    * @return CurveSetPtr\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT CurveSetPtr CloneInLocalCoordinates\n    (\n    LocalCoordinateSelect frameType,\n    TransformR localToWorld,\n    TransformR worldToLocal,\n    XRange3dR localRange\n    ) const;\n\n\t/**\n    * @brief 获取有坐标系的元素\n    * @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame) const;\n\n\t/**\n\t* @brief 获取有坐标系的元素\n\t* @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @param int searchPreference\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame, int srchPref) const;\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param xvector<XPoint3d> const & points\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(xvector<XPoint3d> const&points,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint3dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint3dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建多边形\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint2dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint2dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建矩形\n\t* @details 根据 XY 坐标创建矩形\n\t* \n\t* @param double x0\n\t* @param double y0\n\t* @param double x1\n\t* @param double y1\n\t* @param double z\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateRectangle(double x0, double y0, double x1, double y1, double z,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由给定线段创建边界类型为 BOUNDARY_TYPE_None 的曲线\n\t* \n\t* @param xvector<XSegment3d> const & segments\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(xvector<XSegment3d> const &segs);\n\n\t/**\n\t* @brief 创建圆盘\n\t* @details 为一个完整的椭圆(圆)盘创建一个曲线向量结构\n\t* \n\t* @param XEllipse3dCR arc\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateDisk(XEllipse3dCR arc, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer, bool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个仅有单一元素的曲线结构\n\t* \n\t* @param IBasicCurvePtr child\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(IBasicCurvePtr child, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open);\n\n\t/**\n\t* @brief B样条拷贝\n\t* @details 返回一个深度拷贝,作为B样条曲线\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneAsBsplines() const;\n\n\t/**\n\t* @brief 添加边缘点\n\t* @details 为所有的子节点添加边缘点\n\t* \n\t* @param xvector <XPoint3d> & points\n\t* @param IFacetOptionsR options\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AddStrokePoints(xvector <XPoint3d> &points, IFacetOptionsR options) const;\n\n    /**\n\t* @brief 添加面点\n\t* @details 沿着曲线计算指定距离的点\n\t* \n\t* @param xvector<double> const & distances\n\t* @param xvector<CurveDescInfo> & locations\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool AddSpacedPoints(xvector<double> const &distances, xvector<CurveDescInfo> &locations) const;\n\n\t/**\n\t* @brief 添加边缘\n\t* @details 在结构中添加所有边缘\n\t* \n\t* @param xvector <xvector<xvector<XPoint3d>>> & regionsPoints\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CollectLinearGeometry(xvector <xvector<xvector<XPoint3d>> > &regionsPoints) const;\n\n\t/**\n\t* @brief 获取B样条曲线\n\t* @details 将一个表示开放或闭合路径作为单个B样条曲线\n\t* \n\t* @return ATBsplineCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetBsplineCurve() const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n    /**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索最接近曲线的点。如果曲线是一个区域类型,同时要在该区域的内部寻找投影\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XPoint3dR curveOrRegionPoint\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification ClosestCurveOrRegionPoint(XPoint3dCR spacePoint, XPoint3dR curveOrRegionPoint) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点和终点\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点终点和他们的正切值\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @param XVec3dR unitTangentA\n\t* @param XVec3dR unitTangentB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\t/**\n\t* @brief 获取起点\n\t* @details 返回曲线的起点\n\t* \n\t* @param XPoint3dR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线总长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length() const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线经过变换后的总长度\n\t* \n\t* @param XRotMatrixCP worldToLocal\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length(XRotMatrixCP worldToLocal) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线的xyz范围\n\t* \n\t* @param XRange3dR range\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线经过变换后的范围\n\t* \n\t* @param XRange3dR range\n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\t/**\n\t* @brief 查询索引\n\t* @details 返回指定元素的索引\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t FindIndexOfPrimitive(IBasicCurveCP primitive) const;\n\n\t/**\n\t* @brief 复制曲线指定范围的曲线\n\t* @details 复制曲线指定索引和比例参数范围内的部分\n\t* \n\t* @param int index0\n\t* @param double fraction0\n\t* @param int index1\n\t* @param double fraction1\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n    ATGEOSET_EXPORT CurveSetPtr CloneBetweenCyclicIndexedFractions(int index0, double fraction0, int index1, double fraction1) const;\n\n\t/**\n\t* @brief 反转拷贝\n\t* @details 返回一个所有元素都被反转的深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneReversed() const;\n\n\t/**\n\t* @brief 查询是否包含非线性元素\n\t* @details 如果曲线有一个不非线性元素,则返回true。\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ContainsNonLinearPrimitive() const;\n\n\t/**\n\t* @brief 计算交点\n\t* @details 计算曲线与给定平面的交点\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 平面选中\n\t* @details 计算封闭曲线与平面的交叉点,并以奇偶性规则为设为起始对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param double tolerance\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr PlaneSection(XPlane3dCR plane, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 空间点位置情况\n\t* @details 当以XY平面视角看,测试给定点在曲线内、曲线上还是曲线外\n\t* \n\t* @param XPoint3dCR xyz\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification PointInOnOutXY(XPoint3dCR xyz) const;\n\n\t/**\n\t* @brief 射线击中情况\n\t* @details 测试射线击中曲线在区域内、区域上还是区域外\n\t* \n\t* @param XRay3dCR ray\n\t* @param SolidDescInfoR hitDetail\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification RayPierceInOnOut\n\t(\n\t\tXRay3dCR ray,\n\t\tSolidDescInfoR hitDetail\n\t) const;\n\n\t/**\n\t* @brief 原地变换\n\t* @details 应用给定变换并修改曲线\n\t* \n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\t/**\n\t* @brief 原地反转\n\t* @details 将所有元素进行反转\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串内的单个点被消除,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串相邻的空间点被消除（可选）,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @param bool doSimplifyLinestrings\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives(bool doSimplifyLinestrings);\n\n\t/**\n\t* @brief 原地修改以简化线串\n\t* @details 消除线串相邻的空间点\n\t* \n\t* @param double distanceTol\n\t* @param bool eliminateOverdraw\n\t* @param bool wrap\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void SimplifyLinestrings(double distTol, bool eliminateOverdraw, bool wrap);\n\n\t/**\n\t* @brief 重排元素\n\t* @details 将曲线元素重新排序以缩小元素首尾相连的间隙\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT double ReorderForSmallGaps();\n\n\t/**\n\t* @brief 链接元素\n\t* @details 将曲线的元素首尾相连\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AssembleChains();\n\n\t/**\n\t* @brief 区域相并\n\t* @details 返回给定两个区域的并\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaUnion(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相减\n\t* @details 返回给定两个区域的减\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaDifference(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相交\n\t* @details 返回给定两个区域的交\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaIntersection(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 循环索引\n\t* @details 返回给定索引值关于集合大小的模\n\t* \n\t* @param int index\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT size_t CyclicIndex(int index) const;\n\n\t/**\n\t* @brief 循环获取值\n\t* @details 根据给定索引的循环索引获取元素\n\t* \n\t* @param ptrdiff_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr GetCyclic(ptrdiff_t index) const;\n\n    /**\n    * @brief 获取索引\n    * @details 返回给定曲线元素的详细细节所对应的元素索引\n    * \n    * @param CurveDescInfo const & location\n    * @return size_t\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT size_t CurveDescInfoIndex(CurveDescInfo const& location) const;\n\n\t/**\n\t* @brief 与平面相交\n\t* @details 计算封闭曲线与平面的交叉点,返回以奇偶性规则构造的起止点对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool AppendClosedCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过给定偏移后的深度拷贝.\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AreaOffset(CurveOffsetOptionsCR options) const;\n\n\t/**\n\t* @brief 返回从index0,fraction0到index1,fraction1的曲线段\n\t* \n\t* @param int index0 \n\t* @param double fraction0 \n\t* @param int index1 \n\t* @param double fraction1 \n\t* @param bool allowExtrapolation \n\t* @return ATGEOSET_EXPORT CurveSetPtr \n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/17\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneBetweenDirectedFractions(int index0, double fraction0, int index1, double fraction1, bool allowExtrapolation) const;\n\n\t/**\n\t* @brief 返回输入的曲线的布尔奇运算结果（区域）\n\t*\n\t* @param CurveSetCR regionA\t\t\t\t\t左操作数\n\t* @param CurveSetCR regionB\t\t\t\t\t右操作数\n\t* @param BasicCurvePtrPairVector * newToOld\t（可选）包含新旧曲线的数组指针\n\t* @return ATGEOSET_EXPORT CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/07/22\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaParity(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n};\n\nstruct CurveCurve\n{\nprivate: CurveCurve();\npublic:\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tCurveSetR curveA,\n\t\tCurveSetR curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB,\n\t\tXMatrix4dCP    pWorldToLocal,\n\t\tbool         extend = false\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveR curveA,\n\t\tCurveSetR     curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tCurveSetCR chainA,\n\t\tCurveSetCR chainB\n\t);\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            double &fractionA,\n            XPoint3dR pntA,\n            double &fractionB,\n            XPoint3dR pntB\n            );\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            CurveDescInfoR detailA,\n            CurveDescInfoR detailB\n            );\n};\n\nstruct PathLocationDetail\n{\nprivate:\n\tCurveDescInfo m_curveDetail;\n\tint32_t m_pathIndex;\n\tdouble m_pathDistance;\npublic:\n\n\tATGEOSET_EXPORT PathLocationDetail();\n\n\tATGEOSET_EXPORT PathLocationDetail(PathLocationDetail const &other);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, int pathIndex = -1, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, size_t pathIndex, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(double distance);\n\n\tATGEOSET_EXPORT XPoint3d Point() const;\n\n\tATGEOSET_EXPORT CurveDescInfo GetCurveDescInfo() const;\n\n    ATGEOSET_EXPORT double DistanceFromPathStart() const;\n};\n\nstruct CurveSetWithDistanceIndex : RefCountedBase\n{\nprivate:\n\n\tstruct PathEntry : PathLocationDetail\n\t{\n\t\tdouble             m_projectedDistance;\n\t\tXRange3d           m_range;\n\t\tPathEntry(PathLocationDetail const &pathDetail, double projectedDist, XRange3dCR range)\n\t\t\t: PathLocationDetail(pathDetail),\n\t\t\tm_projectedDistance(projectedDist),\n\t\t\tm_range(range)\n\t\t{\n\t\t}\n\t\tPathEntry(double distance) : PathLocationDetail(distance), m_projectedDistance(distance) {}\n\n\t\tdouble GetDistance(bool projected) const;\n\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistanceXY(PathEntry const &dataA, PathEntry const &dataB);\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistance(PathEntry const &dataA, PathEntry const &dataB);\n\t};\n\n\tCurveSetPtr m_curveVector;\n\txvector<PathEntry> m_locations;\n\tCurveSetPtr m_savedPrimitives;\n\n\tXRotMatrix m_worldToViewRotMatrix;\n\tXRotMatrix m_viewToWorldRotMatrix;\n\tXRotMatrix m_flattenToView;\n\tXMatrix4d m_worldToView;\n\n\texplicit CurveSetWithDistanceIndex(XRotMatrix worldToView);\n\n\tCurveSetWithDistanceIndex();\n\npublic:\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create(XRotMatrix worldToView);\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create();\n\n\tATGEOSET_EXPORT void SetPath(CurveSetPtr &path);\n\n\tATGEOSET_EXPORT bool SearchByDistanceFromPathStart\n\t(\n\t\tdouble targetDist,\n\t\tPathLocationDetail &detail\n\t) const;\n\n    ATGEOSET_EXPORT PathLocationDetail SearchClosestPointBounded\n    (\n    XPoint3dCR spacePoint,\n    bool computeDistAlong\n    ) const;\n};\n\nEND_ATEC_NAMESPACE\n\n", "output": "\nvoid CreateEntityExamples::SewBodiesExample()\n{\n    double length = 20000;\n    double width = 10000;\n    double height = 10000;\n\n    //构造截面1数据(左截面)\n    XPoint3d profile1Pt1 = XPoint3d::FromXYZ(-length, width, 0);\n    XPoint3d profile1Pt2 = XPoint3d::FromXYZ(-length, -width, 0);\n    XPoint3d profile1Pt3 = XPoint3d::FromXYZ(-length, -width, height);\n    XPoint3d profile1Pt4 = XPoint3d::FromXYZ(-length, width, height);\n    xvector<XPoint3d> profile1Pts = xvector<XPoint3d>{ profile1Pt1, profile1Pt2, profile1Pt3, profile1Pt4, profile1Pt1 };\n    CurveSetPtr profile1 = CurveSet::CreateLinear(profile1Pts, CurveSet::BOUNDARY_TYPE_Outer);\n\n    //构造截面2数据（前截面）\n    XPoint3d profile2Pt1 = XPoint3d::FromXYZ(-length, -width, 0);\n    XPoint3d profile2Pt2 = XPoint3d::FromXYZ(length, -width, 0);\n    XPoint3d profile2Pt3 = XPoint3d::FromXYZ(length, -width, height);\n    XPoint3d profile2Pt4 = XPoint3d::FromXYZ(-length, -width, height);\n    xvector<XPoint3d> profile2Pts = xvector<XPoint3d>{ profile2Pt1, profile2Pt2, profile2Pt3, profile2Pt4, profile2Pt1 };\n    CurveSetPtr profile2 = CurveSet::CreateLinear(profile2Pts, CurveSet::BOUNDARY_TYPE_Outer);\n\n    //构造截面3数据（右截面）\n    XPoint3d profile3Pt1 = XPoint3d::FromXYZ(length, -width, 0);\n    XPoint3d profile3Pt2 = XPoint3d::FromXYZ(length, width, 0);\n    XPoint3d profile3Pt3 = XPoint3d::FromXYZ(length, width, height);\n    XPoint3d profile3Pt4 = XPoint3d::FromXYZ(length, -width, height);\n    xvector<XPoint3d> profile3Pts = xvector<XPoint3d>{ profile3Pt1, profile3Pt2, profile3Pt3, profile3Pt4, profile3Pt1 };\n    CurveSetPtr profile3 = CurveSet::CreateLinear(profile3Pts, CurveSet::BOUNDARY_TYPE_Outer);\n\n    //构造截面4数据（后截面）\n    XPoint3d profile4Pt1 = XPoint3d::FromXYZ(length, width, 0);\n    XPoint3d profile4Pt2 = XPoint3d::FromXYZ(-length, width, 0);\n    XPoint3d profile4Pt3 = XPoint3d::FromXYZ(-length, width, height);\n    XPoint3d profile4Pt4 = XPoint3d::FromXYZ(length, width, height);\n    xvector<XPoint3d> profile4Pts = xvector<XPoint3d>{ profile4Pt1, profile4Pt2, profile4Pt3, profile4Pt4, profile4Pt1 };\n    CurveSetPtr profile4 = CurveSet::CreateLinear(profile4Pts, CurveSet::BOUNDARY_TYPE_Outer);\n\n    //构造截面5数据（底截面）\n    XPoint3d profile5Pt1 = XPoint3d::FromXYZ(-length, width, 0);\n    XPoint3d profile5Pt2 = XPoint3d::FromXYZ(-length, -width, 0);\n    XPoint3d profile5Pt3 = XPoint3d::FromXYZ(length, -width, 0);\n    XPoint3d profile5Pt4 = XPoint3d::FromXYZ(length, width, 0);\n    xvector<XPoint3d> profile5Pts = xvector<XPoint3d>{ profile5Pt1, profile5Pt2, profile5Pt3, profile5Pt4, profile5Pt1 };\n    CurveSetPtr profile5 = CurveSet::CreateLinear(profile5Pts, CurveSet::BOUNDARY_TYPE_Outer);\n\n    //构造截面6数据（顶截面）\n    XPoint3d profile6Pt1 = XPoint3d::FromXYZ(-length, width, height);\n    XPoint3d profile6Pt2 = XPoint3d::FromXYZ(-length, -width, height);\n    XPoint3d profile6Pt3 = XPoint3d::FromXYZ(length, -width, height);\n    XPoint3d profile6Pt4 = XPoint3d::FromXYZ(length, width, height);\n    xvector<XPoint3d> profile6Pts = xvector<XPoint3d>{ profile6Pt1, profile6Pt2, profile6Pt3, profile6Pt4, profile6Pt1 };\n    CurveSetPtr profile6 = CurveSet::CreateLinear(profile6Pts, CurveSet::BOUNDARY_TYPE_Outer);\n\n    //获得当前激活的场景\n    ATSceneRefP pSceneref = atSceneRef_getActive();\n    if (pSceneref == nullptr)\n        return;\n\n    //创建薄片\n    xvector<CurveSetPtr> profileCrvs = { profile1, profile2, profile3, profile4, profile5, profile6 };\n    xvector<ISolidCoreEntityPtr> profileEntities;\n    for (CurveSetPtr profileCrvPtr : profileCrvs)\n    {\n        if (!profileCrvPtr.IsValid())\n            continue;\n\n        ISolidCoreEntityPtr solidPtr;\n        ATECStatus sattus = EntityUtl::Create::EntityFromCurveSet(solidPtr, *profileCrvPtr, *pSceneref);\n        if (sattus == ATECStatus::SUCCESS)\n            profileEntities.push_back(solidPtr);\n    }\n\n    //缝合体\n    xvector<ISolidCoreEntityPtr> sewn;\n    xvector<ISolidCoreEntityPtr> unsewn;\n    EntityUtl::Modify::SewEntitys(sewn, unsewn, profileEntities.data(), profileEntities.size(), 100, 1);//缝合体\n    for(ISolidCoreEntityPtr solidPtr : sewn)\n    {\n        HEATObject obj;\n        GeometryToATObject::ToObject(obj, *solidPtr, nullptr, *pSceneref);\n        if (obj.IsValid())\n            obj.AddToScene();\n    }\n}"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};. You need to implement the function EvaluateVertexExample in the interface. Here are some apis that you can use and remember:\n code of file EntityUtl.h: \n\n#pragma once\n\n/**\n* @file EntityUtl.h\n*\n* @author SZEWC\n* @date 2022/04/27\n*/\n\n\n/**\n* @brief 以指定起终点截面的方式拉伸体\n* @details \n* \n* @param ISolidCoreEntityPtr & out \n* @param CurveSetCR startProfile \n* @param CurveSetCR endProfile \n* @param CurveSetCR path \n* @param ATSceneRefR scene \n* @param bool alignParallel \n* @param bool selfRepair \n* @param bool createSheet \n* @param XVec3dCP lockDirection \n* @param double const * twistAngle \n* @param double const * scale \n* @param XPoint3dCP scalePoint \n* @return ATEC \n*\n* @author SZEWEC\n* @since 2022/04/28\n*/\nENTITYUTIL_EXPORT ATEC::ATECStatus atSolid_EntityFromSweep\n(\nATEC::ATDataCore::ISolidCoreEntityPtr& out,\nATEC::CurveSetCR startProfile,\nATEC::CurveSetCR endProfile,\nATEC::CurveSetCR path,\nATEC::ATDataCore::ATSceneRefR scene,\nbool alignParallel,\nbool selfRepair,\nbool createSheet,\nATEC::XVec3dCP lockDirection = NULL,\ndouble const* twistAngle = NULL,\ndouble const* scale = NULL,\nATEC::XPoint3dCP scalePoint = NULL\n);\n\n/**\n* @brief 元件到体\n* @details 将给定元件转换成体\n* \n* @param BODY_TAG * bodyP\n* @param ATEC::TransformP bodyTransformP\n* @param ATEC::ATDataCore::ATObjectDescrP odP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @param UInt32 nodeId\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_elementToBody\n(\nBODY_TAG*       bodyP,          \nATEC::TransformP      bodyTransformP, \nATEC::ATDataCore::ATObjectDescrP odP,            \nATEC::ATDataCore::ATSceneRefP    SceneRef,       \nUInt32          nodeId = 1L     \n);\n\n/**\n* @brief 体到元件\n* @details 将给定体转换成元件\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\n* @param BODY_TAG bodyTag\n* @param bool wireframe\n* @param int uIsoParametrics\n* @param int vIsoParametrics\n* @param unsigned int useSmartIso\n* @param ATEC::ATDataCore::ATObjectP templateP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_bodyToObject\n(\nATEC::ATDataCore::ATObjectDescrH edPP,               \nBODY_TAG        bodyTag,            \nbool            wireframe,          \nint             uIsoParametrics,    \nint             vIsoParametrics,    \nunsigned int    useSmartIso,        \nATEC::ATDataCore::ATObjectP      tempP,          \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 面到元件\n* @details 将给定的面转换成等价的元件\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\n* @param FACE_TAG face\n* @param bool wireframe\n* @param int nIsoparametrics\n* @param ATEC::ATDataCore::ATObjectP templateP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_faceToObject\n(\nATEC::ATDataCore::ATObjectDescrH edPP,               \nFACE_TAG        face,               \nbool            wireframe,          \nint             nIsoparametrics,    \nATEC::ATDataCore::ATObjectP      tempP,          \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 体求减\n* @details 从 b2 中减去 b1\n* \n* @param BODY_TAG b2\n* @param BODY_TAG b1\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_subtract\n(\nBODY_TAG        b2,                \nBODY_TAG        b1                 \n);\n\n/**\n* @brief 面面相交\n* @details 计算两个面的交,结果以线体返回\n* \n* @param BODY_TAG * b\n* @param FACE_TAG f1\n* @param FACE_TAG f2\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_faceFaceIntersect\n(\nBODY_TAG        *b,                \nFACE_TAG        f1,                \nFACE_TAG        f2                 \n);\n\n/**\n* @brief 获取输入实体的面ID\n* \n* @param ATEC::FaceId * faceIdP\n* @param ENTITY_TAG ent\n* @param bool useHighestId\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/27\n*/\nENTITYUTIL_EXPORT int atSolid_idFromEntity\n(\nATEC::FaceId          *faceIdP,\nENTITY_TAG      ent,\nbool            useHighestId\n);\n\n/**\n* @brief 检查体\n* @details 检查输入体的几何、拓扑和尺寸有效性\n* \n* @param BODY_TAG body\n* @param bool checkGeometry\n* @param bool checkTopology\n* @param bool checkSize\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_checkBody\n(\nBODY_TAG        body,\nbool            chkGeometry,\nbool            chkTopology,\nbool            chkSize\n);\n\n/**\n* @brief 创建实体列表\n* @details 创建一个空的实体列表\n* \n* @param TAG_ENTITY_LIST * * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listCreate\n(\nTAG_ENTITY_LIST **lP            \n);\n\n/**\n* @brief 删除实体列表\n* @details 释放给定实体列表分配的内存\n* \n* @param TAG_ENTITY_LIST * * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listDelete\n(\nTAG_ENTITY_LIST **lP            \n);\n\n/**\n* @brief 列表添加元素\n* @details 往实体列表的尾部添加一个元素\n* \n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listAdd\n(\nTAG_ENTITY_LIST *lP,            \nENTITY_TAG      ent             \n);\n\n/**\n* @brief 列表添加元素\n* @details 往实体列表的尾部添加另一个列表的所有元素\n* \n* @param TAG_ENTITY_LIST * lDP\n* @param TAG_ENTITY_LIST * lSP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listAddList\n(\nTAG_ENTITY_LIST *lDP,\nTAG_ENTITY_LIST *lSP\n);\n\n/**\n* @brief 列表移除实体\n* @details 从列表中移除指定的实体\n* \n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listRemove\n(\nTAG_ENTITY_LIST *lP,\nENTITY_TAG      ent\n);\n\n/**\n* @brief 列表计数\n* @details 返回实体列表的元素个数\n* \n* @param int * count\n* @param TAG_ENTITY_LIST * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listCount\n(\nint             *count,         \nTAG_ENTITY_LIST *lP             \n);\n\n/**\n* @brief 列表查询实体\n* @details 在列表中搜索给定的实体并返回中索引,若不存在返回-1\n* \n* @param int * nth\n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listLookup\n(\nint             *nth,           \nTAG_ENTITY_LIST *lP,            \nENTITY_TAG      ent             \n);\n\n/**\n* @brief 查询列表指定位置的元素\n* @details 返回实体列表指定位置的元素\n* \n* @param ENTITY_TAG * entP\n* @param TAG_ENTITY_LIST * lP\n* @param int nth\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listNthEl\n(\nENTITY_TAG      *entP,          \nTAG_ENTITY_LIST *lP,            \nint             nth             \n);\n\n/**\n* @brief 清空列表\n* @details 移除列表中的所有元素\n* \n* @param TAG_ENTITY_LIST * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listEmpty\n(\nTAG_ENTITY_LIST *lP             \n);\n\nENTITYUTIL_EXPORT int atSolid_listCreateNonEntity (NON_ENTITY_LIST** lPP);\nENTITYUTIL_EXPORT int atSolid_listDeleteNonEntity (NON_ENTITY_LIST** lPP);\nENTITYUTIL_EXPORT int atSolid_listAddNonEntity (NON_ENTITY_LIST* lP, void* dataP);\nENTITYUTIL_EXPORT int atSolid_listCountNonEntity (int* countP, NON_ENTITY_LIST* lP);\nENTITYUTIL_EXPORT int atSolid_listNthNonEntity (void** dataPP, NON_ENTITY_LIST* lP, int nth);\n\n/**\n* @brief 偏移面\n* @details 将输入面的集合中所有面偏移指定距离,这些面必须属于同一个体\n* \n* @param TAG_ENTITY_LIST * pFaceList\n* @param double * pOffset\n* @param double tolerance\n* @param bool faceFaceCheck\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_offsetFaces\n(\nTAG_ENTITY_LIST *pFaceList,\ndouble          *pOffset,\ndouble          tolerance,\nbool            faceFaceCheck\n);\n\n/**\n* @brief 偏移线体\n* @details 返回给定线体偏移后的边缘\n* \n* @param TAG_ENTITY_LIST * pOffsetList\n* @param BODY_TAG wireBody\n* @param EDGE_TAG refEdge\n* @param ATEC::XPoint3d * pNormal\n* @param double distance\n* @param double tolerance\n* @param int gapFill\n* @param bool localCheck\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_offsetWire\n(\nTAG_ENTITY_LIST *pOffsetList,\nBODY_TAG        wireBody,\nEDGE_TAG        refEdge,\nATEC::XPoint3d        *pNormal,           \ndouble          distance,\ndouble          tolerance,\nint             gapFill,            \nbool            localCheck\n);\n\n/**\n* @brief 面上最近的点\n* @details 计算给定面上离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * clstPt\n* @param ATEC::XPoint3d * normal\n* @param ATEC::XPoint2d * param\n* @param ATEC::XPoint3d * testPt\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_closestPointToFace\n(\nATEC::XPoint3d        *clstPt,            \nATEC::XPoint3d        *normal,            \nATEC::XPoint2d        *param,             \nATEC::XPoint3d        *testPt,            \nFACE_TAG        face                \n);\n\n/**\n* @brief 边上最近的点\n* @details 计算给定边上离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * clstPt\n* @param double * param\n* @param ATEC::XPoint3d * testPt\n* @param EDGE_TAG edge\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_closestPointToEdge\n(\nATEC::XPoint3d        *clstPt,            \ndouble          *param,             \nATEC::XPoint3d        *testPt,            \nEDGE_TAG        edge               \n);\n\n/**\n* @brief 离点最近的点\n* @details 计算给定点离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * point\n* @param VERTEX_TAG vertex\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_pointFromVertex\n(\nATEC::XPoint3d        *point,             \nVERTEX_TAG      vertex              \n);\n\n/**\n* @brief 获取实体\n* @details 从给定起始点发射射线,返回体上与之相交的所有实体\n* \n* @param TAG_ENTITY_LIST * hits\n* @param double * * params\n* @param ATEC::XPoint3dP origin\n* @param ATEC::XPoint3dP dir\n* @param double radius\n* @param int type\n* @param BODY_TAG b\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getEntities\n(\nTAG_ENTITY_LIST *hits,              \ndouble          **params,           \nATEC::XPoint3dP       origin,             \nATEC::XPoint3dP       dir,                \ndouble          radius,             \nint             type,               \nBODY_TAG        b,                  \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 获取面实体\n* @details 从给定起始点发射射线,返回体上与之相交的第一个面以及相应的交点\n* \n* @param ATEC::XPoint3d * outPointP\n* @param ATEC::XPoint3d * outNormalP\n* @param FACE_TAG * outFaceP\n* @param ATEC::XPoint3d * inPointP\n* @param ATEC::XPoint3d * inNormalP\n* @param BODY_TAG body\n* @param bool backupRayOrigin\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_boresiteToFace\n(\nATEC::XPoint3d        *outPointP,         \nATEC::XPoint3d        *outNormalP,        \nFACE_TAG        *outFaceP,          \nATEC::XPoint3d        *inPointP,          \nATEC::XPoint3d        *inNormalP,         \nBODY_TAG        body,               \nbool            backupRayOrigin,    \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 曲线与面相交\n* @details 将给定部分曲线与给定的面相交,并返回曲线与面之间的交点以及相应的参数\n* \n* @param ATEC::XPoint3dP * pointPP\n* @param ATEC::XPoint2d * * faceUVPP\n* @param double * * curveParamPP\n* @param int * numIntsP\n* @param FACE_TAG face\n* @param CURVE_TAG curve\n* @param double startParam\n* @param double endParam\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_faceIntersectCurve\n(\nATEC::XPoint3dP       *pntPP,\nATEC::XPoint2d        **faceUVPP,\ndouble          **curveParamPP,\nint             *numIntsP,\nFACE_TAG        face,\nCURVE_TAG       curve,\ndouble          startParam,\ndouble          endParam\n);\n\n/**\n* @brief 获取体的包围盒\n* @details 计算给定体的包围盒\n* \n* @param ATEC::XPoint3d * lo\n* @param ATEC::XPoint3d * hi\n* @param BODY_TAG b\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getBodyBox\n(\nATEC::XPoint3d       *lo,             \nATEC::XPoint3d       *hi,             \nBODY_TAG       b                \n);\n\n/**\n* @brief 获取平滑的面列表\n* @details 向面的列表中添加一个面,并添加这个面与列表中的面的平滑连接\n* \n* @param TAG_ENTITY_LIST * listP\n* @param FACE_TAG face\n* @param bool addSmoothFaces\n* @param int allowedFaceTypeMask\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getSmoothFaceList\n(\nTAG_ENTITY_LIST *listP,\nFACE_TAG        face,\nbool            addSmoothFaces,\nint             allowedFaceTypeMask\n);\n\nenum SmoothEdgeType\n    {\n    SMOOTH_TYPE_NONE  = 0,\n    SMOOTH_TYPE_BLEND = 1,\n    SMOOTH_TYPE_TANGENT = 2\n    };\n\n/**\n* @brief 面的所有边\n* @details 返回构成面的所有边\n* \n* @param TAG_ENTITY_LIST * edgeListP\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getEdgeListFromFace\n(\nTAG_ENTITY_LIST *edgeListP,         \nFACE_TAG        face                \n);\n\n/**\n* @brief 线体是否G1连续\n* @details 查询线体是否关于所有点G1连续\n* \n* @param BODY_TAG wire\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_wireIsG1\n(\nBODY_TAG        wire\n);\n\n/**\n* @brief 实体最小距离\n* @details 计算两个实体之间的最小距离\n* \n* @param ATEC::XPoint3dP pPoint1\n* @param ATEC::XPoint3dP pPoint2\n* @param double * pDistance\n* @param ENTITY_TAG entity1\n* @param ENTITY_TAG entity2\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_minimumDistanceBetweenEntities\n(\nATEC::XPoint3dP           pPoint1,\nATEC::XPoint3dP           pPoint2,\ndouble              *pDist,\nENTITY_TAG          entity1,\nENTITY_TAG          entity2\n);\n\n/**\n* @brief 简化体\n* @details 尝试将B样条曲线和曲面简化为分析曲线和曲面\n* \n* @param BODY_TAG * bodyP\n* @param bool local\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_simplifyBody\n(\nBODY_TAG        *bodyP,\nbool            local\n);\n\n/**\n* @brief 开始转换\n* @details 将变换矩阵推入堆栈中\n* \n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_beginCurrTrans (ATEC::ATDataCore::ATSceneRefP SceneRef);\n\n/**\n* @brief 结束转换\n* @details 从堆栈中弹出brSolid_beginCurrTrans推入的变换矩阵\n* \n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_endCurrTrans ();\n\n/**\n* @brief 应用变换\n* @details 对体应用给定变换\n* \n* @param ENTITY_TAG entity\n* @param ATEC::TransformP transformP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_applyTransform\n(\nENTITY_TAG      entity,            \nATEC::TransformP      transformP         \n);\n\n/**\n* @brief 给薄面体加盖\n* @details 通过添加其他面封闭给定的薄面体并转换为体\n* \n* @param TAG_ENTITY_LIST * faces\n* @param BODY_TAG * lamina\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_capSurface\n(\nTAG_ENTITY_LIST *faces,             \nBODY_TAG        *lamina             \n);\n\n/**\n* @brief 逆转体\n* @details 将体中的所有面逆转方向\n* \n* @param BODY_TAG body\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_reverseBody\n(\nBODY_TAG        body               \n);\n\n/**\n* @brief 删除实体\n* @details 删除给定的实体\n* \n* @param ENTITY_TAG e\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_deleteEntity\n(\nENTITY_TAG      e                  \n);\n\n/**\n* @brief 复制体\n* @details 创建给定体的一个复制\n* \n* @param BODY_TAG * copy\n* @param BODY_TAG source\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_copyBody\n(\nBODY_TAG        *copy,\nBODY_TAG        source\n);\n\n/**\n* @brief 删除体\n* @details 释放体所分配的内存\n* \n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_freeBody\n(\nBODY_TAG        body               \n);\n\n/**\n* @brief 释放内存\n* @details 释放列表所分配的内存\n* \n* @param void * v\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_free\n(\nvoid            *v\n);\n\n/**\n* @brief 边缘数据\n* @details 返回边缘的拓扑和几何信息\n* \n* @param VERTEX_TAG * startVertexP\n* @param VERTEX_TAG * endVertexP\n* @param ATEC::XPoint3d * startPointP\n* @param ATEC::XPoint3d * endPointP\n* @param double * startParamP\n* @param double * endParamP\n* @param COEDGE_TAG * coEdgeP\n* @param CURVE_TAG * curveP\n* @param bool * reversedP\n* @param EDGE_TAG edge\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_edgeData\n(\nVERTEX_TAG      *startVertexP,  \nVERTEX_TAG      *endVertexP,    \nATEC::XPoint3d        *startPointP,   \nATEC::XPoint3d        *endPointP,     \ndouble          *startParamP,   \ndouble          *endParamP,     \nCOEDGE_TAG      *coEdgeP,       \nCURVE_TAG       *curveP,        \nbool            *reversedP,     \nEDGE_TAG        edge            \n);\n\n/**\n* @brief 获取所有边\n* @details 返回体的所有边列表\n* \n* @param TAG_ENTITY_LIST * listP\n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getEdgeList\n(\nTAG_ENTITY_LIST *listP,             \nBODY_TAG        body                \n);\n\n/**\n* @brief 获取所有面\n* @details 返回体的所有面列表\n* \n* @param TAG_ENTITY_LIST * listP\n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getFaceList\n(\nTAG_ENTITY_LIST *listP,             \nBODY_TAG        body                \n);\n\n/**\n* @brief 体的首条边\n* @details 返回体的第一条边\n* \n* @param EDGE_TAG * pEdge\n* @param BODY_TAG body\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_bodyAskFirstEdge\n(\nEDGE_TAG        *pEdge,\nBODY_TAG        body\n);\n\n/**\n* @brief 创建空体\n* @details 创建一个最小的仅包含一个点的体\n* \n* @param BODY_TAG * b\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_body\n(\nBODY_TAG        *b                  \n);\n\n/**\n* @brief 面集到薄面体\n* @details 将输入的面拼接并创建一个薄面体,所有的面必须来自同一个体\n* \n* @param BODY_TAG * sheetP\n* @param TAG_ENTITY_LIST * faceListP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sheetFromFaces\n(\nBODY_TAG        *sheetP,            \nTAG_ENTITY_LIST *faceListP          \n);\n\n/**\n* @brief 面到薄面体\n* @details 根据输入的单个面创建一个薄面体\n* \n* @param BODY_TAG * sheetP\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sheetFromFace\n(\nBODY_TAG        *sheetP,          \nFACE_TAG        face              \n);\n\n/**\n* @brief 揭开面\n* @details 将输入的面从所属的薄面体中移除\n* \n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_uncoverFace\n(\nFACE_TAG        face\n);\n\n/**\n* @brief 两个体压印\n* @details 计算两个体的交并把交压印到目标体或两个体上\n* \n* @param TAG_ENTITY_LIST * pTargetEdges\n* @param TAG_ENTITY_LIST * pToolEdges\n* @param BODY_TAG target\n* @param BODY_TAG tool\n* @param double tolerance\n* @param bool imprintTool\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintBodies\n(\nTAG_ENTITY_LIST *pTargetEdges,  \nTAG_ENTITY_LIST *pToolEdges,    \nBODY_TAG        target,         \nBODY_TAG        tool,           \ndouble          tolerance,      \nbool            imprintTool     \n);\n\nENTITYUTIL_EXPORT bool atSolid_isSmartObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetOrSolidObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSceneerObject (ATEC::ATDataCore::ATObjectDescrP odP);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetBody (BODY_TAG bodyTag);\n\nENTITYUTIL_EXPORT bool atSolid_isWireBody (BODY_TAG bodyTag);\n\nENTITYUTIL_EXPORT bool atSolid_isFace (ENTITY_TAG entityTag);\n\nENTITYUTIL_EXPORT bool atSolid_isEdge (ENTITY_TAG entityTag);\n\n/**\n* @brief 获取FACE_TYPE\n* @details 返回FACE_TYPE常数\n* \n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_faceType ();\n\n/**\n* @brief 获取EDGE_TYPE\n* @details 返回EDGE_TYPE常数\n* \n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_edgeType ();\n\nENTITYUTIL_EXPORT void atSolid_moveBoresiteToEyePoint\n(\nATEC::XPoint3d        *pBorePoint,\nATEC::XPoint3d        *pBoreDirection,\nBODY_TAG        pBody\n);\n\nENTITYUTIL_EXPORT void atSolid_displayFace\n(\nTransDescrP     *transientPP,   \nFACE_TAG        faceP,\nbool            display,\nbool            showSmoothFaces,\nint             allowedFaceTypeMask,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             weight,\nint             style\n);\n\nENTITYUTIL_EXPORT void atSolid_displayEdge\n(\nTransDescrP     *transientPP,   \nEDGE_TAG        edgeP,          \nbool            display,        \nSmoothEdgeType  smoothSequence, \nbool            showStart,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             weight,\nint             style\n);\n\nENTITYUTIL_EXPORT int atSolid_createMark\n(\nint             *markP\n);\n\nENTITYUTIL_EXPORT int atSolid_gotoMark\n(\nint             mark\n);\n\nENTITYUTIL_EXPORT int atSolid_deleteMark\n(\nint             mark\n);\n\nENTITYUTIL_EXPORT void atSolid_getBoresiteWithBodyTransform\n(\nATEC::XPoint3dP       borePointP,         \nATEC::XPoint3dP       boreDirectionP,     \nATEC::XPoint3dCP      pntP,             \nint             view,               \nATEC::ATDataCore::ATSceneRefP    SceneRef,           \nATEC::TransformCP     bodyTransformP,     \nbool            useACS,             \nbool            frontClipBorePoint  \n);\n\nENTITYUTIL_EXPORT void atSolid_displayFaceWithBodyTransform\n(\nTransDescrP     *transientPP,       \nFACE_TAG        faceP,\nATEC::TransformP      bodyTransformP,     \nbool            display,\nbool            showSmoothFaces,\nint             nIsoParametrics,    \nint             allowedFaceTypeMask,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             style,\nint             weight\n);\n\nENTITYUTIL_EXPORT void atSolid_displayEdgeWithBodyTransform\n(\nTransDescrP     *transientPP,       \nEDGE_TAG        edgeP,              \nATEC::TransformP      bodyTransformP,     \nbool            display,            \nSmoothEdgeType  smoothSequence,     \nbool            showStart,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nUInt32          color,\nlong            style,\nUInt32          weight,\nbool            showAllEdgesWithSameId\n);\n\nENTITYUTIL_EXPORT int atSolid_getSharedEdgesOfFaces\n(\nTAG_ENTITY_LIST     *edgeListP,\nTAG_ENTITY_LIST     *faceListP\n);\n\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_getBSplineFromSmartSurface\n(\nATEC::ATBsplineSurface*   pBSurface,\nBODY_TAG            bodyP\n);\n\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_getBSplineFromSmartSurface2\n(\nATEC::ATBsplineSurface*   pBSurface,\nBODY_TAG            bodyP,\nATEC::TransformP          bodyTransformP,\nATEC::ATDataCore::ATSceneRefP        SceneRef\n);\n\n#define     SOLIDTEMPLATE_OPTION_None               0\n#define     SOLIDTEMPLATE_OPTION_PreserveElemId     1\n#define     SOLIDTEMPLATE_OPTION_PrimaryClass       2\n\nENTITYUTIL_EXPORT ATEC::ATDataCore::ATObjectP  atSolid_createBrepTemplateForOdP\n(\nATEC::ATDataCore::ATObjectP          objectP,   \nATEC::ATDataCore::ATObjectDescrCP    odP,        \nUInt32              options     \n);\n\n/**\n* @brief 沿线拉伸体\n* @details 沿着输入的线体拉伸线体或薄面体\n* \n* @param BODY_TAG * bodyP\n* @param BODY_TAG wireBody\n* @param ATEC::XPoint3d * pathStartP\n* @param double shell\n* @param bool capped\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sweepBodyWire\n(\n\tBODY_TAG        *bodyP,\n\tBODY_TAG        wireBody,\n\tATEC::XPoint3d        *pathStartP,\n\tdouble          shell,\n\tbool            capped,\n\tATEC::ATDataCore::ATSceneRefP    SceneRef\n);\n\n/**\n* @brief 根据面ID从输入的体中寻找面\n* \n* @param FACE_TAG * faceP \n* @param ATEC::FaceId * faceIdP \n* @param BODY_TAG body \n* @return ENTITYUTIL_EXPORT int \n*\n* @author SZEWEC\n* @since 2022/04/29\n*/\nENTITYUTIL_EXPORT int atSolid_faceFromId\n(\n\tFACE_TAG        *faceP,\n\tATEC::FaceId          *faceIdP,\n\tBODY_TAG        body\n);\n\n/**\n* @brief 使用输入的边生成元素,当元素代表边的一部分的时候该接口接收一个起始和终止参数\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\t\t生成的元素\n* @param ATEC::ATDataCore::ATObjectP templateP\t\t生成元素的模板,传NULL时使用默认样式\n* @param EDGE_TAG edge\t\t\t\t\t\t\t\t边\n* @param double * startParameterP\t\t\t\t\t传NULL时使用边的起点,否则为该参数指定的点（位于边上）作为起点\n* @param double * endParameterP\t\t\t\t\t\t传NULL时使用边的终点,否则为该参数指定的点（位于边上）作为终点\n* @param ATEC::ATDataCore::ATScenesRefP SceneRef\t生成的元素所在的场景\n* @return ENTITYUTIL_EXPORT int\t\t\t\t\t\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/05\n*/\nENTITYUTIL_EXPORT int atSolid_elementFromEdge\n(\n\tATEC::ATDataCore::ATObjectDescrH edPP,\n\tATEC::ATDataCore::ATObjectP      tempP,\n\tEDGE_TAG        edge,\n\tdouble          *startParameterP,\n\tdouble          *endParameterP,\n\tATEC::ATDataCore::ATSceneRefP    SceneRef\n);\n\n/**\n* @brief 将给定的曲线压印到实体上\n*\n* @param TAG_ENTITY_LIST * pImprintList\t\t[out] 压印到实体上的结果曲线,或者NULL\n* @param BODY_TAG body\t\t\t\t\t\t[in ] 实体\n* @param TAG_ENTITY_LIST * pEdgeList\t\t[in ] 待压印的曲线\n* @param ATEC::XPoint3d * pVector\t\t\t[in ] 压印（投影）的方向\n* @param double tolerance\t\t\t\t\t[in ] 容差,用于解决容差问题与计算参数空间曲线需要\n* @return ENTITYUTIL_EXPORT ATEC::StatusInt\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/30\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintCurveSet\n(\n\tTAG_ENTITY_LIST *pImprintList,\n\tBODY_TAG        body,\n\tTAG_ENTITY_LIST *pEdgeList,\n\tATEC::XPoint3d        *pVector,\n\tdouble          tolerance\n);\n\n/**\n* @brief 将给定的曲线沿着面的法线方向压印到实体上\n*\n* @param TAG_ENTITY_LIST * pImprintList\t\t[out] 压印到实体上的结果曲线,或者NULL\n* @param BODY_TAG body\t\t\t\t\t\t[in ] 实体\n* @param TAG_ENTITY_LIST * pEdgeList\t\t[in ] 待压印的曲线\n* @param double tolerance\t\t\t\t\t[in ] 容差,用于解决容差问题与计算参数空间曲线需要\n* @return ENTITYUTIL_EXPORT ATEC::StatusInt\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/30\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintCurveNormal\n(\n\tTAG_ENTITY_LIST *pImprintList,\n\tBODY_TAG        body,\n\tTAG_ENTITY_LIST *pEdgeList,\n\tdouble          tolerance\n);\n\n\n code of file IBasicCurve.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 基本线元类\n* @author SZEWC\n* @since 2022/04/28\n*/\nstruct IBasicCurve : public RefCountedBase\n{\nprivate: virtual void IAmAbstractClass() = 0;\n\npublic:\n\tenum BasicCurveType\n\t{\n\t\tBCURVE_TYPE_Invalid = 0,\n\t\tBCURVE_TYPE_Line = 1,\n\t\tBCURVE_TYPE_LineString = 2,\n\t\tBCURVE_TYPE_Arc = 3,\n\t\tBCURVE_TYPE_BsplineCurve = 4,\n\t\tBCURVE_TYPE_InterpolationCurve = 5,\n\t\tBCURVE_TYPE_AkimaCurve = 6,\n\t\tBCURVE_TYPE_PointString = 7,\n\t\tBCURVE_TYPE_CurveSet = 8,\n\t\tBCURVE_TYPE_Spiral = 9,\n\t\tBCURVE_TYPE_PartialCurve = 10,\n\t\tBCURVE_TYPE_NotClassified = -1,\n\t};\n\n\tATGEOSET_EXPORT int64_t GetTag() const;\n\n\tATGEOSET_EXPORT int GetIntTag() const;\n\n\tATGEOSET_EXPORT void SetTag(int64_t tag);\n\n\tATGEOSET_EXPORT void SetTag(int tag);\n\n\tATGEOSET_EXPORT CurveSetPtr GetChildCurveSetP();\n\npublic:\n\tATGEOSET_EXPORT xvector<XPoint3d> * GetLineStringP();\n\n\tATGEOSET_EXPORT BasicCurveType           GetBasicCurveType() const;\n\n\tATGEOSET_EXPORT bool TryGetLine(XSegment3dR segment) const;\n\n\tATGEOSET_EXPORT bool TryGetArc(XEllipse3dR arc) const;\n\n\tATGEOSET_EXPORT XSegment3dCP                 GetLineCP() const;\n\n\tATGEOSET_EXPORT xvector<XPoint3d> const* GetLineStringCP() const;\n\n\tATGEOSET_EXPORT bool TryGetSegmentInLineString(XSegment3dR segment, size_t startPointIndex) const;\n\n\tATGEOSET_EXPORT XEllipse3dCP                 GetArcCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurveCP             GetBsplineCurveCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr             GetBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr            GetProxyBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT XSpiral2dPlacementCP         GetSpiralPlacementCP() const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLine(XSegment3dCR segment);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(XPoint3dCP points, size_t nPoints);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(xvector<XPoint3d> const &points);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateArc(XEllipse3dCR ellipse);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurveCR curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurvePtr& curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiral(XSpiral2dBaseCR spiral, TransformCR frame,\n\t\tdouble fractionA, double fractionB);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusBearingRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble endRadians,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusLengthRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble length,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT IBasicCurvePtr Clone() const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneComponent(ptrdiff_t componentIndex) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneAsSingleOffsetPrimitiveXY(CurveOffsetOptionsCR options) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XRay3dR ray) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, CurveDescInfo &detail) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2, XVec3dR derivative3) const;\n\n\tATGEOSET_EXPORT bool FractionToFrenetFrame(double f, TransformR frame) const;\n\n\tATGEOSET_EXPORT bool Length(double &length) const;\n\n\tATGEOSET_EXPORT bool Length(XRotMatrixCP worldToLocal, double &length) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\tATGEOSET_EXPORT size_t NumComponent() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetATBsplineCurvePtr(double fraction0 = 0.0, double fraction1 = 1.0) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(XRotMatrixCP worldToView, double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool TrySetStart(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TrySetEnd(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\tATGEOSET_EXPORT void  AppendCurvePlaneIntersections\n\t(\n\t\tXPlane3dByVectorsCR plane,\n\t\tUVBoundarySelect   bounded,\n\t\txvector<CurveAndSolidDescInfo> &intersections\n\t) const;\n\n\tATGEOSET_EXPORT bool AddStrokes(xvector <XPoint3d> &points, IFacetOptionsR options,\n\t\tbool includeStartPoint = true,\n\t\tdouble startFraction = 0.0,\n\t\tdouble endFraction = 1.0\n\t) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, double &fraction, XPoint3dR curvePoint) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneBetweenFractions(double fractionA, double fractionB, bool allowExtrapolation) const;\n\n\tATGEOSET_EXPORT CurveSetCP            GetChildCurveSetCP() const;\n\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(double startFraction, double endFraction, double &signedDist) const;\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(XRotMatrixCP worldToLocal, double startFraction, double endFraction, double &signedDist) const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateRectangle(double x0, double y0, double x1, double y1, double z, int areaSignPref = 0);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateChildCurveSet(CurveSetPtr source);\n\n\tATGEOSET_EXPORT bool  TryGetPartialCurveData(double &fractionA, double &fractionB, IBasicCurvePtr &parentCurve, int64_t &tag) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file CurveSet.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 线串类\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct CurveSet : RefCountedBase, xvector<IBasicCurvePtr>\n{\n\n\tenum BoundaryType\n\t{\n\n\t\tBOUNDARY_TYPE_None = 0,\n\n\t\tBOUNDARY_TYPE_Open = 1,\n\n\t\tBOUNDARY_TYPE_Outer = 2,\n\n\t\tBOUNDARY_TYPE_Inner = 3,\n\n\t\tBOUNDARY_TYPE_ParityRegion = 4,\n\n\t\tBOUNDARY_TYPE_UnionRegion = 5,\n\t};\n\n\tenum InOutClassification\n\t{\n\t\tINOUT_Unknown = 0,\n\t\tINOUT_In = 1,\n\t\tINOUT_Out = 2,\n\t\tINOUT_On = 3\n\t};\n\nprotected:\n\tBoundaryType    m_boundaryType;\n\npublic:\n\t/**\n\t* @brief 设定边界\n\t* @details 设定曲线的边界类型\n\t* \n\t* @param BoundaryType BoundaryType\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void SetBoundaryType(BoundaryType BoundaryType);\n\n\t/**\n\t* @brief 获取叶节点\n\t* @details 通过只计算叶节点的索引深度搜索以获取目标叶节点\n\t* \n\t* @param size_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr FindIndexedLeaf(size_t index) const;\n\n\t/**\n\t* @brief 获取索引值\n\t* @details 深度搜索以获取给定叶节点的索引值\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @param size_t & index\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool LeafToIndex(IBasicCurveCP primitive, size_t &index) const;\n\n\t/**\n\t* @brief 获取叶节点个数\n\t* @details 获取曲线的叶节点个数\n\t* \n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesBelow() const;\n\n\texplicit CurveSet(BoundaryType boundaryType) { m_boundaryType = boundaryType; }\n\n\t/**\n\t* @brief 是否单元素曲线\n\t* @details 查询曲线是否只有一个基本元素\n\t* \n\t* @return IBasicCurve\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurve::BasicCurveType HasSingleBasicCurve() const;\n\n\t/**\n\t* @brief 获取边界类型\n\t* @details 获取曲线的边界类型\n\t* \n\t* @return BoundaryType\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT BoundaryType GetBoundaryType() const;\n\n\t/**\n\t* @brief 查询是否开\n\t* @details 查询是否开路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsOpenPath() const;\n\n\t/**\n\t* @brief 查询是否闭\n\t* @details 查询是否闭路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsClosedPath() const;\n\n\t/**\n\t* @brief 查询实际开闭\n\t* @details 查询是否名义上是开路径但起点和终点连接\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsPhysicallyClosedPath() const;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个带有给定边界类型没有成员的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个具有单个基本元素和给定边界类型的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @param IBasicCurvePtr primitive\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType, IBasicCurvePtr primitive);\n\n\t/**\n\t* @brief 拷贝\n\t* @details 返回一个深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr Clone() const;\n\n\t/**\n\t* @brief 倒角拷贝\n\t* @details 返回一个深度拷贝,在连续曲线之间插入圆角\n\t* \n\t* @param double radius\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithFillets(double radius) const;\n\n\t/**\n\t* @brief 闭合拷贝\n\t* @details 返回一个深度拷贝,闭合终端点的间隙\n\t* \n\t* @param CurveGapOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithGapsClosed(CurveGapOptionsCR options) const;\n\n\t/**\n\t* @brief 添加元素\n\t* @details 递归遍历source, 将所有叶节点添加到this, 返回添加的数量\n\t* \n\t* @param CurveSetCR source\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t AddPrimitives(CurveSetCR source);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 添加单个基本曲线\n\t* \n\t* @param IBasicCurvePtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(IBasicCurvePtr child);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 将chile的所有元素作为曲线成员添加\n\t* \n\t* @param CurveSetPtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(CurveSetPtr child);\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过XY方向的偏移后的深度拷贝\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneOffsetCurvesXY(CurveOffsetOptionsCR options);\n\n\t/**\n\t* @brief 获取叶节点数量\n\t* @details 计算指定类型的叶节点数量\n\t* \n\t* @param IBasicCurve::BasicCurveType targetType\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesOfType(IBasicCurve::BasicCurveType targetType) const;\n\n\t/**\n\t* @brief 用区域分割曲线\n\t* @details 用指定区域分割曲线,分别返回区域内、外和区域上的曲线\n\t* \n\t* @param CurveSetCR region\n\t* @param CurveSetP insideCollector\n\t* @param CurveSetP outsideCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByRegion(CurveSetCR region, CurveSetP insideCollector, CurveSetP outsideCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 用平面分割曲线\n\t* @details 用指定平面分割曲线,分别返回平面上方、下方和平面内的曲线\n\t* \n\t* @param XPlane3dCR plane\n\t* @param CurveSetP belowCollector\n\t* @param CurveSetP aboveCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByPlane(XPlane3dCR plane, CurveSetP belowCollector, CurveSetP aboveCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 拆分拷贝\n\t* @details 返回一个深度拷贝,但所有的多线段被拆分成单条线段\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithExplodedLinestrings() const;\n\n\t/**\n\t* @brief 获取质心\n\t* @details 返回包含曲线的质心(不考虑孤立点)\n\t* \n\t* @param double & length\n\t* @param XPoint3dR centroid\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  WireCentroid(double &length, XPoint3dR centroid) const;\n\n\t/**\n\t* @brief 获取质心、法向量和面积\n\t* @details 返回质心、法向量和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param XVec3dR normal\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CentroidNormalArea(XPoint3dR centroid, XVec3dR normal, double &area) const;\n\n\t/**\n\t* @brief 获取质心和面积\n\t* @details 返回XY平面方向上的质心和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  CentroidAreaXY(XPoint3dR centroid, double &area) const;\n\n\t/**\n\t* @brief 投影范围\n\t* @details 当投影到射线的时候,返回射线参数的范围\n\t* \n\t* @param XRay3dCR ray\n\t* @return XRange1d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT XRange1d ProjectedParameterRange(XRay3dCR ray) const;\n\n    /**\n    * @brief 局部坐标拷贝\n    * @details 返回曲线的深度复制并转换为与曲线相关联的局部坐标系统。\n    * \n    * @param LocalCoordinateSelect frameType\n    * @param TransformR localToWorld\n    * @param TransformR worldToLocal\n    * @param XRange3dR localRange\n    * @return CurveSetPtr\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT CurveSetPtr CloneInLocalCoordinates\n    (\n    LocalCoordinateSelect frameType,\n    TransformR localToWorld,\n    TransformR worldToLocal,\n    XRange3dR localRange\n    ) const;\n\n\t/**\n    * @brief 获取有坐标系的元素\n    * @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame) const;\n\n\t/**\n\t* @brief 获取有坐标系的元素\n\t* @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @param int searchPreference\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame, int srchPref) const;\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param xvector<XPoint3d> const & points\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(xvector<XPoint3d> const&points,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint3dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint3dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建多边形\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint2dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint2dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建矩形\n\t* @details 根据 XY 坐标创建矩形\n\t* \n\t* @param double x0\n\t* @param double y0\n\t* @param double x1\n\t* @param double y1\n\t* @param double z\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateRectangle(double x0, double y0, double x1, double y1, double z,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由给定线段创建边界类型为 BOUNDARY_TYPE_None 的曲线\n\t* \n\t* @param xvector<XSegment3d> const & segments\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(xvector<XSegment3d> const &segs);\n\n\t/**\n\t* @brief 创建圆盘\n\t* @details 为一个完整的椭圆(圆)盘创建一个曲线向量结构\n\t* \n\t* @param XEllipse3dCR arc\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateDisk(XEllipse3dCR arc, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer, bool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个仅有单一元素的曲线结构\n\t* \n\t* @param IBasicCurvePtr child\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(IBasicCurvePtr child, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open);\n\n\t/**\n\t* @brief B样条拷贝\n\t* @details 返回一个深度拷贝,作为B样条曲线\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneAsBsplines() const;\n\n\t/**\n\t* @brief 添加边缘点\n\t* @details 为所有的子节点添加边缘点\n\t* \n\t* @param xvector <XPoint3d> & points\n\t* @param IFacetOptionsR options\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AddStrokePoints(xvector <XPoint3d> &points, IFacetOptionsR options) const;\n\n    /**\n\t* @brief 添加面点\n\t* @details 沿着曲线计算指定距离的点\n\t* \n\t* @param xvector<double> const & distances\n\t* @param xvector<CurveDescInfo> & locations\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool AddSpacedPoints(xvector<double> const &distances, xvector<CurveDescInfo> &locations) const;\n\n\t/**\n\t* @brief 添加边缘\n\t* @details 在结构中添加所有边缘\n\t* \n\t* @param xvector <xvector<xvector<XPoint3d>>> & regionsPoints\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CollectLinearGeometry(xvector <xvector<xvector<XPoint3d>> > &regionsPoints) const;\n\n\t/**\n\t* @brief 获取B样条曲线\n\t* @details 将一个表示开放或闭合路径作为单个B样条曲线\n\t* \n\t* @return ATBsplineCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetBsplineCurve() const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n    /**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索最接近曲线的点。如果曲线是一个区域类型,同时要在该区域的内部寻找投影\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XPoint3dR curveOrRegionPoint\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification ClosestCurveOrRegionPoint(XPoint3dCR spacePoint, XPoint3dR curveOrRegionPoint) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点和终点\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点终点和他们的正切值\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @param XVec3dR unitTangentA\n\t* @param XVec3dR unitTangentB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\t/**\n\t* @brief 获取起点\n\t* @details 返回曲线的起点\n\t* \n\t* @param XPoint3dR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线总长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length() const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线经过变换后的总长度\n\t* \n\t* @param XRotMatrixCP worldToLocal\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length(XRotMatrixCP worldToLocal) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线的xyz范围\n\t* \n\t* @param XRange3dR range\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线经过变换后的范围\n\t* \n\t* @param XRange3dR range\n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\t/**\n\t* @brief 查询索引\n\t* @details 返回指定元素的索引\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t FindIndexOfPrimitive(IBasicCurveCP primitive) const;\n\n\t/**\n\t* @brief 复制曲线指定范围的曲线\n\t* @details 复制曲线指定索引和比例参数范围内的部分\n\t* \n\t* @param int index0\n\t* @param double fraction0\n\t* @param int index1\n\t* @param double fraction1\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n    ATGEOSET_EXPORT CurveSetPtr CloneBetweenCyclicIndexedFractions(int index0, double fraction0, int index1, double fraction1) const;\n\n\t/**\n\t* @brief 反转拷贝\n\t* @details 返回一个所有元素都被反转的深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneReversed() const;\n\n\t/**\n\t* @brief 查询是否包含非线性元素\n\t* @details 如果曲线有一个不非线性元素,则返回true。\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ContainsNonLinearPrimitive() const;\n\n\t/**\n\t* @brief 计算交点\n\t* @details 计算曲线与给定平面的交点\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 平面选中\n\t* @details 计算封闭曲线与平面的交叉点,并以奇偶性规则为设为起始对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param double tolerance\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr PlaneSection(XPlane3dCR plane, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 空间点位置情况\n\t* @details 当以XY平面视角看,测试给定点在曲线内、曲线上还是曲线外\n\t* \n\t* @param XPoint3dCR xyz\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification PointInOnOutXY(XPoint3dCR xyz) const;\n\n\t/**\n\t* @brief 射线击中情况\n\t* @details 测试射线击中曲线在区域内、区域上还是区域外\n\t* \n\t* @param XRay3dCR ray\n\t* @param SolidDescInfoR hitDetail\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification RayPierceInOnOut\n\t(\n\t\tXRay3dCR ray,\n\t\tSolidDescInfoR hitDetail\n\t) const;\n\n\t/**\n\t* @brief 原地变换\n\t* @details 应用给定变换并修改曲线\n\t* \n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\t/**\n\t* @brief 原地反转\n\t* @details 将所有元素进行反转\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串内的单个点被消除,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串相邻的空间点被消除（可选）,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @param bool doSimplifyLinestrings\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives(bool doSimplifyLinestrings);\n\n\t/**\n\t* @brief 原地修改以简化线串\n\t* @details 消除线串相邻的空间点\n\t* \n\t* @param double distanceTol\n\t* @param bool eliminateOverdraw\n\t* @param bool wrap\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void SimplifyLinestrings(double distTol, bool eliminateOverdraw, bool wrap);\n\n\t/**\n\t* @brief 重排元素\n\t* @details 将曲线元素重新排序以缩小元素首尾相连的间隙\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT double ReorderForSmallGaps();\n\n\t/**\n\t* @brief 链接元素\n\t* @details 将曲线的元素首尾相连\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AssembleChains();\n\n\t/**\n\t* @brief 区域相并\n\t* @details 返回给定两个区域的并\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaUnion(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相减\n\t* @details 返回给定两个区域的减\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaDifference(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相交\n\t* @details 返回给定两个区域的交\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaIntersection(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 循环索引\n\t* @details 返回给定索引值关于集合大小的模\n\t* \n\t* @param int index\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT size_t CyclicIndex(int index) const;\n\n\t/**\n\t* @brief 循环获取值\n\t* @details 根据给定索引的循环索引获取元素\n\t* \n\t* @param ptrdiff_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr GetCyclic(ptrdiff_t index) const;\n\n    /**\n    * @brief 获取索引\n    * @details 返回给定曲线元素的详细细节所对应的元素索引\n    * \n    * @param CurveDescInfo const & location\n    * @return size_t\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT size_t CurveDescInfoIndex(CurveDescInfo const& location) const;\n\n\t/**\n\t* @brief 与平面相交\n\t* @details 计算封闭曲线与平面的交叉点,返回以奇偶性规则构造的起止点对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool AppendClosedCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过给定偏移后的深度拷贝.\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AreaOffset(CurveOffsetOptionsCR options) const;\n\n\t/**\n\t* @brief 返回从index0,fraction0到index1,fraction1的曲线段\n\t* \n\t* @param int index0 \n\t* @param double fraction0 \n\t* @param int index1 \n\t* @param double fraction1 \n\t* @param bool allowExtrapolation \n\t* @return ATGEOSET_EXPORT CurveSetPtr \n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/17\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneBetweenDirectedFractions(int index0, double fraction0, int index1, double fraction1, bool allowExtrapolation) const;\n\n\t/**\n\t* @brief 返回输入的曲线的布尔奇运算结果（区域）\n\t*\n\t* @param CurveSetCR regionA\t\t\t\t\t左操作数\n\t* @param CurveSetCR regionB\t\t\t\t\t右操作数\n\t* @param BasicCurvePtrPairVector * newToOld\t（可选）包含新旧曲线的数组指针\n\t* @return ATGEOSET_EXPORT CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/07/22\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaParity(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n};\n\nstruct CurveCurve\n{\nprivate: CurveCurve();\npublic:\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tCurveSetR curveA,\n\t\tCurveSetR curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB,\n\t\tXMatrix4dCP    pWorldToLocal,\n\t\tbool         extend = false\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveR curveA,\n\t\tCurveSetR     curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tCurveSetCR chainA,\n\t\tCurveSetCR chainB\n\t);\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            double &fractionA,\n            XPoint3dR pntA,\n            double &fractionB,\n            XPoint3dR pntB\n            );\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            CurveDescInfoR detailA,\n            CurveDescInfoR detailB\n            );\n};\n\nstruct PathLocationDetail\n{\nprivate:\n\tCurveDescInfo m_curveDetail;\n\tint32_t m_pathIndex;\n\tdouble m_pathDistance;\npublic:\n\n\tATGEOSET_EXPORT PathLocationDetail();\n\n\tATGEOSET_EXPORT PathLocationDetail(PathLocationDetail const &other);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, int pathIndex = -1, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, size_t pathIndex, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(double distance);\n\n\tATGEOSET_EXPORT XPoint3d Point() const;\n\n\tATGEOSET_EXPORT CurveDescInfo GetCurveDescInfo() const;\n\n    ATGEOSET_EXPORT double DistanceFromPathStart() const;\n};\n\nstruct CurveSetWithDistanceIndex : RefCountedBase\n{\nprivate:\n\n\tstruct PathEntry : PathLocationDetail\n\t{\n\t\tdouble             m_projectedDistance;\n\t\tXRange3d           m_range;\n\t\tPathEntry(PathLocationDetail const &pathDetail, double projectedDist, XRange3dCR range)\n\t\t\t: PathLocationDetail(pathDetail),\n\t\t\tm_projectedDistance(projectedDist),\n\t\t\tm_range(range)\n\t\t{\n\t\t}\n\t\tPathEntry(double distance) : PathLocationDetail(distance), m_projectedDistance(distance) {}\n\n\t\tdouble GetDistance(bool projected) const;\n\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistanceXY(PathEntry const &dataA, PathEntry const &dataB);\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistance(PathEntry const &dataA, PathEntry const &dataB);\n\t};\n\n\tCurveSetPtr m_curveVector;\n\txvector<PathEntry> m_locations;\n\tCurveSetPtr m_savedPrimitives;\n\n\tXRotMatrix m_worldToViewRotMatrix;\n\tXRotMatrix m_viewToWorldRotMatrix;\n\tXRotMatrix m_flattenToView;\n\tXMatrix4d m_worldToView;\n\n\texplicit CurveSetWithDistanceIndex(XRotMatrix worldToView);\n\n\tCurveSetWithDistanceIndex();\n\npublic:\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create(XRotMatrix worldToView);\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create();\n\n\tATGEOSET_EXPORT void SetPath(CurveSetPtr &path);\n\n\tATGEOSET_EXPORT bool SearchByDistanceFromPathStart\n\t(\n\t\tdouble targetDist,\n\t\tPathLocationDetail &detail\n\t) const;\n\n    ATGEOSET_EXPORT PathLocationDetail SearchClosestPointBounded\n    (\n    XPoint3dCR spacePoint,\n    bool computeDistAlong\n    ) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XEllipse3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 椭圆弧\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct ATGEOSET_EXPORT XEllipse3d\n{\n\tXPoint3d center;\n\tXVec3d   vector0;\n\tXVec3d   vector90;\n\tdouble start;\n\tdouble sweep;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 返回由已有椭圆的起始和终止比例定义的椭圆弧\n\t* \n\t* @param XEllipse3dCR parent\n\t* @param double startFraction\n\t* @param double endFraction\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromFractionInterval\n\t(\n\t\tXEllipse3dCR parent,\n\t\tdouble startFraction,\n\t\tdouble endFraction\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 根据椭圆的中心点、角度为0度和90度的点,以及扫掠角度创建一个椭圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point90\n\t* @param double theta0\n\t* @param double sweep\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromPoints(XPoint3dCR center, XPoint3dCR pnt0, XPoint3dCR pnt90, double theta0, double sweep);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由起始点,起始切线,半径,扫掠角度和面法向量创建椭圆弧\n\t* \n\t* @param XPoint3dCR pointA\n\t* @param XVec3dCR tangent\n\t* @param XVec3dCR planeNormal\n\t* @param double radius\n\t* @param double sweepRadians\n\t* @return ValidatedXEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic ValidatedXEllipse3d FromStartTangentNormalRadiusSweep(\n\n\t\tXPoint3dCR pntA,\n\t\tXVec3dCR tangent,\n\t\tXVec3dCR planeNormal,\n\t\tdouble radius,\n\t\tdouble sweepRadians\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由弧上的点创建椭圆弧\n\t* \n\t* @param XPoint3dCR start\n\t* @param XPoint3dCR middle\n\t* @param XPoint3dCR end\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromPointsOnArc(XPoint3dCR start, XPoint3dCR middle, XPoint3dCR end);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、起始点和终止点的切线创建椭圆弧（扫掠角取较小的一个）\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endTarget\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromArcCenterStartEnd(XPoint3dCR center, XPoint3dCR startPoint, XPoint3dCR endTarget);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、半径和面法向量创建完整的圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param XVec3dCR normal\n\t* @param double radius\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromCenterNormalRadius(XPoint3dCR center, XVec3dCR normal, double radius);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、半径创建XY平面上完整的圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param double radius\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromCenterRadiusXY(XPoint3dCR center, double radius);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 返回给定椭圆弧以反方向扫掠得到的椭圆弧\n\t* \n\t* @param XEllipse3dCR source\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromReversed(XEllipse3dCR source);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由给定点和扫掠角初始化数据\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point90\n\t* @param double theta0\n\t* @param double sweep\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid InitFromPoints\n\t(\n\t\tXPoint3dCR      center,\n\t\tXPoint3dCR      pnt0,\n\t\tXPoint3dCR      pnt90,\n\t\tdouble          theta0,\n\t\tdouble          sweep\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由椭圆弧上的点初始化数据\n\t* \n\t* @param XPoint3dCR start\n\t* @param XPoint3dCR middle\n\t* @param XPoint3dCR end\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool InitFromPointsOnArc\n\t(\n\t\tXPoint3dCR      start,\n\t\tXPoint3dCR      middle,\n\t\tXPoint3dCR      end\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由中心点、起始点和终止点的切线初始化数据（扫掠角取较小的一个）\n\t* \n\t* @param XPoint3dCR centerIN\n\t* @param XPoint3dCR startIN\n\t* @param XPoint3dCR end\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool InitFromArcCenterStartEnd\n\t(\n\t\tXPoint3dCR      centerIN,\n\t\tXPoint3dCR      startIN,\n\t\tXPoint3dCR      end\n\t);\n\n\t/**\n\t* @brief 设置起始点\n\t* @details 修改椭圆弧的起点和终点\n\t* \n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endPoint\n\t* @param bool ccw\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool SetStartEnd\n\t(\n\t\tXPoint3dCR      startPoint,\n\t\tXPoint3dCR      endPoint,\n\t\tbool            ccw\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由中心点、半径和面法向量初始化数据\n\t* \n\t* @param XPoint3dCR centerIN\n\t* @param XVec3dCR normal\n\t* @param double radius\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid InitFromCenterNormalRadius\n\t(\n\t\tXPoint3dCR      centerIN,\n\t\tXVec3dCR      normal,\n\t\tdouble          radius\n\t);\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点\n\t* \n\t* @param XPoint3dR point\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       point,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 角到点\n\t* @details 返回椭圆弧给定参数角对应的空间点\n\t* \n\t* @param double theta\n\t* @return XPoint3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tXPoint3d RadiansToPoint(double theta) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 返回椭圆弧给定参数坐标对应的空间点\n\t* \n\t* @param XPoint3dR point\n\t* @param double xx\n\t* @param double yy\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       point,\n\t\tdouble          xx,\n\t\tdouble          yy\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点\n\t* \n\t* @param XPoint4dR point\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint4dR       point,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 获取椭圆弧的起点和终点\n\t* \n\t* @param XPoint3dR startPoint\n\t* @param XPoint3dR endPoint\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid EvaluateEndPoints\n\t(\n\t\tXPoint3dR       startPoint,\n\t\tXPoint3dR       endPoint\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点以及在参数值处的导数\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param XVec3dR dX\n\t* @param XVec3dR ddX\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tXVec3dR       dX,\n\t\tXVec3dR       ddX,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算给定的参数角比例对应的空间点\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param double fraction\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid FractionParameterToPoint\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tdouble          fraction\n\t) const;\n\n\t/**\n\t* @brief 比例到点\n\t* @details 返回给定的参数角比例对应的空间点\n\t* \n\t* @param double fraction\n\t* @return XPoint3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tXPoint3d FractionToPoint(double fraction) const;\n\n\t/**\n\t* @brief 比例到导数\n\t* @details 返回给定的参数角比例对应的空间点及在该点处的导数\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param XVec3dR dX\n\t* @param XVec3dR ddX\n\t* @param double fraction\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid FractionParameterToDerivatives\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tXVec3dR       dX,\n\t\tXVec3dR       ddX,\n\t\tdouble          fraction\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算给定的参数角比例对应的空间点及在该点处的导数,以数组形式返回\n\t* \n\t* @param XPoint3dP point3dX\n\t* @param int numDerivative\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dP       pnt3dX,\n\t\tint             numDerivative,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 点到角\n\t* @details 计算椭圆弧上的点对应的参数角\n\t* \n\t* @param XPoint3dCR point\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble PointToAngle(XPoint3dCR point) const;\n\n\t/**\n\t* @brief 投影点\n\t* @details 将给定点投影到椭圆弧所在的平面上\n\t* \n\t* @param XPoint3dR xYZNear\n\t* @param double & coff0\n\t* @param double & coff90\n\t* @param XPoint3dCR xYZ\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool ProjectPointToPlane\n\t(\n\t\tXPoint3dR       xYZNear,\n\t\tdouble          &coff0,\n\t\tdouble          &coff90,\n\t\tXPoint3dCR      xYZ\n\t) const;\n\n\t/**\n\t* @brief 角到比例\n\t* @details 计算给定参数角所对应椭圆弧上的比例\n\t* \n\t* @param double angle\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble AngleToFraction(double angle) const;\n\n\t/**\n\t* @brief 弧长\n\t* @details 返回椭圆弧的长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble ArcLength() const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 计算椭圆弧空间点的范围\n\t* \n\t* @param XRange3dR range\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief XY方向上与直线相交\n\t* @details 计算XY方向上与直线相交的交点,椭圆弧和直线都视为无界的\n\t* \n\t* @param XPoint3dP cartesianPoints\n\t* @param double * pLineParams\n\t* @param XPoint3dP ellipseCoffs\n\t* @param double * pEllipseAngle\n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endPoint\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectXYLine\n\t(\n\t\tXPoint3dP       cartesianPoints,\n\t\tdouble          *pLineParams,\n\t\tXPoint3dP       ellipseCoffs,\n\t\tdouble          *pEllipseAngle,\n\t\tXPoint3dCR      startPoint,\n\t\tXPoint3dCR      endPoint\n\t) const;\n\n\t/**\n\t* @brief 是否完整\n\t* @details 查询椭圆弧是否完整\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCircular() const;\n\n\t/**\n\t* @brief 是否完整\n\t* @details 查询椭圆弧是否完整\n\t* \n\t* @param double & radius\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCircular(double &radius) const;\n\n\t/**\n\t* @brief 是否逆时针\n\t* @details 查询椭圆弧在XY平面内的投影是否逆时针扫掠\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCCWSweepXY() const;\n\n\t/**\n\t* @brief 与线段相交\n\t* @details 计算与给定椭圆弧相交的交点,椭圆弧和线段都视为无界的\n\t* \n\t* @param XPoint3dP pointArray\n\t* @param XPoint3dP ellipseParams\n\t* @param double * pLineParams\n\t* @param XSegment3dCR segment\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectSweptXSegment3d\n\t(\n\t\tXPoint3dP       pntArray,\n\t\tXPoint3dP       ellipseParams,\n\t\tdouble          *pLineParams,\n\t\tXSegment3dCR    segment\n\t) const;\n\n\t/**\n\t* @brief 与线段相交\n\t* @details 计算与给定线段相交的交点,椭圆弧和线段都视为有界的\n\t* \n\t* @param XPoint3dP pointArray\n\t* @param XPoint3dP ellipseParams\n\t* @param double * pLineParams\n\t* @param XSegment3dCR segment\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectSweptXSegment3dBounded\n\t(\n\t\tXPoint3dP       pntArray,\n\t\tXPoint3dP       ellipseParams,\n\t\tdouble          *pLineParams,\n\t\tXSegment3dCR    segment\n\t) const;\n\n\t/**\n\t* @brief 转换为BR类型3D元素\n\t* @details 将椭圆弧转换为BR类型的3D元素\n\t* \n\t* @param XPoint3dR centerOUT\n\t* @param double * pQuatWXYZ\n\t* @param XVec3dR directionX\n\t* @param XVec3dR directionY\n\t* @param double & rx\n\t* @param double & ry\n\t* @param double & startAngle\n\t* @param double & sweepAngle\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetATFields3d\n\t(\n\t\tXPoint3dR       centerOUT,\n\t\tdouble *        pQuatWXYZ,\n\t\tXVec3dR         directionX,\n\t\tXVec3dR         directionY,\n\t\tdouble          &rx,\n\t\tdouble          &ry,\n\t\tdouble          &startAngle,\n\t\tdouble          &sweepAngle\n\t) const;\n\n\t/**\n\t* @brief 设置扫掠角\n\t* @details 设置椭圆弧的扫掠角\n\t* \n\t* @param double startAngle\n\t* @param double sweepIN\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid SetSweep\n\t(\n\t\tdouble          startAngle,\n\t\tdouble          sweepIN\n\t);\n\n\t/**\n    * @brief 获取扫掠角\n    * @details 获取椭圆弧的扫掠角\n\t* \n\t* @param double & startAngle\n\t* @param double & sweepAngle\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetSweep\n\t(\n\t\tdouble          &startAngle,\n\t\tdouble          &sweepAngle\n\t) const;\n\n\t/**\n\t* @brief 补全扫掠角\n\t* @details 根据当前的角度范围补全扫掠角\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid ComplementSweep();\n\n\t/**\n    * @brief 与弧相交\n    * @details 计算与给定椭圆弧相交的交点,椭圆弧都视为有界的\n\t* \n\t* @param XPoint3dP cartesianPoints\n\t* @param XPoint3dP ellipse0Coffs\n\t* @param double * pEllipse0Angle\n\t* @param XPoint3dP ellipse1Coffs\n\t* @param double * pEllipse1Angle\n\t* @param XEllipse3dCR ellipse1\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectXYXEllipse3dBounded\n\t(\n\t\tXPoint3dP       cartesianPoints,\n\t\tXPoint3dP       ellipse0Coffs,\n\t\tdouble          *pEllipse0Angle,\n\t\tXPoint3dP       ellipse1Coffs,\n\t\tdouble          *pEllipse1Angle,\n\t\tXEllipse3dCR    ellipse1\n\t) const;\n\n\t/**\n\t* @brief 比例到角\n\t* @details 计算给定比例参数对应的参数角\n\t* \n\t* @param double fraction\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble FractionToAngle(double fraction) const;\n\n\t/**\n\t* @brief 获取最近点\n\t* @details 获取有界椭圆弧在XY方向上离给定空间点最近的点\n\t* \n\t* @param double & minAngle\n\t* @param double & minDistanceSquared\n\t* @param XPoint3dR minPoint\n\t* @param XPoint3dCR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool ClosestPointXYBounded\n\t(\n\t\tdouble          &minAngle,\n\t\tdouble          &minDistSquared,\n\t\tXPoint3dR       minPoint,\n\t\tXPoint3dCR      point\n\t) const;\n\n\t/**\n\t* @brief 完全扫掠\n\t* @details 将椭圆弧以现有的方向扫掠完整的360°\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid MakeFullSweep();\n\n    /**\n    * @brief 获取最近点\n    * @details 在应用变换矩阵（可选）后,计算椭圆弧在XY方向上离给定点最近的点（投影或端点）\n    * \n    * @param XPoint3dR closePoint\n    * @param double & closeParam\n    * @param double & distanceXY\n    * @param XPoint3dCR spacePoint\n    * @param XMatrix4dCP worldToLocal\n    * @return bool\n    *\n    * @author SZEWEC\n    * @since 2022/04/22\n    */\n    bool ClosestPointBoundedXY\n    (\n    XPoint3dR   closePoint,\n    double&     closeParam,\n    double&     distXY,\n    XPoint3dCR  spacePoint,\n    XMatrix4dCP worldToLocal\n    ) const;\n\n    /**\n    * @brief 获取最近点\n    * @details 在应用变换矩阵（可选）后,计算椭圆弧在XY方向上离给定点最近的点（投影或端点）\n    * \n    * @param XPoint3dR closePoint\n    * @param double & closeParam\n    * @param double & distanceXY\n    * @param XPoint3dCR spacePoint\n    * @param XMatrix4dCP worldToLocal\n    * @param bool extend0\n    * @param bool extend1\n    * @return bool\n    *\n    * @author SZEWEC\n    * @since 2022/04/22\n    */\n    bool ClosestPointBoundedXY\n    (\n    XPoint3dR   closePoint,\n    double&     closeParam,\n    double&     distXY,\n    XPoint3dCR  spacePoint,\n    XMatrix4dCP worldToLocal,\n    bool extend0,\n    bool extend1\n    ) const;\n\n\t/**\n\t* @brief 获取椭圆弧的起始与终止角度\n\t*\n\t* @param double & startAngle 起始角度\n\t* @param double & endAngle 终止角度\n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/30\n\t*/\n\tvoid GetLimits\n\t(\n\t\tdouble &startAngle,\n\t\tdouble &endAngle\n\t) const;\n\n\t/**\n\t* @brief 给定0°和90°的向量创建椭圆弧\n\t*\n\t* @param XPoint3dCR center\t\t\t\t\t中心点\n\t* @param XVec3dCR vector0\t\t\t\t\t0°向量（通常为沿着主轴的方向）\n\t* @param XVec3dCR vector90\t\t\t\t\t90°向量（通常为沿着短轴的方向）\n\t* @param double theta0\t\t\t\t\t\t起始点对应的角度\n\t* @param double sweep\t\t\t\t\t\t扫掠角度\n\t* @return ATEC_NAMESPACE_NAME::XEllipse3d\t椭圆弧\n\t*\n\t* @author SZEWEC\n\t* @since 2022/06/20\n\t*/\n\tstatic XEllipse3d FromVectors\n\t(\n\t\tXPoint3dCR center,\n\t\tXVec3dCR vector0,\n\t\tXVec3dCR vector90,\n\t\tdouble theta0,\n\t\tdouble sweep\n\t);\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XPoint3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n /**\n * @brief 3D绌洪棿鐐圭被\n * @author SZEWC\n * @since 2022/04/13\n*/\nstruct ATGEOSET_EXPORT XPoint3d\n{\n\n\tdouble x;\n\n\tdouble y;\n\n\tdouble z;\n\n\tstatic XPoint3d From(double x, double y, double z = 0.0);\n\n\tstatic XPoint3d From(XPoint2dCR xy);\n\n\tstatic XPoint3d FromZero();\n\n\tstatic XPoint3d FromOne();\n\n\tstatic XPoint3d FromXYZ(double x, double y, double z);\n\n\tvoid Swap(XPoint3dR other);\n\n\tdouble DotDifference(XPoint3dCR origin, XVec3dCR vector) const;\n\n\tvoid Zero();\n\n\tvoid Init(XPoint2dCR source);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double ay);\n\n\tvoid SetComponent(double a, int index);\n\n\tdouble GetComponent(int index) const;\n\n\tvoid Interpolate(XPoint3dCR pnt0, double fractionParameter, XPoint3dCR point1);\n\n\tdouble Distance(XPoint3dCR point2) const;\n\n\tdouble DistanceXY(XPoint3dCR point2) const;\n\n\tbool DistanceXY(XPoint3dCR otherPoint, XMatrix4dCP matrix, double &distance) const;\n\n\tbool IsEqual(XPoint3dCR point2) const;\n\n\tbool IsEqual(XPoint3dCR point2, double tolerance) const;\n\n\tbool IsDisconnect() const;\n\n\tvoid InitDisconnect();\n\n\tvoid Init(XVec3dCR vector);\n\n\tvoid Subtract(XPoint3dCR base, XVec3dCR vector);\n\n\tvoid Add(XVec3dCR vector);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2, XVec3dCR point3, double scale3);\n\n\tvoid CrossProduct(XPoint3dCR point1, XPoint3dCR point2);\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble AngleTo(XPoint3dCR point2) const;\n\n\tvoid RotateXY(XPoint3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tdouble MagnitudeXY() const;\n\n\tvoid Scale(XPoint3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XPoint3dCR vector);\n\n\tvoid Negate();\n\n\tdouble Normalize(XPoint3dCR vector);\n\n\tdouble Normalize();\n\n\tvoid Subtract(XPoint3dCR point2);\n\n\tvoid DifferenceOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2, XPoint3dCR point3, double scale3);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2, XPoint3dCR point3, double a3);\n\n\tvoid Add(XPoint3dCR vector);\n\n\tvoid SumOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, XPoint3dCR point);\n\n\tstatic XPoint3d FromInterpolate(XPoint3dCR pntA, double fraction, XPoint3dCR pntB);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector, double scaleFactor);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1, XPoint3dCR point2, double scaleFactor2);\n\n\tstatic XPoint3d FromScale(XPoint3d point, double scale);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, XVec3dCR vector);\n\n\tbool AlmostEqual(XPoint3d const & dataB) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB) const;\n\n\tbool AlmostEqual(XPoint3d const & dataB, double abstol) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB, double abstol) const;\n\n\tstatic bool AlmostEqual(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tstatic bool AlmostEqualXY(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tdouble DistanceSquared(XPoint3dCR point2) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file CreateEntityExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};", "output": "\n\nvoid CreateEntityExamples::EvaluateVertexExample()\n{\n    //获得当前激活的场景\n    ATSceneRefP pSceneref = atSceneRef_getActive();\n    if (pSceneref == nullptr)\n        return;\n\n    //创建长方体\n    ISolidCoreEntityPtr cuboidEntityPtr = GetCuboidEntity();\n    HEATObject cuboidObj;\n    GeometryToATObject::ToObject(cuboidObj, *cuboidEntityPtr, nullptr, *pSceneref);\n    if (cuboidObj.IsValid())\n        cuboidObj.AddToScene();\n\n    //提取顶点的SubEntity\n    xvector<ISubEntityPtr> vertices;\n    EntityUtl::GetEntityVertices(&vertices, *cuboidEntityPtr);\n    for(ISubEntityPtr subEntityPtr : vertices)\n    {\n        //提取顶点\n        XPoint3d pt = XPoint3d::FromZero();\n        if (ATECStatus::SUCCESS != EntityUtl::EvaluateVertex(*subEntityPtr, pt))\n            continue;\n\n        //绘制点\n        XEllipse3d ellips = XEllipse3d::FromCenterRadiusXY(pt, 1000); // 椭圆\n        IBasicCurvePtr pBaisc = IBasicCurve::CreateArc(ellips);            // 基本曲线\n        CurveSetPtr pCv = CurveSet::Create(CurveSet::BOUNDARY_TYPE_Outer); // 曲线集合\n        pCv->Add(pBaisc);\n\n        //添加到场景\n        HEATObject obj;\n        GeometryToATObject::ToObject(obj, *pCv, nullptr, pSceneref->Is3d(), *pSceneref);\n        if (obj.IsValid())\n            obj.AddToScene();\n    }\n}\n\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};. You need to implement the function GetCircularEntity in the interface. Here are some apis that you can use and remember:\n code of file EntityUtl.h: \n\n#pragma once\n\n/**\n* @file EntityUtl.h\n*\n* @author SZEWC\n* @date 2022/04/27\n*/\n\n\n/**\n* @brief 以指定起终点截面的方式拉伸体\n* @details \n* \n* @param ISolidCoreEntityPtr & out \n* @param CurveSetCR startProfile \n* @param CurveSetCR endProfile \n* @param CurveSetCR path \n* @param ATSceneRefR scene \n* @param bool alignParallel \n* @param bool selfRepair \n* @param bool createSheet \n* @param XVec3dCP lockDirection \n* @param double const * twistAngle \n* @param double const * scale \n* @param XPoint3dCP scalePoint \n* @return ATEC \n*\n* @author SZEWEC\n* @since 2022/04/28\n*/\nENTITYUTIL_EXPORT ATEC::ATECStatus atSolid_EntityFromSweep\n(\nATEC::ATDataCore::ISolidCoreEntityPtr& out,\nATEC::CurveSetCR startProfile,\nATEC::CurveSetCR endProfile,\nATEC::CurveSetCR path,\nATEC::ATDataCore::ATSceneRefR scene,\nbool alignParallel,\nbool selfRepair,\nbool createSheet,\nATEC::XVec3dCP lockDirection = NULL,\ndouble const* twistAngle = NULL,\ndouble const* scale = NULL,\nATEC::XPoint3dCP scalePoint = NULL\n);\n\n/**\n* @brief 元件到体\n* @details 将给定元件转换成体\n* \n* @param BODY_TAG * bodyP\n* @param ATEC::TransformP bodyTransformP\n* @param ATEC::ATDataCore::ATObjectDescrP odP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @param UInt32 nodeId\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_elementToBody\n(\nBODY_TAG*       bodyP,          \nATEC::TransformP      bodyTransformP, \nATEC::ATDataCore::ATObjectDescrP odP,            \nATEC::ATDataCore::ATSceneRefP    SceneRef,       \nUInt32          nodeId = 1L     \n);\n\n/**\n* @brief 体到元件\n* @details 将给定体转换成元件\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\n* @param BODY_TAG bodyTag\n* @param bool wireframe\n* @param int uIsoParametrics\n* @param int vIsoParametrics\n* @param unsigned int useSmartIso\n* @param ATEC::ATDataCore::ATObjectP templateP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_bodyToObject\n(\nATEC::ATDataCore::ATObjectDescrH edPP,               \nBODY_TAG        bodyTag,            \nbool            wireframe,          \nint             uIsoParametrics,    \nint             vIsoParametrics,    \nunsigned int    useSmartIso,        \nATEC::ATDataCore::ATObjectP      tempP,          \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 面到元件\n* @details 将给定的面转换成等价的元件\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\n* @param FACE_TAG face\n* @param bool wireframe\n* @param int nIsoparametrics\n* @param ATEC::ATDataCore::ATObjectP templateP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_faceToObject\n(\nATEC::ATDataCore::ATObjectDescrH edPP,               \nFACE_TAG        face,               \nbool            wireframe,          \nint             nIsoparametrics,    \nATEC::ATDataCore::ATObjectP      tempP,          \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 体求减\n* @details 从 b2 中减去 b1\n* \n* @param BODY_TAG b2\n* @param BODY_TAG b1\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_subtract\n(\nBODY_TAG        b2,                \nBODY_TAG        b1                 \n);\n\n/**\n* @brief 面面相交\n* @details 计算两个面的交,结果以线体返回\n* \n* @param BODY_TAG * b\n* @param FACE_TAG f1\n* @param FACE_TAG f2\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_faceFaceIntersect\n(\nBODY_TAG        *b,                \nFACE_TAG        f1,                \nFACE_TAG        f2                 \n);\n\n/**\n* @brief 获取输入实体的面ID\n* \n* @param ATEC::FaceId * faceIdP\n* @param ENTITY_TAG ent\n* @param bool useHighestId\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/27\n*/\nENTITYUTIL_EXPORT int atSolid_idFromEntity\n(\nATEC::FaceId          *faceIdP,\nENTITY_TAG      ent,\nbool            useHighestId\n);\n\n/**\n* @brief 检查体\n* @details 检查输入体的几何、拓扑和尺寸有效性\n* \n* @param BODY_TAG body\n* @param bool checkGeometry\n* @param bool checkTopology\n* @param bool checkSize\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_checkBody\n(\nBODY_TAG        body,\nbool            chkGeometry,\nbool            chkTopology,\nbool            chkSize\n);\n\n/**\n* @brief 创建实体列表\n* @details 创建一个空的实体列表\n* \n* @param TAG_ENTITY_LIST * * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listCreate\n(\nTAG_ENTITY_LIST **lP            \n);\n\n/**\n* @brief 删除实体列表\n* @details 释放给定实体列表分配的内存\n* \n* @param TAG_ENTITY_LIST * * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listDelete\n(\nTAG_ENTITY_LIST **lP            \n);\n\n/**\n* @brief 列表添加元素\n* @details 往实体列表的尾部添加一个元素\n* \n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listAdd\n(\nTAG_ENTITY_LIST *lP,            \nENTITY_TAG      ent             \n);\n\n/**\n* @brief 列表添加元素\n* @details 往实体列表的尾部添加另一个列表的所有元素\n* \n* @param TAG_ENTITY_LIST * lDP\n* @param TAG_ENTITY_LIST * lSP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listAddList\n(\nTAG_ENTITY_LIST *lDP,\nTAG_ENTITY_LIST *lSP\n);\n\n/**\n* @brief 列表移除实体\n* @details 从列表中移除指定的实体\n* \n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listRemove\n(\nTAG_ENTITY_LIST *lP,\nENTITY_TAG      ent\n);\n\n/**\n* @brief 列表计数\n* @details 返回实体列表的元素个数\n* \n* @param int * count\n* @param TAG_ENTITY_LIST * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listCount\n(\nint             *count,         \nTAG_ENTITY_LIST *lP             \n);\n\n/**\n* @brief 列表查询实体\n* @details 在列表中搜索给定的实体并返回中索引,若不存在返回-1\n* \n* @param int * nth\n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listLookup\n(\nint             *nth,           \nTAG_ENTITY_LIST *lP,            \nENTITY_TAG      ent             \n);\n\n/**\n* @brief 查询列表指定位置的元素\n* @details 返回实体列表指定位置的元素\n* \n* @param ENTITY_TAG * entP\n* @param TAG_ENTITY_LIST * lP\n* @param int nth\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listNthEl\n(\nENTITY_TAG      *entP,          \nTAG_ENTITY_LIST *lP,            \nint             nth             \n);\n\n/**\n* @brief 清空列表\n* @details 移除列表中的所有元素\n* \n* @param TAG_ENTITY_LIST * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listEmpty\n(\nTAG_ENTITY_LIST *lP             \n);\n\nENTITYUTIL_EXPORT int atSolid_listCreateNonEntity (NON_ENTITY_LIST** lPP);\nENTITYUTIL_EXPORT int atSolid_listDeleteNonEntity (NON_ENTITY_LIST** lPP);\nENTITYUTIL_EXPORT int atSolid_listAddNonEntity (NON_ENTITY_LIST* lP, void* dataP);\nENTITYUTIL_EXPORT int atSolid_listCountNonEntity (int* countP, NON_ENTITY_LIST* lP);\nENTITYUTIL_EXPORT int atSolid_listNthNonEntity (void** dataPP, NON_ENTITY_LIST* lP, int nth);\n\n/**\n* @brief 偏移面\n* @details 将输入面的集合中所有面偏移指定距离,这些面必须属于同一个体\n* \n* @param TAG_ENTITY_LIST * pFaceList\n* @param double * pOffset\n* @param double tolerance\n* @param bool faceFaceCheck\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_offsetFaces\n(\nTAG_ENTITY_LIST *pFaceList,\ndouble          *pOffset,\ndouble          tolerance,\nbool            faceFaceCheck\n);\n\n/**\n* @brief 偏移线体\n* @details 返回给定线体偏移后的边缘\n* \n* @param TAG_ENTITY_LIST * pOffsetList\n* @param BODY_TAG wireBody\n* @param EDGE_TAG refEdge\n* @param ATEC::XPoint3d * pNormal\n* @param double distance\n* @param double tolerance\n* @param int gapFill\n* @param bool localCheck\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_offsetWire\n(\nTAG_ENTITY_LIST *pOffsetList,\nBODY_TAG        wireBody,\nEDGE_TAG        refEdge,\nATEC::XPoint3d        *pNormal,           \ndouble          distance,\ndouble          tolerance,\nint             gapFill,            \nbool            localCheck\n);\n\n/**\n* @brief 面上最近的点\n* @details 计算给定面上离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * clstPt\n* @param ATEC::XPoint3d * normal\n* @param ATEC::XPoint2d * param\n* @param ATEC::XPoint3d * testPt\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_closestPointToFace\n(\nATEC::XPoint3d        *clstPt,            \nATEC::XPoint3d        *normal,            \nATEC::XPoint2d        *param,             \nATEC::XPoint3d        *testPt,            \nFACE_TAG        face                \n);\n\n/**\n* @brief 边上最近的点\n* @details 计算给定边上离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * clstPt\n* @param double * param\n* @param ATEC::XPoint3d * testPt\n* @param EDGE_TAG edge\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_closestPointToEdge\n(\nATEC::XPoint3d        *clstPt,            \ndouble          *param,             \nATEC::XPoint3d        *testPt,            \nEDGE_TAG        edge               \n);\n\n/**\n* @brief 离点最近的点\n* @details 计算给定点离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * point\n* @param VERTEX_TAG vertex\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_pointFromVertex\n(\nATEC::XPoint3d        *point,             \nVERTEX_TAG      vertex              \n);\n\n/**\n* @brief 获取实体\n* @details 从给定起始点发射射线,返回体上与之相交的所有实体\n* \n* @param TAG_ENTITY_LIST * hits\n* @param double * * params\n* @param ATEC::XPoint3dP origin\n* @param ATEC::XPoint3dP dir\n* @param double radius\n* @param int type\n* @param BODY_TAG b\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getEntities\n(\nTAG_ENTITY_LIST *hits,              \ndouble          **params,           \nATEC::XPoint3dP       origin,             \nATEC::XPoint3dP       dir,                \ndouble          radius,             \nint             type,               \nBODY_TAG        b,                  \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 获取面实体\n* @details 从给定起始点发射射线,返回体上与之相交的第一个面以及相应的交点\n* \n* @param ATEC::XPoint3d * outPointP\n* @param ATEC::XPoint3d * outNormalP\n* @param FACE_TAG * outFaceP\n* @param ATEC::XPoint3d * inPointP\n* @param ATEC::XPoint3d * inNormalP\n* @param BODY_TAG body\n* @param bool backupRayOrigin\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_boresiteToFace\n(\nATEC::XPoint3d        *outPointP,         \nATEC::XPoint3d        *outNormalP,        \nFACE_TAG        *outFaceP,          \nATEC::XPoint3d        *inPointP,          \nATEC::XPoint3d        *inNormalP,         \nBODY_TAG        body,               \nbool            backupRayOrigin,    \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 曲线与面相交\n* @details 将给定部分曲线与给定的面相交,并返回曲线与面之间的交点以及相应的参数\n* \n* @param ATEC::XPoint3dP * pointPP\n* @param ATEC::XPoint2d * * faceUVPP\n* @param double * * curveParamPP\n* @param int * numIntsP\n* @param FACE_TAG face\n* @param CURVE_TAG curve\n* @param double startParam\n* @param double endParam\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_faceIntersectCurve\n(\nATEC::XPoint3dP       *pntPP,\nATEC::XPoint2d        **faceUVPP,\ndouble          **curveParamPP,\nint             *numIntsP,\nFACE_TAG        face,\nCURVE_TAG       curve,\ndouble          startParam,\ndouble          endParam\n);\n\n/**\n* @brief 获取体的包围盒\n* @details 计算给定体的包围盒\n* \n* @param ATEC::XPoint3d * lo\n* @param ATEC::XPoint3d * hi\n* @param BODY_TAG b\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getBodyBox\n(\nATEC::XPoint3d       *lo,             \nATEC::XPoint3d       *hi,             \nBODY_TAG       b                \n);\n\n/**\n* @brief 获取平滑的面列表\n* @details 向面的列表中添加一个面,并添加这个面与列表中的面的平滑连接\n* \n* @param TAG_ENTITY_LIST * listP\n* @param FACE_TAG face\n* @param bool addSmoothFaces\n* @param int allowedFaceTypeMask\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getSmoothFaceList\n(\nTAG_ENTITY_LIST *listP,\nFACE_TAG        face,\nbool            addSmoothFaces,\nint             allowedFaceTypeMask\n);\n\nenum SmoothEdgeType\n    {\n    SMOOTH_TYPE_NONE  = 0,\n    SMOOTH_TYPE_BLEND = 1,\n    SMOOTH_TYPE_TANGENT = 2\n    };\n\n/**\n* @brief 面的所有边\n* @details 返回构成面的所有边\n* \n* @param TAG_ENTITY_LIST * edgeListP\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getEdgeListFromFace\n(\nTAG_ENTITY_LIST *edgeListP,         \nFACE_TAG        face                \n);\n\n/**\n* @brief 线体是否G1连续\n* @details 查询线体是否关于所有点G1连续\n* \n* @param BODY_TAG wire\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_wireIsG1\n(\nBODY_TAG        wire\n);\n\n/**\n* @brief 实体最小距离\n* @details 计算两个实体之间的最小距离\n* \n* @param ATEC::XPoint3dP pPoint1\n* @param ATEC::XPoint3dP pPoint2\n* @param double * pDistance\n* @param ENTITY_TAG entity1\n* @param ENTITY_TAG entity2\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_minimumDistanceBetweenEntities\n(\nATEC::XPoint3dP           pPoint1,\nATEC::XPoint3dP           pPoint2,\ndouble              *pDist,\nENTITY_TAG          entity1,\nENTITY_TAG          entity2\n);\n\n/**\n* @brief 简化体\n* @details 尝试将B样条曲线和曲面简化为分析曲线和曲面\n* \n* @param BODY_TAG * bodyP\n* @param bool local\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_simplifyBody\n(\nBODY_TAG        *bodyP,\nbool            local\n);\n\n/**\n* @brief 开始转换\n* @details 将变换矩阵推入堆栈中\n* \n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_beginCurrTrans (ATEC::ATDataCore::ATSceneRefP SceneRef);\n\n/**\n* @brief 结束转换\n* @details 从堆栈中弹出brSolid_beginCurrTrans推入的变换矩阵\n* \n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_endCurrTrans ();\n\n/**\n* @brief 应用变换\n* @details 对体应用给定变换\n* \n* @param ENTITY_TAG entity\n* @param ATEC::TransformP transformP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_applyTransform\n(\nENTITY_TAG      entity,            \nATEC::TransformP      transformP         \n);\n\n/**\n* @brief 给薄面体加盖\n* @details 通过添加其他面封闭给定的薄面体并转换为体\n* \n* @param TAG_ENTITY_LIST * faces\n* @param BODY_TAG * lamina\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_capSurface\n(\nTAG_ENTITY_LIST *faces,             \nBODY_TAG        *lamina             \n);\n\n/**\n* @brief 逆转体\n* @details 将体中的所有面逆转方向\n* \n* @param BODY_TAG body\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_reverseBody\n(\nBODY_TAG        body               \n);\n\n/**\n* @brief 删除实体\n* @details 删除给定的实体\n* \n* @param ENTITY_TAG e\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_deleteEntity\n(\nENTITY_TAG      e                  \n);\n\n/**\n* @brief 复制体\n* @details 创建给定体的一个复制\n* \n* @param BODY_TAG * copy\n* @param BODY_TAG source\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_copyBody\n(\nBODY_TAG        *copy,\nBODY_TAG        source\n);\n\n/**\n* @brief 删除体\n* @details 释放体所分配的内存\n* \n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_freeBody\n(\nBODY_TAG        body               \n);\n\n/**\n* @brief 释放内存\n* @details 释放列表所分配的内存\n* \n* @param void * v\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_free\n(\nvoid            *v\n);\n\n/**\n* @brief 边缘数据\n* @details 返回边缘的拓扑和几何信息\n* \n* @param VERTEX_TAG * startVertexP\n* @param VERTEX_TAG * endVertexP\n* @param ATEC::XPoint3d * startPointP\n* @param ATEC::XPoint3d * endPointP\n* @param double * startParamP\n* @param double * endParamP\n* @param COEDGE_TAG * coEdgeP\n* @param CURVE_TAG * curveP\n* @param bool * reversedP\n* @param EDGE_TAG edge\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_edgeData\n(\nVERTEX_TAG      *startVertexP,  \nVERTEX_TAG      *endVertexP,    \nATEC::XPoint3d        *startPointP,   \nATEC::XPoint3d        *endPointP,     \ndouble          *startParamP,   \ndouble          *endParamP,     \nCOEDGE_TAG      *coEdgeP,       \nCURVE_TAG       *curveP,        \nbool            *reversedP,     \nEDGE_TAG        edge            \n);\n\n/**\n* @brief 获取所有边\n* @details 返回体的所有边列表\n* \n* @param TAG_ENTITY_LIST * listP\n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getEdgeList\n(\nTAG_ENTITY_LIST *listP,             \nBODY_TAG        body                \n);\n\n/**\n* @brief 获取所有面\n* @details 返回体的所有面列表\n* \n* @param TAG_ENTITY_LIST * listP\n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getFaceList\n(\nTAG_ENTITY_LIST *listP,             \nBODY_TAG        body                \n);\n\n/**\n* @brief 体的首条边\n* @details 返回体的第一条边\n* \n* @param EDGE_TAG * pEdge\n* @param BODY_TAG body\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_bodyAskFirstEdge\n(\nEDGE_TAG        *pEdge,\nBODY_TAG        body\n);\n\n/**\n* @brief 创建空体\n* @details 创建一个最小的仅包含一个点的体\n* \n* @param BODY_TAG * b\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_body\n(\nBODY_TAG        *b                  \n);\n\n/**\n* @brief 面集到薄面体\n* @details 将输入的面拼接并创建一个薄面体,所有的面必须来自同一个体\n* \n* @param BODY_TAG * sheetP\n* @param TAG_ENTITY_LIST * faceListP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sheetFromFaces\n(\nBODY_TAG        *sheetP,            \nTAG_ENTITY_LIST *faceListP          \n);\n\n/**\n* @brief 面到薄面体\n* @details 根据输入的单个面创建一个薄面体\n* \n* @param BODY_TAG * sheetP\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sheetFromFace\n(\nBODY_TAG        *sheetP,          \nFACE_TAG        face              \n);\n\n/**\n* @brief 揭开面\n* @details 将输入的面从所属的薄面体中移除\n* \n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_uncoverFace\n(\nFACE_TAG        face\n);\n\n/**\n* @brief 两个体压印\n* @details 计算两个体的交并把交压印到目标体或两个体上\n* \n* @param TAG_ENTITY_LIST * pTargetEdges\n* @param TAG_ENTITY_LIST * pToolEdges\n* @param BODY_TAG target\n* @param BODY_TAG tool\n* @param double tolerance\n* @param bool imprintTool\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintBodies\n(\nTAG_ENTITY_LIST *pTargetEdges,  \nTAG_ENTITY_LIST *pToolEdges,    \nBODY_TAG        target,         \nBODY_TAG        tool,           \ndouble          tolerance,      \nbool            imprintTool     \n);\n\nENTITYUTIL_EXPORT bool atSolid_isSmartObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetOrSolidObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSceneerObject (ATEC::ATDataCore::ATObjectDescrP odP);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetBody (BODY_TAG bodyTag);\n\nENTITYUTIL_EXPORT bool atSolid_isWireBody (BODY_TAG bodyTag);\n\nENTITYUTIL_EXPORT bool atSolid_isFace (ENTITY_TAG entityTag);\n\nENTITYUTIL_EXPORT bool atSolid_isEdge (ENTITY_TAG entityTag);\n\n/**\n* @brief 获取FACE_TYPE\n* @details 返回FACE_TYPE常数\n* \n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_faceType ();\n\n/**\n* @brief 获取EDGE_TYPE\n* @details 返回EDGE_TYPE常数\n* \n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_edgeType ();\n\nENTITYUTIL_EXPORT void atSolid_moveBoresiteToEyePoint\n(\nATEC::XPoint3d        *pBorePoint,\nATEC::XPoint3d        *pBoreDirection,\nBODY_TAG        pBody\n);\n\nENTITYUTIL_EXPORT void atSolid_displayFace\n(\nTransDescrP     *transientPP,   \nFACE_TAG        faceP,\nbool            display,\nbool            showSmoothFaces,\nint             allowedFaceTypeMask,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             weight,\nint             style\n);\n\nENTITYUTIL_EXPORT void atSolid_displayEdge\n(\nTransDescrP     *transientPP,   \nEDGE_TAG        edgeP,          \nbool            display,        \nSmoothEdgeType  smoothSequence, \nbool            showStart,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             weight,\nint             style\n);\n\nENTITYUTIL_EXPORT int atSolid_createMark\n(\nint             *markP\n);\n\nENTITYUTIL_EXPORT int atSolid_gotoMark\n(\nint             mark\n);\n\nENTITYUTIL_EXPORT int atSolid_deleteMark\n(\nint             mark\n);\n\nENTITYUTIL_EXPORT void atSolid_getBoresiteWithBodyTransform\n(\nATEC::XPoint3dP       borePointP,         \nATEC::XPoint3dP       boreDirectionP,     \nATEC::XPoint3dCP      pntP,             \nint             view,               \nATEC::ATDataCore::ATSceneRefP    SceneRef,           \nATEC::TransformCP     bodyTransformP,     \nbool            useACS,             \nbool            frontClipBorePoint  \n);\n\nENTITYUTIL_EXPORT void atSolid_displayFaceWithBodyTransform\n(\nTransDescrP     *transientPP,       \nFACE_TAG        faceP,\nATEC::TransformP      bodyTransformP,     \nbool            display,\nbool            showSmoothFaces,\nint             nIsoParametrics,    \nint             allowedFaceTypeMask,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             style,\nint             weight\n);\n\nENTITYUTIL_EXPORT void atSolid_displayEdgeWithBodyTransform\n(\nTransDescrP     *transientPP,       \nEDGE_TAG        edgeP,              \nATEC::TransformP      bodyTransformP,     \nbool            display,            \nSmoothEdgeType  smoothSequence,     \nbool            showStart,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nUInt32          color,\nlong            style,\nUInt32          weight,\nbool            showAllEdgesWithSameId\n);\n\nENTITYUTIL_EXPORT int atSolid_getSharedEdgesOfFaces\n(\nTAG_ENTITY_LIST     *edgeListP,\nTAG_ENTITY_LIST     *faceListP\n);\n\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_getBSplineFromSmartSurface\n(\nATEC::ATBsplineSurface*   pBSurface,\nBODY_TAG            bodyP\n);\n\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_getBSplineFromSmartSurface2\n(\nATEC::ATBsplineSurface*   pBSurface,\nBODY_TAG            bodyP,\nATEC::TransformP          bodyTransformP,\nATEC::ATDataCore::ATSceneRefP        SceneRef\n);\n\n#define     SOLIDTEMPLATE_OPTION_None               0\n#define     SOLIDTEMPLATE_OPTION_PreserveElemId     1\n#define     SOLIDTEMPLATE_OPTION_PrimaryClass       2\n\nENTITYUTIL_EXPORT ATEC::ATDataCore::ATObjectP  atSolid_createBrepTemplateForOdP\n(\nATEC::ATDataCore::ATObjectP          objectP,   \nATEC::ATDataCore::ATObjectDescrCP    odP,        \nUInt32              options     \n);\n\n/**\n* @brief 沿线拉伸体\n* @details 沿着输入的线体拉伸线体或薄面体\n* \n* @param BODY_TAG * bodyP\n* @param BODY_TAG wireBody\n* @param ATEC::XPoint3d * pathStartP\n* @param double shell\n* @param bool capped\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sweepBodyWire\n(\n\tBODY_TAG        *bodyP,\n\tBODY_TAG        wireBody,\n\tATEC::XPoint3d        *pathStartP,\n\tdouble          shell,\n\tbool            capped,\n\tATEC::ATDataCore::ATSceneRefP    SceneRef\n);\n\n/**\n* @brief 根据面ID从输入的体中寻找面\n* \n* @param FACE_TAG * faceP \n* @param ATEC::FaceId * faceIdP \n* @param BODY_TAG body \n* @return ENTITYUTIL_EXPORT int \n*\n* @author SZEWEC\n* @since 2022/04/29\n*/\nENTITYUTIL_EXPORT int atSolid_faceFromId\n(\n\tFACE_TAG        *faceP,\n\tATEC::FaceId          *faceIdP,\n\tBODY_TAG        body\n);\n\n/**\n* @brief 使用输入的边生成元素,当元素代表边的一部分的时候该接口接收一个起始和终止参数\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\t\t生成的元素\n* @param ATEC::ATDataCore::ATObjectP templateP\t\t生成元素的模板,传NULL时使用默认样式\n* @param EDGE_TAG edge\t\t\t\t\t\t\t\t边\n* @param double * startParameterP\t\t\t\t\t传NULL时使用边的起点,否则为该参数指定的点（位于边上）作为起点\n* @param double * endParameterP\t\t\t\t\t\t传NULL时使用边的终点,否则为该参数指定的点（位于边上）作为终点\n* @param ATEC::ATDataCore::ATScenesRefP SceneRef\t生成的元素所在的场景\n* @return ENTITYUTIL_EXPORT int\t\t\t\t\t\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/05\n*/\nENTITYUTIL_EXPORT int atSolid_elementFromEdge\n(\n\tATEC::ATDataCore::ATObjectDescrH edPP,\n\tATEC::ATDataCore::ATObjectP      tempP,\n\tEDGE_TAG        edge,\n\tdouble          *startParameterP,\n\tdouble          *endParameterP,\n\tATEC::ATDataCore::ATSceneRefP    SceneRef\n);\n\n/**\n* @brief 将给定的曲线压印到实体上\n*\n* @param TAG_ENTITY_LIST * pImprintList\t\t[out] 压印到实体上的结果曲线,或者NULL\n* @param BODY_TAG body\t\t\t\t\t\t[in ] 实体\n* @param TAG_ENTITY_LIST * pEdgeList\t\t[in ] 待压印的曲线\n* @param ATEC::XPoint3d * pVector\t\t\t[in ] 压印（投影）的方向\n* @param double tolerance\t\t\t\t\t[in ] 容差,用于解决容差问题与计算参数空间曲线需要\n* @return ENTITYUTIL_EXPORT ATEC::StatusInt\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/30\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintCurveSet\n(\n\tTAG_ENTITY_LIST *pImprintList,\n\tBODY_TAG        body,\n\tTAG_ENTITY_LIST *pEdgeList,\n\tATEC::XPoint3d        *pVector,\n\tdouble          tolerance\n);\n\n/**\n* @brief 将给定的曲线沿着面的法线方向压印到实体上\n*\n* @param TAG_ENTITY_LIST * pImprintList\t\t[out] 压印到实体上的结果曲线,或者NULL\n* @param BODY_TAG body\t\t\t\t\t\t[in ] 实体\n* @param TAG_ENTITY_LIST * pEdgeList\t\t[in ] 待压印的曲线\n* @param double tolerance\t\t\t\t\t[in ] 容差,用于解决容差问题与计算参数空间曲线需要\n* @return ENTITYUTIL_EXPORT ATEC::StatusInt\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/30\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintCurveNormal\n(\n\tTAG_ENTITY_LIST *pImprintList,\n\tBODY_TAG        body,\n\tTAG_ENTITY_LIST *pEdgeList,\n\tdouble          tolerance\n);\n\n\n code of file CreateEntityExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};", "output": "\n\nISolidCoreEntityPtr CreateEntityExamples::GetCircularEntity()\n{\n    // 准备截面\n    CurveSetPtr profileCirclePtr = GetCircle();\n    CurveSetPtr profileCopyPtr = TransformCircle(profileCirclePtr);\n    xvector<CurveSetPtr> profiles = { profileCirclePtr ,profileCopyPtr };\n\n    // loft造体\n    ISolidCoreEntityPtr circularEntityPtr = nullptr;\n    ATSceneRefP pSceneref = atSceneRef_getActive();\n    EntityUtl::Create::EntityFromLoft(circularEntityPtr, profiles.data(), profiles.size(), NULL, 0, *pSceneref);\n\n    return circularEntityPtr;\n}\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};. You need to implement the function GetCircle in the interface. Here are some apis that you can use and remember:\n code of file IBasicCurve.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 基本线元类\n* @author SZEWC\n* @since 2022/04/28\n*/\nstruct IBasicCurve : public RefCountedBase\n{\nprivate: virtual void IAmAbstractClass() = 0;\n\npublic:\n\tenum BasicCurveType\n\t{\n\t\tBCURVE_TYPE_Invalid = 0,\n\t\tBCURVE_TYPE_Line = 1,\n\t\tBCURVE_TYPE_LineString = 2,\n\t\tBCURVE_TYPE_Arc = 3,\n\t\tBCURVE_TYPE_BsplineCurve = 4,\n\t\tBCURVE_TYPE_InterpolationCurve = 5,\n\t\tBCURVE_TYPE_AkimaCurve = 6,\n\t\tBCURVE_TYPE_PointString = 7,\n\t\tBCURVE_TYPE_CurveSet = 8,\n\t\tBCURVE_TYPE_Spiral = 9,\n\t\tBCURVE_TYPE_PartialCurve = 10,\n\t\tBCURVE_TYPE_NotClassified = -1,\n\t};\n\n\tATGEOSET_EXPORT int64_t GetTag() const;\n\n\tATGEOSET_EXPORT int GetIntTag() const;\n\n\tATGEOSET_EXPORT void SetTag(int64_t tag);\n\n\tATGEOSET_EXPORT void SetTag(int tag);\n\n\tATGEOSET_EXPORT CurveSetPtr GetChildCurveSetP();\n\npublic:\n\tATGEOSET_EXPORT xvector<XPoint3d> * GetLineStringP();\n\n\tATGEOSET_EXPORT BasicCurveType           GetBasicCurveType() const;\n\n\tATGEOSET_EXPORT bool TryGetLine(XSegment3dR segment) const;\n\n\tATGEOSET_EXPORT bool TryGetArc(XEllipse3dR arc) const;\n\n\tATGEOSET_EXPORT XSegment3dCP                 GetLineCP() const;\n\n\tATGEOSET_EXPORT xvector<XPoint3d> const* GetLineStringCP() const;\n\n\tATGEOSET_EXPORT bool TryGetSegmentInLineString(XSegment3dR segment, size_t startPointIndex) const;\n\n\tATGEOSET_EXPORT XEllipse3dCP                 GetArcCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurveCP             GetBsplineCurveCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr             GetBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr            GetProxyBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT XSpiral2dPlacementCP         GetSpiralPlacementCP() const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLine(XSegment3dCR segment);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(XPoint3dCP points, size_t nPoints);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(xvector<XPoint3d> const &points);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateArc(XEllipse3dCR ellipse);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurveCR curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurvePtr& curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiral(XSpiral2dBaseCR spiral, TransformCR frame,\n\t\tdouble fractionA, double fractionB);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusBearingRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble endRadians,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusLengthRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble length,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT IBasicCurvePtr Clone() const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneComponent(ptrdiff_t componentIndex) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneAsSingleOffsetPrimitiveXY(CurveOffsetOptionsCR options) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XRay3dR ray) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, CurveDescInfo &detail) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2, XVec3dR derivative3) const;\n\n\tATGEOSET_EXPORT bool FractionToFrenetFrame(double f, TransformR frame) const;\n\n\tATGEOSET_EXPORT bool Length(double &length) const;\n\n\tATGEOSET_EXPORT bool Length(XRotMatrixCP worldToLocal, double &length) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\tATGEOSET_EXPORT size_t NumComponent() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetATBsplineCurvePtr(double fraction0 = 0.0, double fraction1 = 1.0) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(XRotMatrixCP worldToView, double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool TrySetStart(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TrySetEnd(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\tATGEOSET_EXPORT void  AppendCurvePlaneIntersections\n\t(\n\t\tXPlane3dByVectorsCR plane,\n\t\tUVBoundarySelect   bounded,\n\t\txvector<CurveAndSolidDescInfo> &intersections\n\t) const;\n\n\tATGEOSET_EXPORT bool AddStrokes(xvector <XPoint3d> &points, IFacetOptionsR options,\n\t\tbool includeStartPoint = true,\n\t\tdouble startFraction = 0.0,\n\t\tdouble endFraction = 1.0\n\t) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, double &fraction, XPoint3dR curvePoint) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneBetweenFractions(double fractionA, double fractionB, bool allowExtrapolation) const;\n\n\tATGEOSET_EXPORT CurveSetCP            GetChildCurveSetCP() const;\n\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(double startFraction, double endFraction, double &signedDist) const;\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(XRotMatrixCP worldToLocal, double startFraction, double endFraction, double &signedDist) const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateRectangle(double x0, double y0, double x1, double y1, double z, int areaSignPref = 0);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateChildCurveSet(CurveSetPtr source);\n\n\tATGEOSET_EXPORT bool  TryGetPartialCurveData(double &fractionA, double &fractionB, IBasicCurvePtr &parentCurve, int64_t &tag) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XEllipse3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 椭圆弧\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct ATGEOSET_EXPORT XEllipse3d\n{\n\tXPoint3d center;\n\tXVec3d   vector0;\n\tXVec3d   vector90;\n\tdouble start;\n\tdouble sweep;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 返回由已有椭圆的起始和终止比例定义的椭圆弧\n\t* \n\t* @param XEllipse3dCR parent\n\t* @param double startFraction\n\t* @param double endFraction\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromFractionInterval\n\t(\n\t\tXEllipse3dCR parent,\n\t\tdouble startFraction,\n\t\tdouble endFraction\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 根据椭圆的中心点、角度为0度和90度的点,以及扫掠角度创建一个椭圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point90\n\t* @param double theta0\n\t* @param double sweep\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromPoints(XPoint3dCR center, XPoint3dCR pnt0, XPoint3dCR pnt90, double theta0, double sweep);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由起始点,起始切线,半径,扫掠角度和面法向量创建椭圆弧\n\t* \n\t* @param XPoint3dCR pointA\n\t* @param XVec3dCR tangent\n\t* @param XVec3dCR planeNormal\n\t* @param double radius\n\t* @param double sweepRadians\n\t* @return ValidatedXEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic ValidatedXEllipse3d FromStartTangentNormalRadiusSweep(\n\n\t\tXPoint3dCR pntA,\n\t\tXVec3dCR tangent,\n\t\tXVec3dCR planeNormal,\n\t\tdouble radius,\n\t\tdouble sweepRadians\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由弧上的点创建椭圆弧\n\t* \n\t* @param XPoint3dCR start\n\t* @param XPoint3dCR middle\n\t* @param XPoint3dCR end\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromPointsOnArc(XPoint3dCR start, XPoint3dCR middle, XPoint3dCR end);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、起始点和终止点的切线创建椭圆弧（扫掠角取较小的一个）\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endTarget\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromArcCenterStartEnd(XPoint3dCR center, XPoint3dCR startPoint, XPoint3dCR endTarget);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、半径和面法向量创建完整的圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param XVec3dCR normal\n\t* @param double radius\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromCenterNormalRadius(XPoint3dCR center, XVec3dCR normal, double radius);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、半径创建XY平面上完整的圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param double radius\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromCenterRadiusXY(XPoint3dCR center, double radius);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 返回给定椭圆弧以反方向扫掠得到的椭圆弧\n\t* \n\t* @param XEllipse3dCR source\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromReversed(XEllipse3dCR source);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由给定点和扫掠角初始化数据\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point90\n\t* @param double theta0\n\t* @param double sweep\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid InitFromPoints\n\t(\n\t\tXPoint3dCR      center,\n\t\tXPoint3dCR      pnt0,\n\t\tXPoint3dCR      pnt90,\n\t\tdouble          theta0,\n\t\tdouble          sweep\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由椭圆弧上的点初始化数据\n\t* \n\t* @param XPoint3dCR start\n\t* @param XPoint3dCR middle\n\t* @param XPoint3dCR end\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool InitFromPointsOnArc\n\t(\n\t\tXPoint3dCR      start,\n\t\tXPoint3dCR      middle,\n\t\tXPoint3dCR      end\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由中心点、起始点和终止点的切线初始化数据（扫掠角取较小的一个）\n\t* \n\t* @param XPoint3dCR centerIN\n\t* @param XPoint3dCR startIN\n\t* @param XPoint3dCR end\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool InitFromArcCenterStartEnd\n\t(\n\t\tXPoint3dCR      centerIN,\n\t\tXPoint3dCR      startIN,\n\t\tXPoint3dCR      end\n\t);\n\n\t/**\n\t* @brief 设置起始点\n\t* @details 修改椭圆弧的起点和终点\n\t* \n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endPoint\n\t* @param bool ccw\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool SetStartEnd\n\t(\n\t\tXPoint3dCR      startPoint,\n\t\tXPoint3dCR      endPoint,\n\t\tbool            ccw\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由中心点、半径和面法向量初始化数据\n\t* \n\t* @param XPoint3dCR centerIN\n\t* @param XVec3dCR normal\n\t* @param double radius\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid InitFromCenterNormalRadius\n\t(\n\t\tXPoint3dCR      centerIN,\n\t\tXVec3dCR      normal,\n\t\tdouble          radius\n\t);\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点\n\t* \n\t* @param XPoint3dR point\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       point,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 角到点\n\t* @details 返回椭圆弧给定参数角对应的空间点\n\t* \n\t* @param double theta\n\t* @return XPoint3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tXPoint3d RadiansToPoint(double theta) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 返回椭圆弧给定参数坐标对应的空间点\n\t* \n\t* @param XPoint3dR point\n\t* @param double xx\n\t* @param double yy\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       point,\n\t\tdouble          xx,\n\t\tdouble          yy\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点\n\t* \n\t* @param XPoint4dR point\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint4dR       point,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 获取椭圆弧的起点和终点\n\t* \n\t* @param XPoint3dR startPoint\n\t* @param XPoint3dR endPoint\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid EvaluateEndPoints\n\t(\n\t\tXPoint3dR       startPoint,\n\t\tXPoint3dR       endPoint\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点以及在参数值处的导数\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param XVec3dR dX\n\t* @param XVec3dR ddX\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tXVec3dR       dX,\n\t\tXVec3dR       ddX,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算给定的参数角比例对应的空间点\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param double fraction\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid FractionParameterToPoint\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tdouble          fraction\n\t) const;\n\n\t/**\n\t* @brief 比例到点\n\t* @details 返回给定的参数角比例对应的空间点\n\t* \n\t* @param double fraction\n\t* @return XPoint3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tXPoint3d FractionToPoint(double fraction) const;\n\n\t/**\n\t* @brief 比例到导数\n\t* @details 返回给定的参数角比例对应的空间点及在该点处的导数\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param XVec3dR dX\n\t* @param XVec3dR ddX\n\t* @param double fraction\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid FractionParameterToDerivatives\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tXVec3dR       dX,\n\t\tXVec3dR       ddX,\n\t\tdouble          fraction\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算给定的参数角比例对应的空间点及在该点处的导数,以数组形式返回\n\t* \n\t* @param XPoint3dP point3dX\n\t* @param int numDerivative\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dP       pnt3dX,\n\t\tint             numDerivative,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 点到角\n\t* @details 计算椭圆弧上的点对应的参数角\n\t* \n\t* @param XPoint3dCR point\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble PointToAngle(XPoint3dCR point) const;\n\n\t/**\n\t* @brief 投影点\n\t* @details 将给定点投影到椭圆弧所在的平面上\n\t* \n\t* @param XPoint3dR xYZNear\n\t* @param double & coff0\n\t* @param double & coff90\n\t* @param XPoint3dCR xYZ\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool ProjectPointToPlane\n\t(\n\t\tXPoint3dR       xYZNear,\n\t\tdouble          &coff0,\n\t\tdouble          &coff90,\n\t\tXPoint3dCR      xYZ\n\t) const;\n\n\t/**\n\t* @brief 角到比例\n\t* @details 计算给定参数角所对应椭圆弧上的比例\n\t* \n\t* @param double angle\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble AngleToFraction(double angle) const;\n\n\t/**\n\t* @brief 弧长\n\t* @details 返回椭圆弧的长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble ArcLength() const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 计算椭圆弧空间点的范围\n\t* \n\t* @param XRange3dR range\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief XY方向上与直线相交\n\t* @details 计算XY方向上与直线相交的交点,椭圆弧和直线都视为无界的\n\t* \n\t* @param XPoint3dP cartesianPoints\n\t* @param double * pLineParams\n\t* @param XPoint3dP ellipseCoffs\n\t* @param double * pEllipseAngle\n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endPoint\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectXYLine\n\t(\n\t\tXPoint3dP       cartesianPoints,\n\t\tdouble          *pLineParams,\n\t\tXPoint3dP       ellipseCoffs,\n\t\tdouble          *pEllipseAngle,\n\t\tXPoint3dCR      startPoint,\n\t\tXPoint3dCR      endPoint\n\t) const;\n\n\t/**\n\t* @brief 是否完整\n\t* @details 查询椭圆弧是否完整\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCircular() const;\n\n\t/**\n\t* @brief 是否完整\n\t* @details 查询椭圆弧是否完整\n\t* \n\t* @param double & radius\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCircular(double &radius) const;\n\n\t/**\n\t* @brief 是否逆时针\n\t* @details 查询椭圆弧在XY平面内的投影是否逆时针扫掠\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCCWSweepXY() const;\n\n\t/**\n\t* @brief 与线段相交\n\t* @details 计算与给定椭圆弧相交的交点,椭圆弧和线段都视为无界的\n\t* \n\t* @param XPoint3dP pointArray\n\t* @param XPoint3dP ellipseParams\n\t* @param double * pLineParams\n\t* @param XSegment3dCR segment\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectSweptXSegment3d\n\t(\n\t\tXPoint3dP       pntArray,\n\t\tXPoint3dP       ellipseParams,\n\t\tdouble          *pLineParams,\n\t\tXSegment3dCR    segment\n\t) const;\n\n\t/**\n\t* @brief 与线段相交\n\t* @details 计算与给定线段相交的交点,椭圆弧和线段都视为有界的\n\t* \n\t* @param XPoint3dP pointArray\n\t* @param XPoint3dP ellipseParams\n\t* @param double * pLineParams\n\t* @param XSegment3dCR segment\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectSweptXSegment3dBounded\n\t(\n\t\tXPoint3dP       pntArray,\n\t\tXPoint3dP       ellipseParams,\n\t\tdouble          *pLineParams,\n\t\tXSegment3dCR    segment\n\t) const;\n\n\t/**\n\t* @brief 转换为BR类型3D元素\n\t* @details 将椭圆弧转换为BR类型的3D元素\n\t* \n\t* @param XPoint3dR centerOUT\n\t* @param double * pQuatWXYZ\n\t* @param XVec3dR directionX\n\t* @param XVec3dR directionY\n\t* @param double & rx\n\t* @param double & ry\n\t* @param double & startAngle\n\t* @param double & sweepAngle\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetATFields3d\n\t(\n\t\tXPoint3dR       centerOUT,\n\t\tdouble *        pQuatWXYZ,\n\t\tXVec3dR         directionX,\n\t\tXVec3dR         directionY,\n\t\tdouble          &rx,\n\t\tdouble          &ry,\n\t\tdouble          &startAngle,\n\t\tdouble          &sweepAngle\n\t) const;\n\n\t/**\n\t* @brief 设置扫掠角\n\t* @details 设置椭圆弧的扫掠角\n\t* \n\t* @param double startAngle\n\t* @param double sweepIN\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid SetSweep\n\t(\n\t\tdouble          startAngle,\n\t\tdouble          sweepIN\n\t);\n\n\t/**\n    * @brief 获取扫掠角\n    * @details 获取椭圆弧的扫掠角\n\t* \n\t* @param double & startAngle\n\t* @param double & sweepAngle\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetSweep\n\t(\n\t\tdouble          &startAngle,\n\t\tdouble          &sweepAngle\n\t) const;\n\n\t/**\n\t* @brief 补全扫掠角\n\t* @details 根据当前的角度范围补全扫掠角\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid ComplementSweep();\n\n\t/**\n    * @brief 与弧相交\n    * @details 计算与给定椭圆弧相交的交点,椭圆弧都视为有界的\n\t* \n\t* @param XPoint3dP cartesianPoints\n\t* @param XPoint3dP ellipse0Coffs\n\t* @param double * pEllipse0Angle\n\t* @param XPoint3dP ellipse1Coffs\n\t* @param double * pEllipse1Angle\n\t* @param XEllipse3dCR ellipse1\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectXYXEllipse3dBounded\n\t(\n\t\tXPoint3dP       cartesianPoints,\n\t\tXPoint3dP       ellipse0Coffs,\n\t\tdouble          *pEllipse0Angle,\n\t\tXPoint3dP       ellipse1Coffs,\n\t\tdouble          *pEllipse1Angle,\n\t\tXEllipse3dCR    ellipse1\n\t) const;\n\n\t/**\n\t* @brief 比例到角\n\t* @details 计算给定比例参数对应的参数角\n\t* \n\t* @param double fraction\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble FractionToAngle(double fraction) const;\n\n\t/**\n\t* @brief 获取最近点\n\t* @details 获取有界椭圆弧在XY方向上离给定空间点最近的点\n\t* \n\t* @param double & minAngle\n\t* @param double & minDistanceSquared\n\t* @param XPoint3dR minPoint\n\t* @param XPoint3dCR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool ClosestPointXYBounded\n\t(\n\t\tdouble          &minAngle,\n\t\tdouble          &minDistSquared,\n\t\tXPoint3dR       minPoint,\n\t\tXPoint3dCR      point\n\t) const;\n\n\t/**\n\t* @brief 完全扫掠\n\t* @details 将椭圆弧以现有的方向扫掠完整的360°\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid MakeFullSweep();\n\n    /**\n    * @brief 获取最近点\n    * @details 在应用变换矩阵（可选）后,计算椭圆弧在XY方向上离给定点最近的点（投影或端点）\n    * \n    * @param XPoint3dR closePoint\n    * @param double & closeParam\n    * @param double & distanceXY\n    * @param XPoint3dCR spacePoint\n    * @param XMatrix4dCP worldToLocal\n    * @return bool\n    *\n    * @author SZEWEC\n    * @since 2022/04/22\n    */\n    bool ClosestPointBoundedXY\n    (\n    XPoint3dR   closePoint,\n    double&     closeParam,\n    double&     distXY,\n    XPoint3dCR  spacePoint,\n    XMatrix4dCP worldToLocal\n    ) const;\n\n    /**\n    * @brief 获取最近点\n    * @details 在应用变换矩阵（可选）后,计算椭圆弧在XY方向上离给定点最近的点（投影或端点）\n    * \n    * @param XPoint3dR closePoint\n    * @param double & closeParam\n    * @param double & distanceXY\n    * @param XPoint3dCR spacePoint\n    * @param XMatrix4dCP worldToLocal\n    * @param bool extend0\n    * @param bool extend1\n    * @return bool\n    *\n    * @author SZEWEC\n    * @since 2022/04/22\n    */\n    bool ClosestPointBoundedXY\n    (\n    XPoint3dR   closePoint,\n    double&     closeParam,\n    double&     distXY,\n    XPoint3dCR  spacePoint,\n    XMatrix4dCP worldToLocal,\n    bool extend0,\n    bool extend1\n    ) const;\n\n\t/**\n\t* @brief 获取椭圆弧的起始与终止角度\n\t*\n\t* @param double & startAngle 起始角度\n\t* @param double & endAngle 终止角度\n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/30\n\t*/\n\tvoid GetLimits\n\t(\n\t\tdouble &startAngle,\n\t\tdouble &endAngle\n\t) const;\n\n\t/**\n\t* @brief 给定0°和90°的向量创建椭圆弧\n\t*\n\t* @param XPoint3dCR center\t\t\t\t\t中心点\n\t* @param XVec3dCR vector0\t\t\t\t\t0°向量（通常为沿着主轴的方向）\n\t* @param XVec3dCR vector90\t\t\t\t\t90°向量（通常为沿着短轴的方向）\n\t* @param double theta0\t\t\t\t\t\t起始点对应的角度\n\t* @param double sweep\t\t\t\t\t\t扫掠角度\n\t* @return ATEC_NAMESPACE_NAME::XEllipse3d\t椭圆弧\n\t*\n\t* @author SZEWEC\n\t* @since 2022/06/20\n\t*/\n\tstatic XEllipse3d FromVectors\n\t(\n\t\tXPoint3dCR center,\n\t\tXVec3dCR vector0,\n\t\tXVec3dCR vector90,\n\t\tdouble theta0,\n\t\tdouble sweep\n\t);\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XPoint3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n /**\n * @brief 3D绌洪棿鐐圭被\n * @author SZEWC\n * @since 2022/04/13\n*/\nstruct ATGEOSET_EXPORT XPoint3d\n{\n\n\tdouble x;\n\n\tdouble y;\n\n\tdouble z;\n\n\tstatic XPoint3d From(double x, double y, double z = 0.0);\n\n\tstatic XPoint3d From(XPoint2dCR xy);\n\n\tstatic XPoint3d FromZero();\n\n\tstatic XPoint3d FromOne();\n\n\tstatic XPoint3d FromXYZ(double x, double y, double z);\n\n\tvoid Swap(XPoint3dR other);\n\n\tdouble DotDifference(XPoint3dCR origin, XVec3dCR vector) const;\n\n\tvoid Zero();\n\n\tvoid Init(XPoint2dCR source);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double ay);\n\n\tvoid SetComponent(double a, int index);\n\n\tdouble GetComponent(int index) const;\n\n\tvoid Interpolate(XPoint3dCR pnt0, double fractionParameter, XPoint3dCR point1);\n\n\tdouble Distance(XPoint3dCR point2) const;\n\n\tdouble DistanceXY(XPoint3dCR point2) const;\n\n\tbool DistanceXY(XPoint3dCR otherPoint, XMatrix4dCP matrix, double &distance) const;\n\n\tbool IsEqual(XPoint3dCR point2) const;\n\n\tbool IsEqual(XPoint3dCR point2, double tolerance) const;\n\n\tbool IsDisconnect() const;\n\n\tvoid InitDisconnect();\n\n\tvoid Init(XVec3dCR vector);\n\n\tvoid Subtract(XPoint3dCR base, XVec3dCR vector);\n\n\tvoid Add(XVec3dCR vector);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2, XVec3dCR point3, double scale3);\n\n\tvoid CrossProduct(XPoint3dCR point1, XPoint3dCR point2);\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble AngleTo(XPoint3dCR point2) const;\n\n\tvoid RotateXY(XPoint3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tdouble MagnitudeXY() const;\n\n\tvoid Scale(XPoint3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XPoint3dCR vector);\n\n\tvoid Negate();\n\n\tdouble Normalize(XPoint3dCR vector);\n\n\tdouble Normalize();\n\n\tvoid Subtract(XPoint3dCR point2);\n\n\tvoid DifferenceOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2, XPoint3dCR point3, double scale3);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2, XPoint3dCR point3, double a3);\n\n\tvoid Add(XPoint3dCR vector);\n\n\tvoid SumOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, XPoint3dCR point);\n\n\tstatic XPoint3d FromInterpolate(XPoint3dCR pntA, double fraction, XPoint3dCR pntB);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector, double scaleFactor);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1, XPoint3dCR point2, double scaleFactor2);\n\n\tstatic XPoint3d FromScale(XPoint3d point, double scale);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, XVec3dCR vector);\n\n\tbool AlmostEqual(XPoint3d const & dataB) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB) const;\n\n\tbool AlmostEqual(XPoint3d const & dataB, double abstol) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB, double abstol) const;\n\n\tstatic bool AlmostEqual(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tstatic bool AlmostEqualXY(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tdouble DistanceSquared(XPoint3dCR point2) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file CreateEntityExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};\n code of file CurveSet.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 线串类\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct CurveSet : RefCountedBase, xvector<IBasicCurvePtr>\n{\n\n\tenum BoundaryType\n\t{\n\n\t\tBOUNDARY_TYPE_None = 0,\n\n\t\tBOUNDARY_TYPE_Open = 1,\n\n\t\tBOUNDARY_TYPE_Outer = 2,\n\n\t\tBOUNDARY_TYPE_Inner = 3,\n\n\t\tBOUNDARY_TYPE_ParityRegion = 4,\n\n\t\tBOUNDARY_TYPE_UnionRegion = 5,\n\t};\n\n\tenum InOutClassification\n\t{\n\t\tINOUT_Unknown = 0,\n\t\tINOUT_In = 1,\n\t\tINOUT_Out = 2,\n\t\tINOUT_On = 3\n\t};\n\nprotected:\n\tBoundaryType    m_boundaryType;\n\npublic:\n\t/**\n\t* @brief 设定边界\n\t* @details 设定曲线的边界类型\n\t* \n\t* @param BoundaryType BoundaryType\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void SetBoundaryType(BoundaryType BoundaryType);\n\n\t/**\n\t* @brief 获取叶节点\n\t* @details 通过只计算叶节点的索引深度搜索以获取目标叶节点\n\t* \n\t* @param size_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr FindIndexedLeaf(size_t index) const;\n\n\t/**\n\t* @brief 获取索引值\n\t* @details 深度搜索以获取给定叶节点的索引值\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @param size_t & index\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool LeafToIndex(IBasicCurveCP primitive, size_t &index) const;\n\n\t/**\n\t* @brief 获取叶节点个数\n\t* @details 获取曲线的叶节点个数\n\t* \n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesBelow() const;\n\n\texplicit CurveSet(BoundaryType boundaryType) { m_boundaryType = boundaryType; }\n\n\t/**\n\t* @brief 是否单元素曲线\n\t* @details 查询曲线是否只有一个基本元素\n\t* \n\t* @return IBasicCurve\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurve::BasicCurveType HasSingleBasicCurve() const;\n\n\t/**\n\t* @brief 获取边界类型\n\t* @details 获取曲线的边界类型\n\t* \n\t* @return BoundaryType\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT BoundaryType GetBoundaryType() const;\n\n\t/**\n\t* @brief 查询是否开\n\t* @details 查询是否开路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsOpenPath() const;\n\n\t/**\n\t* @brief 查询是否闭\n\t* @details 查询是否闭路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsClosedPath() const;\n\n\t/**\n\t* @brief 查询实际开闭\n\t* @details 查询是否名义上是开路径但起点和终点连接\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsPhysicallyClosedPath() const;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个带有给定边界类型没有成员的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个具有单个基本元素和给定边界类型的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @param IBasicCurvePtr primitive\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType, IBasicCurvePtr primitive);\n\n\t/**\n\t* @brief 拷贝\n\t* @details 返回一个深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr Clone() const;\n\n\t/**\n\t* @brief 倒角拷贝\n\t* @details 返回一个深度拷贝,在连续曲线之间插入圆角\n\t* \n\t* @param double radius\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithFillets(double radius) const;\n\n\t/**\n\t* @brief 闭合拷贝\n\t* @details 返回一个深度拷贝,闭合终端点的间隙\n\t* \n\t* @param CurveGapOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithGapsClosed(CurveGapOptionsCR options) const;\n\n\t/**\n\t* @brief 添加元素\n\t* @details 递归遍历source, 将所有叶节点添加到this, 返回添加的数量\n\t* \n\t* @param CurveSetCR source\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t AddPrimitives(CurveSetCR source);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 添加单个基本曲线\n\t* \n\t* @param IBasicCurvePtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(IBasicCurvePtr child);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 将chile的所有元素作为曲线成员添加\n\t* \n\t* @param CurveSetPtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(CurveSetPtr child);\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过XY方向的偏移后的深度拷贝\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneOffsetCurvesXY(CurveOffsetOptionsCR options);\n\n\t/**\n\t* @brief 获取叶节点数量\n\t* @details 计算指定类型的叶节点数量\n\t* \n\t* @param IBasicCurve::BasicCurveType targetType\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesOfType(IBasicCurve::BasicCurveType targetType) const;\n\n\t/**\n\t* @brief 用区域分割曲线\n\t* @details 用指定区域分割曲线,分别返回区域内、外和区域上的曲线\n\t* \n\t* @param CurveSetCR region\n\t* @param CurveSetP insideCollector\n\t* @param CurveSetP outsideCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByRegion(CurveSetCR region, CurveSetP insideCollector, CurveSetP outsideCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 用平面分割曲线\n\t* @details 用指定平面分割曲线,分别返回平面上方、下方和平面内的曲线\n\t* \n\t* @param XPlane3dCR plane\n\t* @param CurveSetP belowCollector\n\t* @param CurveSetP aboveCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByPlane(XPlane3dCR plane, CurveSetP belowCollector, CurveSetP aboveCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 拆分拷贝\n\t* @details 返回一个深度拷贝,但所有的多线段被拆分成单条线段\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithExplodedLinestrings() const;\n\n\t/**\n\t* @brief 获取质心\n\t* @details 返回包含曲线的质心(不考虑孤立点)\n\t* \n\t* @param double & length\n\t* @param XPoint3dR centroid\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  WireCentroid(double &length, XPoint3dR centroid) const;\n\n\t/**\n\t* @brief 获取质心、法向量和面积\n\t* @details 返回质心、法向量和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param XVec3dR normal\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CentroidNormalArea(XPoint3dR centroid, XVec3dR normal, double &area) const;\n\n\t/**\n\t* @brief 获取质心和面积\n\t* @details 返回XY平面方向上的质心和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  CentroidAreaXY(XPoint3dR centroid, double &area) const;\n\n\t/**\n\t* @brief 投影范围\n\t* @details 当投影到射线的时候,返回射线参数的范围\n\t* \n\t* @param XRay3dCR ray\n\t* @return XRange1d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT XRange1d ProjectedParameterRange(XRay3dCR ray) const;\n\n    /**\n    * @brief 局部坐标拷贝\n    * @details 返回曲线的深度复制并转换为与曲线相关联的局部坐标系统。\n    * \n    * @param LocalCoordinateSelect frameType\n    * @param TransformR localToWorld\n    * @param TransformR worldToLocal\n    * @param XRange3dR localRange\n    * @return CurveSetPtr\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT CurveSetPtr CloneInLocalCoordinates\n    (\n    LocalCoordinateSelect frameType,\n    TransformR localToWorld,\n    TransformR worldToLocal,\n    XRange3dR localRange\n    ) const;\n\n\t/**\n    * @brief 获取有坐标系的元素\n    * @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame) const;\n\n\t/**\n\t* @brief 获取有坐标系的元素\n\t* @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @param int searchPreference\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame, int srchPref) const;\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param xvector<XPoint3d> const & points\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(xvector<XPoint3d> const&points,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint3dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint3dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建多边形\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint2dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint2dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建矩形\n\t* @details 根据 XY 坐标创建矩形\n\t* \n\t* @param double x0\n\t* @param double y0\n\t* @param double x1\n\t* @param double y1\n\t* @param double z\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateRectangle(double x0, double y0, double x1, double y1, double z,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由给定线段创建边界类型为 BOUNDARY_TYPE_None 的曲线\n\t* \n\t* @param xvector<XSegment3d> const & segments\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(xvector<XSegment3d> const &segs);\n\n\t/**\n\t* @brief 创建圆盘\n\t* @details 为一个完整的椭圆(圆)盘创建一个曲线向量结构\n\t* \n\t* @param XEllipse3dCR arc\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateDisk(XEllipse3dCR arc, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer, bool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个仅有单一元素的曲线结构\n\t* \n\t* @param IBasicCurvePtr child\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(IBasicCurvePtr child, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open);\n\n\t/**\n\t* @brief B样条拷贝\n\t* @details 返回一个深度拷贝,作为B样条曲线\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneAsBsplines() const;\n\n\t/**\n\t* @brief 添加边缘点\n\t* @details 为所有的子节点添加边缘点\n\t* \n\t* @param xvector <XPoint3d> & points\n\t* @param IFacetOptionsR options\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AddStrokePoints(xvector <XPoint3d> &points, IFacetOptionsR options) const;\n\n    /**\n\t* @brief 添加面点\n\t* @details 沿着曲线计算指定距离的点\n\t* \n\t* @param xvector<double> const & distances\n\t* @param xvector<CurveDescInfo> & locations\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool AddSpacedPoints(xvector<double> const &distances, xvector<CurveDescInfo> &locations) const;\n\n\t/**\n\t* @brief 添加边缘\n\t* @details 在结构中添加所有边缘\n\t* \n\t* @param xvector <xvector<xvector<XPoint3d>>> & regionsPoints\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CollectLinearGeometry(xvector <xvector<xvector<XPoint3d>> > &regionsPoints) const;\n\n\t/**\n\t* @brief 获取B样条曲线\n\t* @details 将一个表示开放或闭合路径作为单个B样条曲线\n\t* \n\t* @return ATBsplineCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetBsplineCurve() const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n    /**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索最接近曲线的点。如果曲线是一个区域类型,同时要在该区域的内部寻找投影\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XPoint3dR curveOrRegionPoint\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification ClosestCurveOrRegionPoint(XPoint3dCR spacePoint, XPoint3dR curveOrRegionPoint) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点和终点\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点终点和他们的正切值\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @param XVec3dR unitTangentA\n\t* @param XVec3dR unitTangentB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\t/**\n\t* @brief 获取起点\n\t* @details 返回曲线的起点\n\t* \n\t* @param XPoint3dR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线总长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length() const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线经过变换后的总长度\n\t* \n\t* @param XRotMatrixCP worldToLocal\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length(XRotMatrixCP worldToLocal) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线的xyz范围\n\t* \n\t* @param XRange3dR range\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线经过变换后的范围\n\t* \n\t* @param XRange3dR range\n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\t/**\n\t* @brief 查询索引\n\t* @details 返回指定元素的索引\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t FindIndexOfPrimitive(IBasicCurveCP primitive) const;\n\n\t/**\n\t* @brief 复制曲线指定范围的曲线\n\t* @details 复制曲线指定索引和比例参数范围内的部分\n\t* \n\t* @param int index0\n\t* @param double fraction0\n\t* @param int index1\n\t* @param double fraction1\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n    ATGEOSET_EXPORT CurveSetPtr CloneBetweenCyclicIndexedFractions(int index0, double fraction0, int index1, double fraction1) const;\n\n\t/**\n\t* @brief 反转拷贝\n\t* @details 返回一个所有元素都被反转的深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneReversed() const;\n\n\t/**\n\t* @brief 查询是否包含非线性元素\n\t* @details 如果曲线有一个不非线性元素,则返回true。\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ContainsNonLinearPrimitive() const;\n\n\t/**\n\t* @brief 计算交点\n\t* @details 计算曲线与给定平面的交点\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 平面选中\n\t* @details 计算封闭曲线与平面的交叉点,并以奇偶性规则为设为起始对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param double tolerance\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr PlaneSection(XPlane3dCR plane, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 空间点位置情况\n\t* @details 当以XY平面视角看,测试给定点在曲线内、曲线上还是曲线外\n\t* \n\t* @param XPoint3dCR xyz\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification PointInOnOutXY(XPoint3dCR xyz) const;\n\n\t/**\n\t* @brief 射线击中情况\n\t* @details 测试射线击中曲线在区域内、区域上还是区域外\n\t* \n\t* @param XRay3dCR ray\n\t* @param SolidDescInfoR hitDetail\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification RayPierceInOnOut\n\t(\n\t\tXRay3dCR ray,\n\t\tSolidDescInfoR hitDetail\n\t) const;\n\n\t/**\n\t* @brief 原地变换\n\t* @details 应用给定变换并修改曲线\n\t* \n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\t/**\n\t* @brief 原地反转\n\t* @details 将所有元素进行反转\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串内的单个点被消除,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串相邻的空间点被消除（可选）,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @param bool doSimplifyLinestrings\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives(bool doSimplifyLinestrings);\n\n\t/**\n\t* @brief 原地修改以简化线串\n\t* @details 消除线串相邻的空间点\n\t* \n\t* @param double distanceTol\n\t* @param bool eliminateOverdraw\n\t* @param bool wrap\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void SimplifyLinestrings(double distTol, bool eliminateOverdraw, bool wrap);\n\n\t/**\n\t* @brief 重排元素\n\t* @details 将曲线元素重新排序以缩小元素首尾相连的间隙\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT double ReorderForSmallGaps();\n\n\t/**\n\t* @brief 链接元素\n\t* @details 将曲线的元素首尾相连\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AssembleChains();\n\n\t/**\n\t* @brief 区域相并\n\t* @details 返回给定两个区域的并\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaUnion(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相减\n\t* @details 返回给定两个区域的减\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaDifference(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相交\n\t* @details 返回给定两个区域的交\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaIntersection(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 循环索引\n\t* @details 返回给定索引值关于集合大小的模\n\t* \n\t* @param int index\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT size_t CyclicIndex(int index) const;\n\n\t/**\n\t* @brief 循环获取值\n\t* @details 根据给定索引的循环索引获取元素\n\t* \n\t* @param ptrdiff_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr GetCyclic(ptrdiff_t index) const;\n\n    /**\n    * @brief 获取索引\n    * @details 返回给定曲线元素的详细细节所对应的元素索引\n    * \n    * @param CurveDescInfo const & location\n    * @return size_t\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT size_t CurveDescInfoIndex(CurveDescInfo const& location) const;\n\n\t/**\n\t* @brief 与平面相交\n\t* @details 计算封闭曲线与平面的交叉点,返回以奇偶性规则构造的起止点对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool AppendClosedCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过给定偏移后的深度拷贝.\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AreaOffset(CurveOffsetOptionsCR options) const;\n\n\t/**\n\t* @brief 返回从index0,fraction0到index1,fraction1的曲线段\n\t* \n\t* @param int index0 \n\t* @param double fraction0 \n\t* @param int index1 \n\t* @param double fraction1 \n\t* @param bool allowExtrapolation \n\t* @return ATGEOSET_EXPORT CurveSetPtr \n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/17\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneBetweenDirectedFractions(int index0, double fraction0, int index1, double fraction1, bool allowExtrapolation) const;\n\n\t/**\n\t* @brief 返回输入的曲线的布尔奇运算结果（区域）\n\t*\n\t* @param CurveSetCR regionA\t\t\t\t\t左操作数\n\t* @param CurveSetCR regionB\t\t\t\t\t右操作数\n\t* @param BasicCurvePtrPairVector * newToOld\t（可选）包含新旧曲线的数组指针\n\t* @return ATGEOSET_EXPORT CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/07/22\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaParity(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n};\n\nstruct CurveCurve\n{\nprivate: CurveCurve();\npublic:\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tCurveSetR curveA,\n\t\tCurveSetR curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB,\n\t\tXMatrix4dCP    pWorldToLocal,\n\t\tbool         extend = false\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveR curveA,\n\t\tCurveSetR     curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tCurveSetCR chainA,\n\t\tCurveSetCR chainB\n\t);\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            double &fractionA,\n            XPoint3dR pntA,\n            double &fractionB,\n            XPoint3dR pntB\n            );\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            CurveDescInfoR detailA,\n            CurveDescInfoR detailB\n            );\n};\n\nstruct PathLocationDetail\n{\nprivate:\n\tCurveDescInfo m_curveDetail;\n\tint32_t m_pathIndex;\n\tdouble m_pathDistance;\npublic:\n\n\tATGEOSET_EXPORT PathLocationDetail();\n\n\tATGEOSET_EXPORT PathLocationDetail(PathLocationDetail const &other);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, int pathIndex = -1, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, size_t pathIndex, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(double distance);\n\n\tATGEOSET_EXPORT XPoint3d Point() const;\n\n\tATGEOSET_EXPORT CurveDescInfo GetCurveDescInfo() const;\n\n    ATGEOSET_EXPORT double DistanceFromPathStart() const;\n};\n\nstruct CurveSetWithDistanceIndex : RefCountedBase\n{\nprivate:\n\n\tstruct PathEntry : PathLocationDetail\n\t{\n\t\tdouble             m_projectedDistance;\n\t\tXRange3d           m_range;\n\t\tPathEntry(PathLocationDetail const &pathDetail, double projectedDist, XRange3dCR range)\n\t\t\t: PathLocationDetail(pathDetail),\n\t\t\tm_projectedDistance(projectedDist),\n\t\t\tm_range(range)\n\t\t{\n\t\t}\n\t\tPathEntry(double distance) : PathLocationDetail(distance), m_projectedDistance(distance) {}\n\n\t\tdouble GetDistance(bool projected) const;\n\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistanceXY(PathEntry const &dataA, PathEntry const &dataB);\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistance(PathEntry const &dataA, PathEntry const &dataB);\n\t};\n\n\tCurveSetPtr m_curveVector;\n\txvector<PathEntry> m_locations;\n\tCurveSetPtr m_savedPrimitives;\n\n\tXRotMatrix m_worldToViewRotMatrix;\n\tXRotMatrix m_viewToWorldRotMatrix;\n\tXRotMatrix m_flattenToView;\n\tXMatrix4d m_worldToView;\n\n\texplicit CurveSetWithDistanceIndex(XRotMatrix worldToView);\n\n\tCurveSetWithDistanceIndex();\n\npublic:\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create(XRotMatrix worldToView);\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create();\n\n\tATGEOSET_EXPORT void SetPath(CurveSetPtr &path);\n\n\tATGEOSET_EXPORT bool SearchByDistanceFromPathStart\n\t(\n\t\tdouble targetDist,\n\t\tPathLocationDetail &detail\n\t) const;\n\n    ATGEOSET_EXPORT PathLocationDetail SearchClosestPointBounded\n    (\n    XPoint3dCR spacePoint,\n    bool computeDistAlong\n    ) const;\n};\n\nEND_ATEC_NAMESPACE\n\n", "output": "\nCurveSetPtr CreateEntityExamples::GetCircle()\n{\n    // 圆的数据结构\n    XPoint3d center = XPoint3d::FromXYZ(0, 0, 0);                       // 点 \n    XEllipse3d ellips = XEllipse3d::FromCenterRadiusXY(center, 10000); // 椭圆\n    IBasicCurvePtr pBaisc = IBasicCurve::CreateArc(ellips);            // 基本曲线\n    CurveSetPtr pCv = CurveSet::Create(CurveSet::BOUNDARY_TYPE_Outer); // 曲线集合\n    pCv->Add(pBaisc);\n\n    return pCv;\n}\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};. You need to implement the function TransformCircle in the interface. Here are some apis that you can use and remember:\n code of file XPoint3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n /**\n * @brief 3D绌洪棿鐐圭被\n * @author SZEWC\n * @since 2022/04/13\n*/\nstruct ATGEOSET_EXPORT XPoint3d\n{\n\n\tdouble x;\n\n\tdouble y;\n\n\tdouble z;\n\n\tstatic XPoint3d From(double x, double y, double z = 0.0);\n\n\tstatic XPoint3d From(XPoint2dCR xy);\n\n\tstatic XPoint3d FromZero();\n\n\tstatic XPoint3d FromOne();\n\n\tstatic XPoint3d FromXYZ(double x, double y, double z);\n\n\tvoid Swap(XPoint3dR other);\n\n\tdouble DotDifference(XPoint3dCR origin, XVec3dCR vector) const;\n\n\tvoid Zero();\n\n\tvoid Init(XPoint2dCR source);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double ay);\n\n\tvoid SetComponent(double a, int index);\n\n\tdouble GetComponent(int index) const;\n\n\tvoid Interpolate(XPoint3dCR pnt0, double fractionParameter, XPoint3dCR point1);\n\n\tdouble Distance(XPoint3dCR point2) const;\n\n\tdouble DistanceXY(XPoint3dCR point2) const;\n\n\tbool DistanceXY(XPoint3dCR otherPoint, XMatrix4dCP matrix, double &distance) const;\n\n\tbool IsEqual(XPoint3dCR point2) const;\n\n\tbool IsEqual(XPoint3dCR point2, double tolerance) const;\n\n\tbool IsDisconnect() const;\n\n\tvoid InitDisconnect();\n\n\tvoid Init(XVec3dCR vector);\n\n\tvoid Subtract(XPoint3dCR base, XVec3dCR vector);\n\n\tvoid Add(XVec3dCR vector);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2, XVec3dCR point3, double scale3);\n\n\tvoid CrossProduct(XPoint3dCR point1, XPoint3dCR point2);\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble AngleTo(XPoint3dCR point2) const;\n\n\tvoid RotateXY(XPoint3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tdouble MagnitudeXY() const;\n\n\tvoid Scale(XPoint3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XPoint3dCR vector);\n\n\tvoid Negate();\n\n\tdouble Normalize(XPoint3dCR vector);\n\n\tdouble Normalize();\n\n\tvoid Subtract(XPoint3dCR point2);\n\n\tvoid DifferenceOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2, XPoint3dCR point3, double scale3);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2, XPoint3dCR point3, double a3);\n\n\tvoid Add(XPoint3dCR vector);\n\n\tvoid SumOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, XPoint3dCR point);\n\n\tstatic XPoint3d FromInterpolate(XPoint3dCR pntA, double fraction, XPoint3dCR pntB);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector, double scaleFactor);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1, XPoint3dCR point2, double scaleFactor2);\n\n\tstatic XPoint3d FromScale(XPoint3d point, double scale);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, XVec3dCR vector);\n\n\tbool AlmostEqual(XPoint3d const & dataB) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB) const;\n\n\tbool AlmostEqual(XPoint3d const & dataB, double abstol) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB, double abstol) const;\n\n\tstatic bool AlmostEqual(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tstatic bool AlmostEqualXY(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tdouble DistanceSquared(XPoint3dCR point2) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XRotMatrix.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 大小为3*3的旋转矩阵\n* @author SZEWC\n* @since 2022/04/28\n*/\nstruct ATGEOSET_EXPORT XRotMatrix\n{\n\n\tdouble form3d[3][3];\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个单位矩阵\n\t* \n\t* @return XRotMatrix\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tstatic XRotMatrix FromIdentity();\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 将矩阵初始化为单位矩阵\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid InitIdentity();\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个均匀缩放指定倍数的矩阵\n\t* \n\t* @param double scale\n\t* @return XRotMatrix\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tstatic XRotMatrix FromScale(double scale);\n\n\t/**\n    * @brief 初始化数据\n    * @details 将矩阵初始化为均匀缩放指定倍数的矩阵\n\t* \n\t* @param double scale\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid InitFromScale(double scale);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个在x、y和z方向上指定缩放倍数的缩放矩阵\n\t* \n\t* @param double xscale\n\t* @param double yscale\n\t* @param double zscale\n\t* @return XRotMatrix\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tstatic XRotMatrix FromScaleFactors\n\t(\n\t\tdouble          xscale,\n\t\tdouble          yscale,\n\t\tdouble          zscale\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 将矩阵初始化为在x、y和z方向上指定缩放倍数的缩放矩阵\n\t* \n\t* @param double xscale\n\t* @param double yscale\n\t* @param double zscale\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid InitFromScaleFactors\n\t(\n\t\tdouble          xscale,\n\t\tdouble          yscale,\n\t\tdouble          zscale\n\t);\n\n\t/**\n\t* @brief 按列单位化\n\t* @details 计算输入矩阵按列单位化的结果,同时返回原始行向量的模\n\t* \n\t* @param XRotMatrixCR inMatrix\n\t* @param XVec3dR scaleVector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid NormalizeColumnsOf\n\t(\n\t\tXRotMatrixCR     inMatrix,\n\t\tXVec3dR         scaleVector\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个由给定3个向量复制到列的矩阵\n\t* \n\t* @param XVec3dCR vectorU\n\t* @param XVec3dCR vectorV\n\t* @param XVec3dCR vectorW\n\t* @return XRotMatrix\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tstatic XRotMatrix FromColumnVectors\n\t(\n\t\tXVec3dCR        vectorU,\n\t\tXVec3dCR        vectorV,\n\t\tXVec3dCR        vectorW\n\t);\n\n\t/**\n    * @brief 初始化数据\n    * @details 将矩阵的列初始化为给定3个向量\n\t* \n\t* @param XVec3dCR vectorU\n\t* @param XVec3dCR vectorV\n\t* @param XVec3dCR vectorW\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid InitFromColumnVectors\n\t(\n\t\tXVec3dCR        vectorU,\n\t\tXVec3dCR        vectorV,\n\t\tXVec3dCR        vectorW\n\t);\n\n\t/**\n    * @brief 创建函数\n    * @details 创建一个由给定3个向量复制到行的矩阵\n\t* \n\t* @param XVec3dCR vectorU\n\t* @param XVec3dCR vectorV\n\t* @param XVec3dCR vectorW\n\t* @return XRotMatrix\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tstatic XRotMatrix FromRowVectors\n\t(\n\t\tXVec3dCR        vectorU,\n\t\tXVec3dCR        vectorV,\n\t\tXVec3dCR        vectorW\n\t);\n\n\t/**\n\t* @brief 初始化数据\n    * @details 将矩阵的行初始化为给定3个向量\n\t* \n\t* @param XVec3dCR vectorU\n\t* @param XVec3dCR vectorV\n\t* @param XVec3dCR vectorW\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid InitFromRowVectors\n\t(\n\t\tXVec3dCR        vectorU,\n\t\tXVec3dCR        vectorV,\n\t\tXVec3dCR        vectorW\n\t);\n\n\t/**\n    * @brief 创建函数\n    * @details 创建一个旋转向量到指定角度的矩阵\n\t* \n\t* @param XVec3dCR axis\n\t* @param double radians\n\t* @return XRotMatrix\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tstatic XRotMatrix FromVectorAndRotationAngle(XVec3dCR axis, double radians);\n\n\t/**\n    * @brief 初始化数据\n    * @details 将矩阵初始化为旋转向量到指定角度的矩阵\n\t* \n\t* @param XVec3dCR axis\n\t* @param double radians\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid InitFromVectorAndRotationAngle\n\t(\n\t\tXVec3dCR        axis,\n\t\tdouble          radians\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个将x, y或z轴(axis = 0, 1或2)旋转指定角度的矩阵\n\t* \n\t* @param int axis\n\t* @param double radians\n\t* @return XRotMatrix\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tstatic XRotMatrix FromAxisAndRotationAngle\n\t(\n\t\tint             axis,\n\t\tdouble          radians\n\t);\n\n\t/**\n    * @brief 初始化数据\n    * @details 将矩阵初始化为将x, y或z轴(axis = 0, 1或2)旋转指定角度的矩阵\n\t* \n\t* @param int axis\n\t* @param double radians\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid InitFromAxisAndRotationAngle\n\t(\n\t\tint             axis,\n\t\tdouble          radians\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 将矩阵初始化为将起始向量以最小的角度旋转至终止向量的方向\n\t* \n\t* @param XVec3dCR startVector\n\t* @param XVec3dCR endVector\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tbool InitRotationFromVectorToVector\n\t(\n\t\tXVec3dCR startVector,\n\t\tXVec3dCR endVector\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个将向量旋转90度的矩阵\n\t* \n\t* @param XVec3dCR axis\n\t* @return XRotMatrix\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tstatic XRotMatrix FromRotate90(XVec3dCR axis);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个将指定轴(axis = 0,1 或 2)旋转到给定向量方向的矩阵\n\t* \n\t* @param XVec3dCR dir\n\t* @param int axis\n\t* @param bool normalize\n\t* @return XRotMatrix\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tstatic XRotMatrix From1Vector\n\t(\n\t\tXVec3dCR        dir,\n\t\tint             axis,\n\t\tbool            normalize\n\t);\n\n\t/**\n    * @brief 初始化数据\n    * @details 将矩阵初始化为将指定轴(axis = 0,1 或 2)旋转到给定向量方向\n\t* \n\t* @param XVec3dCR dir\n\t* @param int axis\n\t* @param bool normalize\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tbool InitFrom1Vector\n\t(\n\t\tXVec3dCR        dir,\n\t\tint             axis,\n\t\tbool            normalize\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个前两列为给定向量,第三列为它们的叉乘积的矩阵\n\t* \n\t* @param XVec3dCR xVector\n\t* @param XVec3dCR yVector\n\t* @return XRotMatrix\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tstatic XRotMatrix From2Vectors\n\t(\n\t\tXVec3dCR        xVector,\n\t\tXVec3dCR        yVector\n\t);\n\n\t/**\n    * @brief 初始化数据\n    * @details 将矩阵初始化为前两列为给定向量,第三列为它们的叉乘积的矩阵\n\t* \n\t* @param XVec3dCR xVector\n\t* @param XVec3dCR yVector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid InitFrom2Vectors\n\t(\n\t\tXVec3dCR        xVector,\n\t\tXVec3dCR        yVector\n\t);\n\n\t/**\n\t* @brief 按列正交单位化\n\t* @details 调整列的方向和模使得列之间正交且模为1. primaryAxis 对应的列保持原有的方向,\n    *         econdaryAxis对应的列单位化且要与primaryAxis列正交,并保留在原始的\n    *         primaryAxis 和 econdaryAxis 定义的平面上\n\t* \n\t* @param XRotMatrixCR inMatrix\n\t* @param int primaryAxis\n\t* @param int secondaryAxis\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tbool SquareAndNormalizeColumns\n\t(\n\t\tXRotMatrixCR     inMatrix,\n\t\tint             primaryAxis,\n\t\tint             secAxis\n\t);\n\n\tbool SquareAndNormalizeColumns\n\t(\n\t\tXRotMatrixCR     inMatrix,\n\t\tint             primaryAxis,\n\t\tint             secAxis,\n\t\tint             preferredOrientation\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 从变换矩阵中创建矩阵\n\t* \n\t* @param TransformCR transform\n\t* @return XRotMatrix\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tstatic XRotMatrix From(TransformCR transform);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由变换矩阵创建矩阵\n\t* \n\t* @param TransformCR transform\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid InitFrom(TransformCR transform);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 将矩阵初始化为两个旋转矩阵的积\n\t* \n\t* @param XRotMatrixCR rotMatrixA\n\t* @param XRotMatrixCR rotMatrixB\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid InitProduct\n\t(\n\t\tXRotMatrixCR     rotMatrixA,\n\t\tXRotMatrixCR     rotMatrixB\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 将矩阵初始化为三个旋转矩阵的积\n\t* \n\t* @param XRotMatrixCR rotMatrixA\n\t* @param XRotMatrixCR rotMatrixB\n\t* @param XRotMatrixCR rotMatrixC\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid InitProduct\n\t(\n\t\tXRotMatrixCR     rotMatrixA,\n\t\tXRotMatrixCR     rotMatrixB,\n\t\tXRotMatrixCR     rotMatrixC\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 将矩阵初始化为旋转矩阵与变换矩阵的矩阵部分的积\n\t* \n\t* @param XRotMatrixCR rotMatrixA\n\t* @param TransformCR transformB\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid InitProduct\n\t(\n\t\tXRotMatrixCR     rotMatrixA,\n\t\tTransformCR     transformB\n\t);\n\n\t/**\n\t* @brief 逆矩阵\n\t* @details 计算输入矩阵的逆,若不可逆返回false\n\t* \n\t* @param XRotMatrixCR forward\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tbool InverseOf(XRotMatrixCR forward);\n\n\t/**\n\t* @brief 逆\n\t* @details 计算实例的逆并原地修改\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tbool Invert();\n\n\t/**\n\t* @brief 相乘\n\t* @details 计算给定4维点数组的每个点与矩阵相乘\n\t* \n\t* @param XPoint4dP result\n\t* @param XPoint4dCP point\n\t* @param int numPoint\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid Multiply\n\t(\n\t\tXPoint4dP       result,\n\t\tXPoint4dCP      point,\n\t\tint             numPoint\n\t) const;\n\n\t/**\n    * @brief 相乘\n    * @details 计算给定2维点数组的每个点与矩阵相乘\n\t* \n\t* @param XPoint2dP result\n\t* @param XPoint2dCP point\n\t* @param int numPoint\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid Multiply\n\t(\n\t\tXPoint2dP       result,\n\t\tXPoint2dCP      point,\n\t\tint             numPoint\n\t) const;\n\n\t/**\n    * @brief 相乘\n    * @details 计算范围盒与矩阵相乘后的8个顶点的范围盒\n\t* \n\t* @param XRange3dR outRange\n\t* @param XRange3dCR inRange\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid Multiply\n\t(\n\t\tXRange3dR       outRange,\n\t\tXRange3dCR      inRange\n\t) const;\n\n\t/**\n\t* @brief 相乘\n\t* @details 将给定点原地修改为其与矩阵的乘积\n\t* \n\t* @param XPoint3dR point\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid Multiply(XPoint3dR point) const;\n\n\t/**\n\t* @brief 相乘\n\t* @details 返回给定点与矩阵的乘积\n\t* \n\t* @param XPoint3dR result\n\t* @param XPoint3dCR point\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid Multiply\n\t(\n\t\tXPoint3dR       result,\n\t\tXPoint3dCR      point\n\t) const;\n\n\t/**\n\t* @brief 转置相乘\n\t* @details 返回矩阵转置后与给定点的乘积\n\t* \n\t* @param XPoint3dR result\n\t* @param XPoint3dCR point\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid MultiplyTranspose\n\t(\n\t\tXPoint3dR       result,\n\t\tXPoint3dCR      point\n\t) const;\n\n\t/**\n\t* @brief 转置相乘\n\t* @details 将给定点原地修改为其与转置后的矩阵的乘积\n\t* \n\t* @param XPoint3dR point\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid MultiplyTranspose(XPoint3dR point) const;\n\n\t/**\n    * @brief 相乘\n    * @details 给定3维点数组的每个点与矩阵相乘\n\t* \n\t* @param XPoint3dP result\n\t* @param XPoint3dCP point\n\t* @param int numPoint\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid Multiply\n\t(\n\t\tXPoint3dP       result,\n\t\tXPoint3dCP      point,\n\t\tint             numPoint\n\t) const;\n\n\t/**\n    * @brief 相乘\n    * @details 计算给定3维点数组的每个点与转置后矩阵的乘积\n\t* \n\t* @param XPoint3dP result\n\t* @param XPoint3dCP point\n\t* @param int numPoint\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid MultiplyTranspose\n\t(\n\t\tXPoint3dP       result,\n\t\tXPoint3dCP      point,\n\t\tint             numPoint\n\t) const;\n\n\t/**\n\t* @brief 相乘\n    * @details 给定3维点数组的每个点与矩阵相乘\n\t* \n\t* @param xvector<XPoint3d> & outXYZ\n\t* @param xvector<XPoint3d> const & inXYZ\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid Multiply\n\t(\n\t\txvector<XPoint3d> &outXYZ,\n\t\txvector<XPoint3d> const &inXYZ\n\t) const;\n\n\t/**\n    * @brief 相乘\n    * @details 给定3维点数组的每个点与转置后的矩阵相乘\n\t* \n\t* @param xvector<XPoint3d> & outXYZ\n\t* @param xvector<XPoint3d> const & inXYZ\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid MultiplyTranspose\n\t(\n\t\txvector<XPoint3d> &outXYZ,\n\t\txvector<XPoint3d> const &inXYZ\n\t) const;\n\n\t/**\n    * @brief 相乘\n    * @details 给定2维点数组的每个点与矩阵相乘\n\t* \n\t* @param xvector<XPoint2d> & out\n\t* @param xvector<XPoint2d> const & in\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid Multiply\n\t(\n\t\txvector<XPoint2d> &out,\n\t\txvector<XPoint2d> const &in\n\t) const;\n\n\t/**\n    * @brief 相乘\n    * @details 给定4维点数组的每个点与矩阵相乘\n\t* \n\t* @param xvector<XPoint4d> & xyzwOut\n\t* @param xvector<XPoint4d> const & xyzwIn\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid Multiply\n\t(\n\t\txvector<XPoint4d> &xyzwOut,\n\t\txvector<XPoint4d> const &xyzwIn\n\t) const;\n\n\t/**\n\t* @brief 获取列\n\t* @details 将矩阵的3列作为向量返回\n\t* \n\t* @param XVec3dR vectorU\n\t* @param XVec3dR vectorV\n\t* @param XVec3dR vectorW\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid GetColumns\n\t(\n\t\tXVec3dR         vectorU,\n\t\tXVec3dR         vectorV,\n\t\tXVec3dR         vectorW\n\t) const;\n\n\t/**\n\t* @brief 获取列\n\t* @details 将矩阵指定列作为向量返回\n\t* \n\t* @param XVec3dR vector\n\t* @param int col\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid GetColumn\n\t(\n\t\tXVec3dR         vector,\n\t\tint             col\n\t) const;\n\n\t/**\n\t* @brief 修改列\n\t* @details 将矩阵给定列修改为给定向量\n\t* \n\t* @param XVec3dCR vector\n\t* @param int col\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tvoid SetColumn\n\t(\n\t\tXVec3dCR        vector,\n\t\tint             col\n\t);\n\n\t/**\n\t* @brief 是否单位阵\n\t* @details 查询实例是否单位矩阵\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/18\n\t*/\n\tbool IsIdentity() const;\n\n\t/**\n\t* @brief 返回单位化旋转轴与旋转角\n\t*\n\t* @param XVec3dR axis\t单位化的旋转轴\n\t* @return double\t\t旋转角,[0, PI]\n\t*\n\t* @author SZEWEC\n\t* @since 2022/12/01\n\t*/\n\tdouble GetRotationAngleAndVector(XVec3dR axis) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file CreateEntityExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};", "output": "\nCurveSetPtr CreateEntityExamples::TransformCircle(CurveSetPtr crvPtr)\n{\n    if (!crvPtr.IsValid())\n        return nullptr;\n\n    XPoint3d translation = XPoint3d::FromXYZ(0, 0, 10000); // 平移\n    XRotMatrix mat = XRotMatrix::FromScale(1.5);\n    Transform trs = Transform::From(mat, translation);\n\n    CurveSetPtr pCopy = crvPtr->Clone(); // 副本\n    pCopy->TransformInPlace(trs);   // 平移+缩放\n    return pCopy;\n}\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};. You need to implement the function GetCuboidEntity in the interface. Here are some apis that you can use and remember:\n code of file EntityUtl.h: \n\n#pragma once\n\n/**\n* @file EntityUtl.h\n*\n* @author SZEWC\n* @date 2022/04/27\n*/\n\n\n/**\n* @brief 以指定起终点截面的方式拉伸体\n* @details \n* \n* @param ISolidCoreEntityPtr & out \n* @param CurveSetCR startProfile \n* @param CurveSetCR endProfile \n* @param CurveSetCR path \n* @param ATSceneRefR scene \n* @param bool alignParallel \n* @param bool selfRepair \n* @param bool createSheet \n* @param XVec3dCP lockDirection \n* @param double const * twistAngle \n* @param double const * scale \n* @param XPoint3dCP scalePoint \n* @return ATEC \n*\n* @author SZEWEC\n* @since 2022/04/28\n*/\nENTITYUTIL_EXPORT ATEC::ATECStatus atSolid_EntityFromSweep\n(\nATEC::ATDataCore::ISolidCoreEntityPtr& out,\nATEC::CurveSetCR startProfile,\nATEC::CurveSetCR endProfile,\nATEC::CurveSetCR path,\nATEC::ATDataCore::ATSceneRefR scene,\nbool alignParallel,\nbool selfRepair,\nbool createSheet,\nATEC::XVec3dCP lockDirection = NULL,\ndouble const* twistAngle = NULL,\ndouble const* scale = NULL,\nATEC::XPoint3dCP scalePoint = NULL\n);\n\n/**\n* @brief 元件到体\n* @details 将给定元件转换成体\n* \n* @param BODY_TAG * bodyP\n* @param ATEC::TransformP bodyTransformP\n* @param ATEC::ATDataCore::ATObjectDescrP odP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @param UInt32 nodeId\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_elementToBody\n(\nBODY_TAG*       bodyP,          \nATEC::TransformP      bodyTransformP, \nATEC::ATDataCore::ATObjectDescrP odP,            \nATEC::ATDataCore::ATSceneRefP    SceneRef,       \nUInt32          nodeId = 1L     \n);\n\n/**\n* @brief 体到元件\n* @details 将给定体转换成元件\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\n* @param BODY_TAG bodyTag\n* @param bool wireframe\n* @param int uIsoParametrics\n* @param int vIsoParametrics\n* @param unsigned int useSmartIso\n* @param ATEC::ATDataCore::ATObjectP templateP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_bodyToObject\n(\nATEC::ATDataCore::ATObjectDescrH edPP,               \nBODY_TAG        bodyTag,            \nbool            wireframe,          \nint             uIsoParametrics,    \nint             vIsoParametrics,    \nunsigned int    useSmartIso,        \nATEC::ATDataCore::ATObjectP      tempP,          \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 面到元件\n* @details 将给定的面转换成等价的元件\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\n* @param FACE_TAG face\n* @param bool wireframe\n* @param int nIsoparametrics\n* @param ATEC::ATDataCore::ATObjectP templateP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_faceToObject\n(\nATEC::ATDataCore::ATObjectDescrH edPP,               \nFACE_TAG        face,               \nbool            wireframe,          \nint             nIsoparametrics,    \nATEC::ATDataCore::ATObjectP      tempP,          \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 体求减\n* @details 从 b2 中减去 b1\n* \n* @param BODY_TAG b2\n* @param BODY_TAG b1\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_subtract\n(\nBODY_TAG        b2,                \nBODY_TAG        b1                 \n);\n\n/**\n* @brief 面面相交\n* @details 计算两个面的交,结果以线体返回\n* \n* @param BODY_TAG * b\n* @param FACE_TAG f1\n* @param FACE_TAG f2\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_faceFaceIntersect\n(\nBODY_TAG        *b,                \nFACE_TAG        f1,                \nFACE_TAG        f2                 \n);\n\n/**\n* @brief 获取输入实体的面ID\n* \n* @param ATEC::FaceId * faceIdP\n* @param ENTITY_TAG ent\n* @param bool useHighestId\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/27\n*/\nENTITYUTIL_EXPORT int atSolid_idFromEntity\n(\nATEC::FaceId          *faceIdP,\nENTITY_TAG      ent,\nbool            useHighestId\n);\n\n/**\n* @brief 检查体\n* @details 检查输入体的几何、拓扑和尺寸有效性\n* \n* @param BODY_TAG body\n* @param bool checkGeometry\n* @param bool checkTopology\n* @param bool checkSize\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_checkBody\n(\nBODY_TAG        body,\nbool            chkGeometry,\nbool            chkTopology,\nbool            chkSize\n);\n\n/**\n* @brief 创建实体列表\n* @details 创建一个空的实体列表\n* \n* @param TAG_ENTITY_LIST * * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listCreate\n(\nTAG_ENTITY_LIST **lP            \n);\n\n/**\n* @brief 删除实体列表\n* @details 释放给定实体列表分配的内存\n* \n* @param TAG_ENTITY_LIST * * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listDelete\n(\nTAG_ENTITY_LIST **lP            \n);\n\n/**\n* @brief 列表添加元素\n* @details 往实体列表的尾部添加一个元素\n* \n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listAdd\n(\nTAG_ENTITY_LIST *lP,            \nENTITY_TAG      ent             \n);\n\n/**\n* @brief 列表添加元素\n* @details 往实体列表的尾部添加另一个列表的所有元素\n* \n* @param TAG_ENTITY_LIST * lDP\n* @param TAG_ENTITY_LIST * lSP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listAddList\n(\nTAG_ENTITY_LIST *lDP,\nTAG_ENTITY_LIST *lSP\n);\n\n/**\n* @brief 列表移除实体\n* @details 从列表中移除指定的实体\n* \n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listRemove\n(\nTAG_ENTITY_LIST *lP,\nENTITY_TAG      ent\n);\n\n/**\n* @brief 列表计数\n* @details 返回实体列表的元素个数\n* \n* @param int * count\n* @param TAG_ENTITY_LIST * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listCount\n(\nint             *count,         \nTAG_ENTITY_LIST *lP             \n);\n\n/**\n* @brief 列表查询实体\n* @details 在列表中搜索给定的实体并返回中索引,若不存在返回-1\n* \n* @param int * nth\n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listLookup\n(\nint             *nth,           \nTAG_ENTITY_LIST *lP,            \nENTITY_TAG      ent             \n);\n\n/**\n* @brief 查询列表指定位置的元素\n* @details 返回实体列表指定位置的元素\n* \n* @param ENTITY_TAG * entP\n* @param TAG_ENTITY_LIST * lP\n* @param int nth\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listNthEl\n(\nENTITY_TAG      *entP,          \nTAG_ENTITY_LIST *lP,            \nint             nth             \n);\n\n/**\n* @brief 清空列表\n* @details 移除列表中的所有元素\n* \n* @param TAG_ENTITY_LIST * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listEmpty\n(\nTAG_ENTITY_LIST *lP             \n);\n\nENTITYUTIL_EXPORT int atSolid_listCreateNonEntity (NON_ENTITY_LIST** lPP);\nENTITYUTIL_EXPORT int atSolid_listDeleteNonEntity (NON_ENTITY_LIST** lPP);\nENTITYUTIL_EXPORT int atSolid_listAddNonEntity (NON_ENTITY_LIST* lP, void* dataP);\nENTITYUTIL_EXPORT int atSolid_listCountNonEntity (int* countP, NON_ENTITY_LIST* lP);\nENTITYUTIL_EXPORT int atSolid_listNthNonEntity (void** dataPP, NON_ENTITY_LIST* lP, int nth);\n\n/**\n* @brief 偏移面\n* @details 将输入面的集合中所有面偏移指定距离,这些面必须属于同一个体\n* \n* @param TAG_ENTITY_LIST * pFaceList\n* @param double * pOffset\n* @param double tolerance\n* @param bool faceFaceCheck\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_offsetFaces\n(\nTAG_ENTITY_LIST *pFaceList,\ndouble          *pOffset,\ndouble          tolerance,\nbool            faceFaceCheck\n);\n\n/**\n* @brief 偏移线体\n* @details 返回给定线体偏移后的边缘\n* \n* @param TAG_ENTITY_LIST * pOffsetList\n* @param BODY_TAG wireBody\n* @param EDGE_TAG refEdge\n* @param ATEC::XPoint3d * pNormal\n* @param double distance\n* @param double tolerance\n* @param int gapFill\n* @param bool localCheck\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_offsetWire\n(\nTAG_ENTITY_LIST *pOffsetList,\nBODY_TAG        wireBody,\nEDGE_TAG        refEdge,\nATEC::XPoint3d        *pNormal,           \ndouble          distance,\ndouble          tolerance,\nint             gapFill,            \nbool            localCheck\n);\n\n/**\n* @brief 面上最近的点\n* @details 计算给定面上离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * clstPt\n* @param ATEC::XPoint3d * normal\n* @param ATEC::XPoint2d * param\n* @param ATEC::XPoint3d * testPt\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_closestPointToFace\n(\nATEC::XPoint3d        *clstPt,            \nATEC::XPoint3d        *normal,            \nATEC::XPoint2d        *param,             \nATEC::XPoint3d        *testPt,            \nFACE_TAG        face                \n);\n\n/**\n* @brief 边上最近的点\n* @details 计算给定边上离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * clstPt\n* @param double * param\n* @param ATEC::XPoint3d * testPt\n* @param EDGE_TAG edge\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_closestPointToEdge\n(\nATEC::XPoint3d        *clstPt,            \ndouble          *param,             \nATEC::XPoint3d        *testPt,            \nEDGE_TAG        edge               \n);\n\n/**\n* @brief 离点最近的点\n* @details 计算给定点离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * point\n* @param VERTEX_TAG vertex\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_pointFromVertex\n(\nATEC::XPoint3d        *point,             \nVERTEX_TAG      vertex              \n);\n\n/**\n* @brief 获取实体\n* @details 从给定起始点发射射线,返回体上与之相交的所有实体\n* \n* @param TAG_ENTITY_LIST * hits\n* @param double * * params\n* @param ATEC::XPoint3dP origin\n* @param ATEC::XPoint3dP dir\n* @param double radius\n* @param int type\n* @param BODY_TAG b\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getEntities\n(\nTAG_ENTITY_LIST *hits,              \ndouble          **params,           \nATEC::XPoint3dP       origin,             \nATEC::XPoint3dP       dir,                \ndouble          radius,             \nint             type,               \nBODY_TAG        b,                  \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 获取面实体\n* @details 从给定起始点发射射线,返回体上与之相交的第一个面以及相应的交点\n* \n* @param ATEC::XPoint3d * outPointP\n* @param ATEC::XPoint3d * outNormalP\n* @param FACE_TAG * outFaceP\n* @param ATEC::XPoint3d * inPointP\n* @param ATEC::XPoint3d * inNormalP\n* @param BODY_TAG body\n* @param bool backupRayOrigin\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_boresiteToFace\n(\nATEC::XPoint3d        *outPointP,         \nATEC::XPoint3d        *outNormalP,        \nFACE_TAG        *outFaceP,          \nATEC::XPoint3d        *inPointP,          \nATEC::XPoint3d        *inNormalP,         \nBODY_TAG        body,               \nbool            backupRayOrigin,    \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 曲线与面相交\n* @details 将给定部分曲线与给定的面相交,并返回曲线与面之间的交点以及相应的参数\n* \n* @param ATEC::XPoint3dP * pointPP\n* @param ATEC::XPoint2d * * faceUVPP\n* @param double * * curveParamPP\n* @param int * numIntsP\n* @param FACE_TAG face\n* @param CURVE_TAG curve\n* @param double startParam\n* @param double endParam\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_faceIntersectCurve\n(\nATEC::XPoint3dP       *pntPP,\nATEC::XPoint2d        **faceUVPP,\ndouble          **curveParamPP,\nint             *numIntsP,\nFACE_TAG        face,\nCURVE_TAG       curve,\ndouble          startParam,\ndouble          endParam\n);\n\n/**\n* @brief 获取体的包围盒\n* @details 计算给定体的包围盒\n* \n* @param ATEC::XPoint3d * lo\n* @param ATEC::XPoint3d * hi\n* @param BODY_TAG b\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getBodyBox\n(\nATEC::XPoint3d       *lo,             \nATEC::XPoint3d       *hi,             \nBODY_TAG       b                \n);\n\n/**\n* @brief 获取平滑的面列表\n* @details 向面的列表中添加一个面,并添加这个面与列表中的面的平滑连接\n* \n* @param TAG_ENTITY_LIST * listP\n* @param FACE_TAG face\n* @param bool addSmoothFaces\n* @param int allowedFaceTypeMask\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getSmoothFaceList\n(\nTAG_ENTITY_LIST *listP,\nFACE_TAG        face,\nbool            addSmoothFaces,\nint             allowedFaceTypeMask\n);\n\nenum SmoothEdgeType\n    {\n    SMOOTH_TYPE_NONE  = 0,\n    SMOOTH_TYPE_BLEND = 1,\n    SMOOTH_TYPE_TANGENT = 2\n    };\n\n/**\n* @brief 面的所有边\n* @details 返回构成面的所有边\n* \n* @param TAG_ENTITY_LIST * edgeListP\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getEdgeListFromFace\n(\nTAG_ENTITY_LIST *edgeListP,         \nFACE_TAG        face                \n);\n\n/**\n* @brief 线体是否G1连续\n* @details 查询线体是否关于所有点G1连续\n* \n* @param BODY_TAG wire\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_wireIsG1\n(\nBODY_TAG        wire\n);\n\n/**\n* @brief 实体最小距离\n* @details 计算两个实体之间的最小距离\n* \n* @param ATEC::XPoint3dP pPoint1\n* @param ATEC::XPoint3dP pPoint2\n* @param double * pDistance\n* @param ENTITY_TAG entity1\n* @param ENTITY_TAG entity2\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_minimumDistanceBetweenEntities\n(\nATEC::XPoint3dP           pPoint1,\nATEC::XPoint3dP           pPoint2,\ndouble              *pDist,\nENTITY_TAG          entity1,\nENTITY_TAG          entity2\n);\n\n/**\n* @brief 简化体\n* @details 尝试将B样条曲线和曲面简化为分析曲线和曲面\n* \n* @param BODY_TAG * bodyP\n* @param bool local\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_simplifyBody\n(\nBODY_TAG        *bodyP,\nbool            local\n);\n\n/**\n* @brief 开始转换\n* @details 将变换矩阵推入堆栈中\n* \n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_beginCurrTrans (ATEC::ATDataCore::ATSceneRefP SceneRef);\n\n/**\n* @brief 结束转换\n* @details 从堆栈中弹出brSolid_beginCurrTrans推入的变换矩阵\n* \n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_endCurrTrans ();\n\n/**\n* @brief 应用变换\n* @details 对体应用给定变换\n* \n* @param ENTITY_TAG entity\n* @param ATEC::TransformP transformP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_applyTransform\n(\nENTITY_TAG      entity,            \nATEC::TransformP      transformP         \n);\n\n/**\n* @brief 给薄面体加盖\n* @details 通过添加其他面封闭给定的薄面体并转换为体\n* \n* @param TAG_ENTITY_LIST * faces\n* @param BODY_TAG * lamina\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_capSurface\n(\nTAG_ENTITY_LIST *faces,             \nBODY_TAG        *lamina             \n);\n\n/**\n* @brief 逆转体\n* @details 将体中的所有面逆转方向\n* \n* @param BODY_TAG body\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_reverseBody\n(\nBODY_TAG        body               \n);\n\n/**\n* @brief 删除实体\n* @details 删除给定的实体\n* \n* @param ENTITY_TAG e\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_deleteEntity\n(\nENTITY_TAG      e                  \n);\n\n/**\n* @brief 复制体\n* @details 创建给定体的一个复制\n* \n* @param BODY_TAG * copy\n* @param BODY_TAG source\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_copyBody\n(\nBODY_TAG        *copy,\nBODY_TAG        source\n);\n\n/**\n* @brief 删除体\n* @details 释放体所分配的内存\n* \n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_freeBody\n(\nBODY_TAG        body               \n);\n\n/**\n* @brief 释放内存\n* @details 释放列表所分配的内存\n* \n* @param void * v\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_free\n(\nvoid            *v\n);\n\n/**\n* @brief 边缘数据\n* @details 返回边缘的拓扑和几何信息\n* \n* @param VERTEX_TAG * startVertexP\n* @param VERTEX_TAG * endVertexP\n* @param ATEC::XPoint3d * startPointP\n* @param ATEC::XPoint3d * endPointP\n* @param double * startParamP\n* @param double * endParamP\n* @param COEDGE_TAG * coEdgeP\n* @param CURVE_TAG * curveP\n* @param bool * reversedP\n* @param EDGE_TAG edge\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_edgeData\n(\nVERTEX_TAG      *startVertexP,  \nVERTEX_TAG      *endVertexP,    \nATEC::XPoint3d        *startPointP,   \nATEC::XPoint3d        *endPointP,     \ndouble          *startParamP,   \ndouble          *endParamP,     \nCOEDGE_TAG      *coEdgeP,       \nCURVE_TAG       *curveP,        \nbool            *reversedP,     \nEDGE_TAG        edge            \n);\n\n/**\n* @brief 获取所有边\n* @details 返回体的所有边列表\n* \n* @param TAG_ENTITY_LIST * listP\n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getEdgeList\n(\nTAG_ENTITY_LIST *listP,             \nBODY_TAG        body                \n);\n\n/**\n* @brief 获取所有面\n* @details 返回体的所有面列表\n* \n* @param TAG_ENTITY_LIST * listP\n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getFaceList\n(\nTAG_ENTITY_LIST *listP,             \nBODY_TAG        body                \n);\n\n/**\n* @brief 体的首条边\n* @details 返回体的第一条边\n* \n* @param EDGE_TAG * pEdge\n* @param BODY_TAG body\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_bodyAskFirstEdge\n(\nEDGE_TAG        *pEdge,\nBODY_TAG        body\n);\n\n/**\n* @brief 创建空体\n* @details 创建一个最小的仅包含一个点的体\n* \n* @param BODY_TAG * b\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_body\n(\nBODY_TAG        *b                  \n);\n\n/**\n* @brief 面集到薄面体\n* @details 将输入的面拼接并创建一个薄面体,所有的面必须来自同一个体\n* \n* @param BODY_TAG * sheetP\n* @param TAG_ENTITY_LIST * faceListP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sheetFromFaces\n(\nBODY_TAG        *sheetP,            \nTAG_ENTITY_LIST *faceListP          \n);\n\n/**\n* @brief 面到薄面体\n* @details 根据输入的单个面创建一个薄面体\n* \n* @param BODY_TAG * sheetP\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sheetFromFace\n(\nBODY_TAG        *sheetP,          \nFACE_TAG        face              \n);\n\n/**\n* @brief 揭开面\n* @details 将输入的面从所属的薄面体中移除\n* \n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_uncoverFace\n(\nFACE_TAG        face\n);\n\n/**\n* @brief 两个体压印\n* @details 计算两个体的交并把交压印到目标体或两个体上\n* \n* @param TAG_ENTITY_LIST * pTargetEdges\n* @param TAG_ENTITY_LIST * pToolEdges\n* @param BODY_TAG target\n* @param BODY_TAG tool\n* @param double tolerance\n* @param bool imprintTool\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintBodies\n(\nTAG_ENTITY_LIST *pTargetEdges,  \nTAG_ENTITY_LIST *pToolEdges,    \nBODY_TAG        target,         \nBODY_TAG        tool,           \ndouble          tolerance,      \nbool            imprintTool     \n);\n\nENTITYUTIL_EXPORT bool atSolid_isSmartObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetOrSolidObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSceneerObject (ATEC::ATDataCore::ATObjectDescrP odP);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetBody (BODY_TAG bodyTag);\n\nENTITYUTIL_EXPORT bool atSolid_isWireBody (BODY_TAG bodyTag);\n\nENTITYUTIL_EXPORT bool atSolid_isFace (ENTITY_TAG entityTag);\n\nENTITYUTIL_EXPORT bool atSolid_isEdge (ENTITY_TAG entityTag);\n\n/**\n* @brief 获取FACE_TYPE\n* @details 返回FACE_TYPE常数\n* \n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_faceType ();\n\n/**\n* @brief 获取EDGE_TYPE\n* @details 返回EDGE_TYPE常数\n* \n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_edgeType ();\n\nENTITYUTIL_EXPORT void atSolid_moveBoresiteToEyePoint\n(\nATEC::XPoint3d        *pBorePoint,\nATEC::XPoint3d        *pBoreDirection,\nBODY_TAG        pBody\n);\n\nENTITYUTIL_EXPORT void atSolid_displayFace\n(\nTransDescrP     *transientPP,   \nFACE_TAG        faceP,\nbool            display,\nbool            showSmoothFaces,\nint             allowedFaceTypeMask,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             weight,\nint             style\n);\n\nENTITYUTIL_EXPORT void atSolid_displayEdge\n(\nTransDescrP     *transientPP,   \nEDGE_TAG        edgeP,          \nbool            display,        \nSmoothEdgeType  smoothSequence, \nbool            showStart,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             weight,\nint             style\n);\n\nENTITYUTIL_EXPORT int atSolid_createMark\n(\nint             *markP\n);\n\nENTITYUTIL_EXPORT int atSolid_gotoMark\n(\nint             mark\n);\n\nENTITYUTIL_EXPORT int atSolid_deleteMark\n(\nint             mark\n);\n\nENTITYUTIL_EXPORT void atSolid_getBoresiteWithBodyTransform\n(\nATEC::XPoint3dP       borePointP,         \nATEC::XPoint3dP       boreDirectionP,     \nATEC::XPoint3dCP      pntP,             \nint             view,               \nATEC::ATDataCore::ATSceneRefP    SceneRef,           \nATEC::TransformCP     bodyTransformP,     \nbool            useACS,             \nbool            frontClipBorePoint  \n);\n\nENTITYUTIL_EXPORT void atSolid_displayFaceWithBodyTransform\n(\nTransDescrP     *transientPP,       \nFACE_TAG        faceP,\nATEC::TransformP      bodyTransformP,     \nbool            display,\nbool            showSmoothFaces,\nint             nIsoParametrics,    \nint             allowedFaceTypeMask,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             style,\nint             weight\n);\n\nENTITYUTIL_EXPORT void atSolid_displayEdgeWithBodyTransform\n(\nTransDescrP     *transientPP,       \nEDGE_TAG        edgeP,              \nATEC::TransformP      bodyTransformP,     \nbool            display,            \nSmoothEdgeType  smoothSequence,     \nbool            showStart,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nUInt32          color,\nlong            style,\nUInt32          weight,\nbool            showAllEdgesWithSameId\n);\n\nENTITYUTIL_EXPORT int atSolid_getSharedEdgesOfFaces\n(\nTAG_ENTITY_LIST     *edgeListP,\nTAG_ENTITY_LIST     *faceListP\n);\n\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_getBSplineFromSmartSurface\n(\nATEC::ATBsplineSurface*   pBSurface,\nBODY_TAG            bodyP\n);\n\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_getBSplineFromSmartSurface2\n(\nATEC::ATBsplineSurface*   pBSurface,\nBODY_TAG            bodyP,\nATEC::TransformP          bodyTransformP,\nATEC::ATDataCore::ATSceneRefP        SceneRef\n);\n\n#define     SOLIDTEMPLATE_OPTION_None               0\n#define     SOLIDTEMPLATE_OPTION_PreserveElemId     1\n#define     SOLIDTEMPLATE_OPTION_PrimaryClass       2\n\nENTITYUTIL_EXPORT ATEC::ATDataCore::ATObjectP  atSolid_createBrepTemplateForOdP\n(\nATEC::ATDataCore::ATObjectP          objectP,   \nATEC::ATDataCore::ATObjectDescrCP    odP,        \nUInt32              options     \n);\n\n/**\n* @brief 沿线拉伸体\n* @details 沿着输入的线体拉伸线体或薄面体\n* \n* @param BODY_TAG * bodyP\n* @param BODY_TAG wireBody\n* @param ATEC::XPoint3d * pathStartP\n* @param double shell\n* @param bool capped\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sweepBodyWire\n(\n\tBODY_TAG        *bodyP,\n\tBODY_TAG        wireBody,\n\tATEC::XPoint3d        *pathStartP,\n\tdouble          shell,\n\tbool            capped,\n\tATEC::ATDataCore::ATSceneRefP    SceneRef\n);\n\n/**\n* @brief 根据面ID从输入的体中寻找面\n* \n* @param FACE_TAG * faceP \n* @param ATEC::FaceId * faceIdP \n* @param BODY_TAG body \n* @return ENTITYUTIL_EXPORT int \n*\n* @author SZEWEC\n* @since 2022/04/29\n*/\nENTITYUTIL_EXPORT int atSolid_faceFromId\n(\n\tFACE_TAG        *faceP,\n\tATEC::FaceId          *faceIdP,\n\tBODY_TAG        body\n);\n\n/**\n* @brief 使用输入的边生成元素,当元素代表边的一部分的时候该接口接收一个起始和终止参数\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\t\t生成的元素\n* @param ATEC::ATDataCore::ATObjectP templateP\t\t生成元素的模板,传NULL时使用默认样式\n* @param EDGE_TAG edge\t\t\t\t\t\t\t\t边\n* @param double * startParameterP\t\t\t\t\t传NULL时使用边的起点,否则为该参数指定的点（位于边上）作为起点\n* @param double * endParameterP\t\t\t\t\t\t传NULL时使用边的终点,否则为该参数指定的点（位于边上）作为终点\n* @param ATEC::ATDataCore::ATScenesRefP SceneRef\t生成的元素所在的场景\n* @return ENTITYUTIL_EXPORT int\t\t\t\t\t\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/05\n*/\nENTITYUTIL_EXPORT int atSolid_elementFromEdge\n(\n\tATEC::ATDataCore::ATObjectDescrH edPP,\n\tATEC::ATDataCore::ATObjectP      tempP,\n\tEDGE_TAG        edge,\n\tdouble          *startParameterP,\n\tdouble          *endParameterP,\n\tATEC::ATDataCore::ATSceneRefP    SceneRef\n);\n\n/**\n* @brief 将给定的曲线压印到实体上\n*\n* @param TAG_ENTITY_LIST * pImprintList\t\t[out] 压印到实体上的结果曲线,或者NULL\n* @param BODY_TAG body\t\t\t\t\t\t[in ] 实体\n* @param TAG_ENTITY_LIST * pEdgeList\t\t[in ] 待压印的曲线\n* @param ATEC::XPoint3d * pVector\t\t\t[in ] 压印（投影）的方向\n* @param double tolerance\t\t\t\t\t[in ] 容差,用于解决容差问题与计算参数空间曲线需要\n* @return ENTITYUTIL_EXPORT ATEC::StatusInt\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/30\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintCurveSet\n(\n\tTAG_ENTITY_LIST *pImprintList,\n\tBODY_TAG        body,\n\tTAG_ENTITY_LIST *pEdgeList,\n\tATEC::XPoint3d        *pVector,\n\tdouble          tolerance\n);\n\n/**\n* @brief 将给定的曲线沿着面的法线方向压印到实体上\n*\n* @param TAG_ENTITY_LIST * pImprintList\t\t[out] 压印到实体上的结果曲线,或者NULL\n* @param BODY_TAG body\t\t\t\t\t\t[in ] 实体\n* @param TAG_ENTITY_LIST * pEdgeList\t\t[in ] 待压印的曲线\n* @param double tolerance\t\t\t\t\t[in ] 容差,用于解决容差问题与计算参数空间曲线需要\n* @return ENTITYUTIL_EXPORT ATEC::StatusInt\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/30\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintCurveNormal\n(\n\tTAG_ENTITY_LIST *pImprintList,\n\tBODY_TAG        body,\n\tTAG_ENTITY_LIST *pEdgeList,\n\tdouble          tolerance\n);\n\n\n code of file XPoint3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n /**\n * @brief 3D绌洪棿鐐圭被\n * @author SZEWC\n * @since 2022/04/13\n*/\nstruct ATGEOSET_EXPORT XPoint3d\n{\n\n\tdouble x;\n\n\tdouble y;\n\n\tdouble z;\n\n\tstatic XPoint3d From(double x, double y, double z = 0.0);\n\n\tstatic XPoint3d From(XPoint2dCR xy);\n\n\tstatic XPoint3d FromZero();\n\n\tstatic XPoint3d FromOne();\n\n\tstatic XPoint3d FromXYZ(double x, double y, double z);\n\n\tvoid Swap(XPoint3dR other);\n\n\tdouble DotDifference(XPoint3dCR origin, XVec3dCR vector) const;\n\n\tvoid Zero();\n\n\tvoid Init(XPoint2dCR source);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double ay);\n\n\tvoid SetComponent(double a, int index);\n\n\tdouble GetComponent(int index) const;\n\n\tvoid Interpolate(XPoint3dCR pnt0, double fractionParameter, XPoint3dCR point1);\n\n\tdouble Distance(XPoint3dCR point2) const;\n\n\tdouble DistanceXY(XPoint3dCR point2) const;\n\n\tbool DistanceXY(XPoint3dCR otherPoint, XMatrix4dCP matrix, double &distance) const;\n\n\tbool IsEqual(XPoint3dCR point2) const;\n\n\tbool IsEqual(XPoint3dCR point2, double tolerance) const;\n\n\tbool IsDisconnect() const;\n\n\tvoid InitDisconnect();\n\n\tvoid Init(XVec3dCR vector);\n\n\tvoid Subtract(XPoint3dCR base, XVec3dCR vector);\n\n\tvoid Add(XVec3dCR vector);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2, XVec3dCR point3, double scale3);\n\n\tvoid CrossProduct(XPoint3dCR point1, XPoint3dCR point2);\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble AngleTo(XPoint3dCR point2) const;\n\n\tvoid RotateXY(XPoint3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tdouble MagnitudeXY() const;\n\n\tvoid Scale(XPoint3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XPoint3dCR vector);\n\n\tvoid Negate();\n\n\tdouble Normalize(XPoint3dCR vector);\n\n\tdouble Normalize();\n\n\tvoid Subtract(XPoint3dCR point2);\n\n\tvoid DifferenceOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2, XPoint3dCR point3, double scale3);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2, XPoint3dCR point3, double a3);\n\n\tvoid Add(XPoint3dCR vector);\n\n\tvoid SumOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, XPoint3dCR point);\n\n\tstatic XPoint3d FromInterpolate(XPoint3dCR pntA, double fraction, XPoint3dCR pntB);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector, double scaleFactor);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1, XPoint3dCR point2, double scaleFactor2);\n\n\tstatic XPoint3d FromScale(XPoint3d point, double scale);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, XVec3dCR vector);\n\n\tbool AlmostEqual(XPoint3d const & dataB) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB) const;\n\n\tbool AlmostEqual(XPoint3d const & dataB, double abstol) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB, double abstol) const;\n\n\tstatic bool AlmostEqual(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tstatic bool AlmostEqualXY(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tdouble DistanceSquared(XPoint3dCR point2) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file CreateEntityExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};\n code of file CurveSet.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 线串类\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct CurveSet : RefCountedBase, xvector<IBasicCurvePtr>\n{\n\n\tenum BoundaryType\n\t{\n\n\t\tBOUNDARY_TYPE_None = 0,\n\n\t\tBOUNDARY_TYPE_Open = 1,\n\n\t\tBOUNDARY_TYPE_Outer = 2,\n\n\t\tBOUNDARY_TYPE_Inner = 3,\n\n\t\tBOUNDARY_TYPE_ParityRegion = 4,\n\n\t\tBOUNDARY_TYPE_UnionRegion = 5,\n\t};\n\n\tenum InOutClassification\n\t{\n\t\tINOUT_Unknown = 0,\n\t\tINOUT_In = 1,\n\t\tINOUT_Out = 2,\n\t\tINOUT_On = 3\n\t};\n\nprotected:\n\tBoundaryType    m_boundaryType;\n\npublic:\n\t/**\n\t* @brief 设定边界\n\t* @details 设定曲线的边界类型\n\t* \n\t* @param BoundaryType BoundaryType\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void SetBoundaryType(BoundaryType BoundaryType);\n\n\t/**\n\t* @brief 获取叶节点\n\t* @details 通过只计算叶节点的索引深度搜索以获取目标叶节点\n\t* \n\t* @param size_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr FindIndexedLeaf(size_t index) const;\n\n\t/**\n\t* @brief 获取索引值\n\t* @details 深度搜索以获取给定叶节点的索引值\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @param size_t & index\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool LeafToIndex(IBasicCurveCP primitive, size_t &index) const;\n\n\t/**\n\t* @brief 获取叶节点个数\n\t* @details 获取曲线的叶节点个数\n\t* \n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesBelow() const;\n\n\texplicit CurveSet(BoundaryType boundaryType) { m_boundaryType = boundaryType; }\n\n\t/**\n\t* @brief 是否单元素曲线\n\t* @details 查询曲线是否只有一个基本元素\n\t* \n\t* @return IBasicCurve\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurve::BasicCurveType HasSingleBasicCurve() const;\n\n\t/**\n\t* @brief 获取边界类型\n\t* @details 获取曲线的边界类型\n\t* \n\t* @return BoundaryType\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT BoundaryType GetBoundaryType() const;\n\n\t/**\n\t* @brief 查询是否开\n\t* @details 查询是否开路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsOpenPath() const;\n\n\t/**\n\t* @brief 查询是否闭\n\t* @details 查询是否闭路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsClosedPath() const;\n\n\t/**\n\t* @brief 查询实际开闭\n\t* @details 查询是否名义上是开路径但起点和终点连接\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsPhysicallyClosedPath() const;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个带有给定边界类型没有成员的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个具有单个基本元素和给定边界类型的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @param IBasicCurvePtr primitive\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType, IBasicCurvePtr primitive);\n\n\t/**\n\t* @brief 拷贝\n\t* @details 返回一个深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr Clone() const;\n\n\t/**\n\t* @brief 倒角拷贝\n\t* @details 返回一个深度拷贝,在连续曲线之间插入圆角\n\t* \n\t* @param double radius\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithFillets(double radius) const;\n\n\t/**\n\t* @brief 闭合拷贝\n\t* @details 返回一个深度拷贝,闭合终端点的间隙\n\t* \n\t* @param CurveGapOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithGapsClosed(CurveGapOptionsCR options) const;\n\n\t/**\n\t* @brief 添加元素\n\t* @details 递归遍历source, 将所有叶节点添加到this, 返回添加的数量\n\t* \n\t* @param CurveSetCR source\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t AddPrimitives(CurveSetCR source);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 添加单个基本曲线\n\t* \n\t* @param IBasicCurvePtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(IBasicCurvePtr child);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 将chile的所有元素作为曲线成员添加\n\t* \n\t* @param CurveSetPtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(CurveSetPtr child);\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过XY方向的偏移后的深度拷贝\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneOffsetCurvesXY(CurveOffsetOptionsCR options);\n\n\t/**\n\t* @brief 获取叶节点数量\n\t* @details 计算指定类型的叶节点数量\n\t* \n\t* @param IBasicCurve::BasicCurveType targetType\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesOfType(IBasicCurve::BasicCurveType targetType) const;\n\n\t/**\n\t* @brief 用区域分割曲线\n\t* @details 用指定区域分割曲线,分别返回区域内、外和区域上的曲线\n\t* \n\t* @param CurveSetCR region\n\t* @param CurveSetP insideCollector\n\t* @param CurveSetP outsideCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByRegion(CurveSetCR region, CurveSetP insideCollector, CurveSetP outsideCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 用平面分割曲线\n\t* @details 用指定平面分割曲线,分别返回平面上方、下方和平面内的曲线\n\t* \n\t* @param XPlane3dCR plane\n\t* @param CurveSetP belowCollector\n\t* @param CurveSetP aboveCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByPlane(XPlane3dCR plane, CurveSetP belowCollector, CurveSetP aboveCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 拆分拷贝\n\t* @details 返回一个深度拷贝,但所有的多线段被拆分成单条线段\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithExplodedLinestrings() const;\n\n\t/**\n\t* @brief 获取质心\n\t* @details 返回包含曲线的质心(不考虑孤立点)\n\t* \n\t* @param double & length\n\t* @param XPoint3dR centroid\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  WireCentroid(double &length, XPoint3dR centroid) const;\n\n\t/**\n\t* @brief 获取质心、法向量和面积\n\t* @details 返回质心、法向量和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param XVec3dR normal\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CentroidNormalArea(XPoint3dR centroid, XVec3dR normal, double &area) const;\n\n\t/**\n\t* @brief 获取质心和面积\n\t* @details 返回XY平面方向上的质心和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  CentroidAreaXY(XPoint3dR centroid, double &area) const;\n\n\t/**\n\t* @brief 投影范围\n\t* @details 当投影到射线的时候,返回射线参数的范围\n\t* \n\t* @param XRay3dCR ray\n\t* @return XRange1d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT XRange1d ProjectedParameterRange(XRay3dCR ray) const;\n\n    /**\n    * @brief 局部坐标拷贝\n    * @details 返回曲线的深度复制并转换为与曲线相关联的局部坐标系统。\n    * \n    * @param LocalCoordinateSelect frameType\n    * @param TransformR localToWorld\n    * @param TransformR worldToLocal\n    * @param XRange3dR localRange\n    * @return CurveSetPtr\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT CurveSetPtr CloneInLocalCoordinates\n    (\n    LocalCoordinateSelect frameType,\n    TransformR localToWorld,\n    TransformR worldToLocal,\n    XRange3dR localRange\n    ) const;\n\n\t/**\n    * @brief 获取有坐标系的元素\n    * @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame) const;\n\n\t/**\n\t* @brief 获取有坐标系的元素\n\t* @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @param int searchPreference\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame, int srchPref) const;\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param xvector<XPoint3d> const & points\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(xvector<XPoint3d> const&points,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint3dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint3dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建多边形\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint2dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint2dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建矩形\n\t* @details 根据 XY 坐标创建矩形\n\t* \n\t* @param double x0\n\t* @param double y0\n\t* @param double x1\n\t* @param double y1\n\t* @param double z\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateRectangle(double x0, double y0, double x1, double y1, double z,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由给定线段创建边界类型为 BOUNDARY_TYPE_None 的曲线\n\t* \n\t* @param xvector<XSegment3d> const & segments\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(xvector<XSegment3d> const &segs);\n\n\t/**\n\t* @brief 创建圆盘\n\t* @details 为一个完整的椭圆(圆)盘创建一个曲线向量结构\n\t* \n\t* @param XEllipse3dCR arc\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateDisk(XEllipse3dCR arc, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer, bool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个仅有单一元素的曲线结构\n\t* \n\t* @param IBasicCurvePtr child\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(IBasicCurvePtr child, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open);\n\n\t/**\n\t* @brief B样条拷贝\n\t* @details 返回一个深度拷贝,作为B样条曲线\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneAsBsplines() const;\n\n\t/**\n\t* @brief 添加边缘点\n\t* @details 为所有的子节点添加边缘点\n\t* \n\t* @param xvector <XPoint3d> & points\n\t* @param IFacetOptionsR options\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AddStrokePoints(xvector <XPoint3d> &points, IFacetOptionsR options) const;\n\n    /**\n\t* @brief 添加面点\n\t* @details 沿着曲线计算指定距离的点\n\t* \n\t* @param xvector<double> const & distances\n\t* @param xvector<CurveDescInfo> & locations\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool AddSpacedPoints(xvector<double> const &distances, xvector<CurveDescInfo> &locations) const;\n\n\t/**\n\t* @brief 添加边缘\n\t* @details 在结构中添加所有边缘\n\t* \n\t* @param xvector <xvector<xvector<XPoint3d>>> & regionsPoints\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CollectLinearGeometry(xvector <xvector<xvector<XPoint3d>> > &regionsPoints) const;\n\n\t/**\n\t* @brief 获取B样条曲线\n\t* @details 将一个表示开放或闭合路径作为单个B样条曲线\n\t* \n\t* @return ATBsplineCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetBsplineCurve() const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n    /**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索最接近曲线的点。如果曲线是一个区域类型,同时要在该区域的内部寻找投影\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XPoint3dR curveOrRegionPoint\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification ClosestCurveOrRegionPoint(XPoint3dCR spacePoint, XPoint3dR curveOrRegionPoint) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点和终点\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点终点和他们的正切值\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @param XVec3dR unitTangentA\n\t* @param XVec3dR unitTangentB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\t/**\n\t* @brief 获取起点\n\t* @details 返回曲线的起点\n\t* \n\t* @param XPoint3dR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线总长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length() const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线经过变换后的总长度\n\t* \n\t* @param XRotMatrixCP worldToLocal\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length(XRotMatrixCP worldToLocal) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线的xyz范围\n\t* \n\t* @param XRange3dR range\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线经过变换后的范围\n\t* \n\t* @param XRange3dR range\n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\t/**\n\t* @brief 查询索引\n\t* @details 返回指定元素的索引\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t FindIndexOfPrimitive(IBasicCurveCP primitive) const;\n\n\t/**\n\t* @brief 复制曲线指定范围的曲线\n\t* @details 复制曲线指定索引和比例参数范围内的部分\n\t* \n\t* @param int index0\n\t* @param double fraction0\n\t* @param int index1\n\t* @param double fraction1\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n    ATGEOSET_EXPORT CurveSetPtr CloneBetweenCyclicIndexedFractions(int index0, double fraction0, int index1, double fraction1) const;\n\n\t/**\n\t* @brief 反转拷贝\n\t* @details 返回一个所有元素都被反转的深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneReversed() const;\n\n\t/**\n\t* @brief 查询是否包含非线性元素\n\t* @details 如果曲线有一个不非线性元素,则返回true。\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ContainsNonLinearPrimitive() const;\n\n\t/**\n\t* @brief 计算交点\n\t* @details 计算曲线与给定平面的交点\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 平面选中\n\t* @details 计算封闭曲线与平面的交叉点,并以奇偶性规则为设为起始对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param double tolerance\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr PlaneSection(XPlane3dCR plane, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 空间点位置情况\n\t* @details 当以XY平面视角看,测试给定点在曲线内、曲线上还是曲线外\n\t* \n\t* @param XPoint3dCR xyz\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification PointInOnOutXY(XPoint3dCR xyz) const;\n\n\t/**\n\t* @brief 射线击中情况\n\t* @details 测试射线击中曲线在区域内、区域上还是区域外\n\t* \n\t* @param XRay3dCR ray\n\t* @param SolidDescInfoR hitDetail\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification RayPierceInOnOut\n\t(\n\t\tXRay3dCR ray,\n\t\tSolidDescInfoR hitDetail\n\t) const;\n\n\t/**\n\t* @brief 原地变换\n\t* @details 应用给定变换并修改曲线\n\t* \n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\t/**\n\t* @brief 原地反转\n\t* @details 将所有元素进行反转\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串内的单个点被消除,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串相邻的空间点被消除（可选）,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @param bool doSimplifyLinestrings\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives(bool doSimplifyLinestrings);\n\n\t/**\n\t* @brief 原地修改以简化线串\n\t* @details 消除线串相邻的空间点\n\t* \n\t* @param double distanceTol\n\t* @param bool eliminateOverdraw\n\t* @param bool wrap\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void SimplifyLinestrings(double distTol, bool eliminateOverdraw, bool wrap);\n\n\t/**\n\t* @brief 重排元素\n\t* @details 将曲线元素重新排序以缩小元素首尾相连的间隙\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT double ReorderForSmallGaps();\n\n\t/**\n\t* @brief 链接元素\n\t* @details 将曲线的元素首尾相连\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AssembleChains();\n\n\t/**\n\t* @brief 区域相并\n\t* @details 返回给定两个区域的并\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaUnion(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相减\n\t* @details 返回给定两个区域的减\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaDifference(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相交\n\t* @details 返回给定两个区域的交\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaIntersection(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 循环索引\n\t* @details 返回给定索引值关于集合大小的模\n\t* \n\t* @param int index\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT size_t CyclicIndex(int index) const;\n\n\t/**\n\t* @brief 循环获取值\n\t* @details 根据给定索引的循环索引获取元素\n\t* \n\t* @param ptrdiff_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr GetCyclic(ptrdiff_t index) const;\n\n    /**\n    * @brief 获取索引\n    * @details 返回给定曲线元素的详细细节所对应的元素索引\n    * \n    * @param CurveDescInfo const & location\n    * @return size_t\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT size_t CurveDescInfoIndex(CurveDescInfo const& location) const;\n\n\t/**\n\t* @brief 与平面相交\n\t* @details 计算封闭曲线与平面的交叉点,返回以奇偶性规则构造的起止点对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool AppendClosedCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过给定偏移后的深度拷贝.\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AreaOffset(CurveOffsetOptionsCR options) const;\n\n\t/**\n\t* @brief 返回从index0,fraction0到index1,fraction1的曲线段\n\t* \n\t* @param int index0 \n\t* @param double fraction0 \n\t* @param int index1 \n\t* @param double fraction1 \n\t* @param bool allowExtrapolation \n\t* @return ATGEOSET_EXPORT CurveSetPtr \n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/17\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneBetweenDirectedFractions(int index0, double fraction0, int index1, double fraction1, bool allowExtrapolation) const;\n\n\t/**\n\t* @brief 返回输入的曲线的布尔奇运算结果（区域）\n\t*\n\t* @param CurveSetCR regionA\t\t\t\t\t左操作数\n\t* @param CurveSetCR regionB\t\t\t\t\t右操作数\n\t* @param BasicCurvePtrPairVector * newToOld\t（可选）包含新旧曲线的数组指针\n\t* @return ATGEOSET_EXPORT CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/07/22\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaParity(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n};\n\nstruct CurveCurve\n{\nprivate: CurveCurve();\npublic:\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tCurveSetR curveA,\n\t\tCurveSetR curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB,\n\t\tXMatrix4dCP    pWorldToLocal,\n\t\tbool         extend = false\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveR curveA,\n\t\tCurveSetR     curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tCurveSetCR chainA,\n\t\tCurveSetCR chainB\n\t);\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            double &fractionA,\n            XPoint3dR pntA,\n            double &fractionB,\n            XPoint3dR pntB\n            );\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            CurveDescInfoR detailA,\n            CurveDescInfoR detailB\n            );\n};\n\nstruct PathLocationDetail\n{\nprivate:\n\tCurveDescInfo m_curveDetail;\n\tint32_t m_pathIndex;\n\tdouble m_pathDistance;\npublic:\n\n\tATGEOSET_EXPORT PathLocationDetail();\n\n\tATGEOSET_EXPORT PathLocationDetail(PathLocationDetail const &other);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, int pathIndex = -1, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, size_t pathIndex, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(double distance);\n\n\tATGEOSET_EXPORT XPoint3d Point() const;\n\n\tATGEOSET_EXPORT CurveDescInfo GetCurveDescInfo() const;\n\n    ATGEOSET_EXPORT double DistanceFromPathStart() const;\n};\n\nstruct CurveSetWithDistanceIndex : RefCountedBase\n{\nprivate:\n\n\tstruct PathEntry : PathLocationDetail\n\t{\n\t\tdouble             m_projectedDistance;\n\t\tXRange3d           m_range;\n\t\tPathEntry(PathLocationDetail const &pathDetail, double projectedDist, XRange3dCR range)\n\t\t\t: PathLocationDetail(pathDetail),\n\t\t\tm_projectedDistance(projectedDist),\n\t\t\tm_range(range)\n\t\t{\n\t\t}\n\t\tPathEntry(double distance) : PathLocationDetail(distance), m_projectedDistance(distance) {}\n\n\t\tdouble GetDistance(bool projected) const;\n\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistanceXY(PathEntry const &dataA, PathEntry const &dataB);\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistance(PathEntry const &dataA, PathEntry const &dataB);\n\t};\n\n\tCurveSetPtr m_curveVector;\n\txvector<PathEntry> m_locations;\n\tCurveSetPtr m_savedPrimitives;\n\n\tXRotMatrix m_worldToViewRotMatrix;\n\tXRotMatrix m_viewToWorldRotMatrix;\n\tXRotMatrix m_flattenToView;\n\tXMatrix4d m_worldToView;\n\n\texplicit CurveSetWithDistanceIndex(XRotMatrix worldToView);\n\n\tCurveSetWithDistanceIndex();\n\npublic:\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create(XRotMatrix worldToView);\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create();\n\n\tATGEOSET_EXPORT void SetPath(CurveSetPtr &path);\n\n\tATGEOSET_EXPORT bool SearchByDistanceFromPathStart\n\t(\n\t\tdouble targetDist,\n\t\tPathLocationDetail &detail\n\t) const;\n\n    ATGEOSET_EXPORT PathLocationDetail SearchClosestPointBounded\n    (\n    XPoint3dCR spacePoint,\n    bool computeDistAlong\n    ) const;\n};\n\nEND_ATEC_NAMESPACE\n\n", "output": "\nISolidCoreEntityPtr CreateEntityExamples::GetCuboidEntity()\n{\n    //准备截面\n    XPoint3d pt1 = XPoint3d::FromXYZ(0, -25000, 0);\n    XPoint3d pt2 = XPoint3d::FromXYZ(25000, -25000, 0);\n    XPoint3d pt3 = XPoint3d::FromXYZ(25000, 25000, 0);\n    XPoint3d pt4 = XPoint3d::FromXYZ(0, 25000, 0);\n    XPoint3dVector pts = { pt1, pt2, pt3, pt4, pt1 };\n    CurveSetPtr profilePtr = CurveSet::CreateLinear(pts, CurveSet::BOUNDARY_TYPE_Outer);\n    if (!profilePtr.IsValid())\n        return nullptr;\n\n    //path\n    XPoint3d pathPt1 = XPoint3d::FromXYZ(0, 0, 0);\n    XPoint3d pathPt2 = XPoint3d::FromXYZ(0, 0, 10000);\n    XPoint3dVector pathPts = { pathPt1, pathPt2 };\n    CurveSetPtr pathPtr = CurveSet::CreateLinear(pathPts, CurveSet::BOUNDARY_TYPE_Open);\n    if (!pathPtr.IsValid())\n        return nullptr;\n\n    ISolidCoreEntityPtr cuboidEntityPtr = nullptr;\n    ATSceneRefP pSceneref = atSceneRef_getActive();\n    if (pSceneref == nullptr)\n        return nullptr;\n\n    EntityUtl::Create::EntityFromSweep(cuboidEntityPtr, *profilePtr, *pathPtr, *pSceneref, false, true, false);\n    return cuboidEntityPtr;\n}\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};. You need to implement the function BooleanExample in the interface. Here are some apis that you can use and remember:\n code of file EntityUtl.h: \n\n#pragma once\n\n/**\n* @file EntityUtl.h\n*\n* @author SZEWC\n* @date 2022/04/27\n*/\n\n\n/**\n* @brief 以指定起终点截面的方式拉伸体\n* @details \n* \n* @param ISolidCoreEntityPtr & out \n* @param CurveSetCR startProfile \n* @param CurveSetCR endProfile \n* @param CurveSetCR path \n* @param ATSceneRefR scene \n* @param bool alignParallel \n* @param bool selfRepair \n* @param bool createSheet \n* @param XVec3dCP lockDirection \n* @param double const * twistAngle \n* @param double const * scale \n* @param XPoint3dCP scalePoint \n* @return ATEC \n*\n* @author SZEWEC\n* @since 2022/04/28\n*/\nENTITYUTIL_EXPORT ATEC::ATECStatus atSolid_EntityFromSweep\n(\nATEC::ATDataCore::ISolidCoreEntityPtr& out,\nATEC::CurveSetCR startProfile,\nATEC::CurveSetCR endProfile,\nATEC::CurveSetCR path,\nATEC::ATDataCore::ATSceneRefR scene,\nbool alignParallel,\nbool selfRepair,\nbool createSheet,\nATEC::XVec3dCP lockDirection = NULL,\ndouble const* twistAngle = NULL,\ndouble const* scale = NULL,\nATEC::XPoint3dCP scalePoint = NULL\n);\n\n/**\n* @brief 元件到体\n* @details 将给定元件转换成体\n* \n* @param BODY_TAG * bodyP\n* @param ATEC::TransformP bodyTransformP\n* @param ATEC::ATDataCore::ATObjectDescrP odP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @param UInt32 nodeId\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_elementToBody\n(\nBODY_TAG*       bodyP,          \nATEC::TransformP      bodyTransformP, \nATEC::ATDataCore::ATObjectDescrP odP,            \nATEC::ATDataCore::ATSceneRefP    SceneRef,       \nUInt32          nodeId = 1L     \n);\n\n/**\n* @brief 体到元件\n* @details 将给定体转换成元件\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\n* @param BODY_TAG bodyTag\n* @param bool wireframe\n* @param int uIsoParametrics\n* @param int vIsoParametrics\n* @param unsigned int useSmartIso\n* @param ATEC::ATDataCore::ATObjectP templateP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_bodyToObject\n(\nATEC::ATDataCore::ATObjectDescrH edPP,               \nBODY_TAG        bodyTag,            \nbool            wireframe,          \nint             uIsoParametrics,    \nint             vIsoParametrics,    \nunsigned int    useSmartIso,        \nATEC::ATDataCore::ATObjectP      tempP,          \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 面到元件\n* @details 将给定的面转换成等价的元件\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\n* @param FACE_TAG face\n* @param bool wireframe\n* @param int nIsoparametrics\n* @param ATEC::ATDataCore::ATObjectP templateP\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_faceToObject\n(\nATEC::ATDataCore::ATObjectDescrH edPP,               \nFACE_TAG        face,               \nbool            wireframe,          \nint             nIsoparametrics,    \nATEC::ATDataCore::ATObjectP      tempP,          \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 体求减\n* @details 从 b2 中减去 b1\n* \n* @param BODY_TAG b2\n* @param BODY_TAG b1\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_subtract\n(\nBODY_TAG        b2,                \nBODY_TAG        b1                 \n);\n\n/**\n* @brief 面面相交\n* @details 计算两个面的交,结果以线体返回\n* \n* @param BODY_TAG * b\n* @param FACE_TAG f1\n* @param FACE_TAG f2\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_faceFaceIntersect\n(\nBODY_TAG        *b,                \nFACE_TAG        f1,                \nFACE_TAG        f2                 \n);\n\n/**\n* @brief 获取输入实体的面ID\n* \n* @param ATEC::FaceId * faceIdP\n* @param ENTITY_TAG ent\n* @param bool useHighestId\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/27\n*/\nENTITYUTIL_EXPORT int atSolid_idFromEntity\n(\nATEC::FaceId          *faceIdP,\nENTITY_TAG      ent,\nbool            useHighestId\n);\n\n/**\n* @brief 检查体\n* @details 检查输入体的几何、拓扑和尺寸有效性\n* \n* @param BODY_TAG body\n* @param bool checkGeometry\n* @param bool checkTopology\n* @param bool checkSize\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_checkBody\n(\nBODY_TAG        body,\nbool            chkGeometry,\nbool            chkTopology,\nbool            chkSize\n);\n\n/**\n* @brief 创建实体列表\n* @details 创建一个空的实体列表\n* \n* @param TAG_ENTITY_LIST * * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listCreate\n(\nTAG_ENTITY_LIST **lP            \n);\n\n/**\n* @brief 删除实体列表\n* @details 释放给定实体列表分配的内存\n* \n* @param TAG_ENTITY_LIST * * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listDelete\n(\nTAG_ENTITY_LIST **lP            \n);\n\n/**\n* @brief 列表添加元素\n* @details 往实体列表的尾部添加一个元素\n* \n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listAdd\n(\nTAG_ENTITY_LIST *lP,            \nENTITY_TAG      ent             \n);\n\n/**\n* @brief 列表添加元素\n* @details 往实体列表的尾部添加另一个列表的所有元素\n* \n* @param TAG_ENTITY_LIST * lDP\n* @param TAG_ENTITY_LIST * lSP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listAddList\n(\nTAG_ENTITY_LIST *lDP,\nTAG_ENTITY_LIST *lSP\n);\n\n/**\n* @brief 列表移除实体\n* @details 从列表中移除指定的实体\n* \n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listRemove\n(\nTAG_ENTITY_LIST *lP,\nENTITY_TAG      ent\n);\n\n/**\n* @brief 列表计数\n* @details 返回实体列表的元素个数\n* \n* @param int * count\n* @param TAG_ENTITY_LIST * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listCount\n(\nint             *count,         \nTAG_ENTITY_LIST *lP             \n);\n\n/**\n* @brief 列表查询实体\n* @details 在列表中搜索给定的实体并返回中索引,若不存在返回-1\n* \n* @param int * nth\n* @param TAG_ENTITY_LIST * lP\n* @param ENTITY_TAG ent\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listLookup\n(\nint             *nth,           \nTAG_ENTITY_LIST *lP,            \nENTITY_TAG      ent             \n);\n\n/**\n* @brief 查询列表指定位置的元素\n* @details 返回实体列表指定位置的元素\n* \n* @param ENTITY_TAG * entP\n* @param TAG_ENTITY_LIST * lP\n* @param int nth\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listNthEl\n(\nENTITY_TAG      *entP,          \nTAG_ENTITY_LIST *lP,            \nint             nth             \n);\n\n/**\n* @brief 清空列表\n* @details 移除列表中的所有元素\n* \n* @param TAG_ENTITY_LIST * lP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_listEmpty\n(\nTAG_ENTITY_LIST *lP             \n);\n\nENTITYUTIL_EXPORT int atSolid_listCreateNonEntity (NON_ENTITY_LIST** lPP);\nENTITYUTIL_EXPORT int atSolid_listDeleteNonEntity (NON_ENTITY_LIST** lPP);\nENTITYUTIL_EXPORT int atSolid_listAddNonEntity (NON_ENTITY_LIST* lP, void* dataP);\nENTITYUTIL_EXPORT int atSolid_listCountNonEntity (int* countP, NON_ENTITY_LIST* lP);\nENTITYUTIL_EXPORT int atSolid_listNthNonEntity (void** dataPP, NON_ENTITY_LIST* lP, int nth);\n\n/**\n* @brief 偏移面\n* @details 将输入面的集合中所有面偏移指定距离,这些面必须属于同一个体\n* \n* @param TAG_ENTITY_LIST * pFaceList\n* @param double * pOffset\n* @param double tolerance\n* @param bool faceFaceCheck\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_offsetFaces\n(\nTAG_ENTITY_LIST *pFaceList,\ndouble          *pOffset,\ndouble          tolerance,\nbool            faceFaceCheck\n);\n\n/**\n* @brief 偏移线体\n* @details 返回给定线体偏移后的边缘\n* \n* @param TAG_ENTITY_LIST * pOffsetList\n* @param BODY_TAG wireBody\n* @param EDGE_TAG refEdge\n* @param ATEC::XPoint3d * pNormal\n* @param double distance\n* @param double tolerance\n* @param int gapFill\n* @param bool localCheck\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_offsetWire\n(\nTAG_ENTITY_LIST *pOffsetList,\nBODY_TAG        wireBody,\nEDGE_TAG        refEdge,\nATEC::XPoint3d        *pNormal,           \ndouble          distance,\ndouble          tolerance,\nint             gapFill,            \nbool            localCheck\n);\n\n/**\n* @brief 面上最近的点\n* @details 计算给定面上离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * clstPt\n* @param ATEC::XPoint3d * normal\n* @param ATEC::XPoint2d * param\n* @param ATEC::XPoint3d * testPt\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_closestPointToFace\n(\nATEC::XPoint3d        *clstPt,            \nATEC::XPoint3d        *normal,            \nATEC::XPoint2d        *param,             \nATEC::XPoint3d        *testPt,            \nFACE_TAG        face                \n);\n\n/**\n* @brief 边上最近的点\n* @details 计算给定边上离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * clstPt\n* @param double * param\n* @param ATEC::XPoint3d * testPt\n* @param EDGE_TAG edge\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_closestPointToEdge\n(\nATEC::XPoint3d        *clstPt,            \ndouble          *param,             \nATEC::XPoint3d        *testPt,            \nEDGE_TAG        edge               \n);\n\n/**\n* @brief 离点最近的点\n* @details 计算给定点离输入的点距离最近的点\n* \n* @param ATEC::XPoint3d * point\n* @param VERTEX_TAG vertex\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_pointFromVertex\n(\nATEC::XPoint3d        *point,             \nVERTEX_TAG      vertex              \n);\n\n/**\n* @brief 获取实体\n* @details 从给定起始点发射射线,返回体上与之相交的所有实体\n* \n* @param TAG_ENTITY_LIST * hits\n* @param double * * params\n* @param ATEC::XPoint3dP origin\n* @param ATEC::XPoint3dP dir\n* @param double radius\n* @param int type\n* @param BODY_TAG b\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getEntities\n(\nTAG_ENTITY_LIST *hits,              \ndouble          **params,           \nATEC::XPoint3dP       origin,             \nATEC::XPoint3dP       dir,                \ndouble          radius,             \nint             type,               \nBODY_TAG        b,                  \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 获取面实体\n* @details 从给定起始点发射射线,返回体上与之相交的第一个面以及相应的交点\n* \n* @param ATEC::XPoint3d * outPointP\n* @param ATEC::XPoint3d * outNormalP\n* @param FACE_TAG * outFaceP\n* @param ATEC::XPoint3d * inPointP\n* @param ATEC::XPoint3d * inNormalP\n* @param BODY_TAG body\n* @param bool backupRayOrigin\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_boresiteToFace\n(\nATEC::XPoint3d        *outPointP,         \nATEC::XPoint3d        *outNormalP,        \nFACE_TAG        *outFaceP,          \nATEC::XPoint3d        *inPointP,          \nATEC::XPoint3d        *inNormalP,         \nBODY_TAG        body,               \nbool            backupRayOrigin,    \nATEC::ATDataCore::ATSceneRefP    SceneRef            \n);\n\n/**\n* @brief 曲线与面相交\n* @details 将给定部分曲线与给定的面相交,并返回曲线与面之间的交点以及相应的参数\n* \n* @param ATEC::XPoint3dP * pointPP\n* @param ATEC::XPoint2d * * faceUVPP\n* @param double * * curveParamPP\n* @param int * numIntsP\n* @param FACE_TAG face\n* @param CURVE_TAG curve\n* @param double startParam\n* @param double endParam\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_faceIntersectCurve\n(\nATEC::XPoint3dP       *pntPP,\nATEC::XPoint2d        **faceUVPP,\ndouble          **curveParamPP,\nint             *numIntsP,\nFACE_TAG        face,\nCURVE_TAG       curve,\ndouble          startParam,\ndouble          endParam\n);\n\n/**\n* @brief 获取体的包围盒\n* @details 计算给定体的包围盒\n* \n* @param ATEC::XPoint3d * lo\n* @param ATEC::XPoint3d * hi\n* @param BODY_TAG b\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getBodyBox\n(\nATEC::XPoint3d       *lo,             \nATEC::XPoint3d       *hi,             \nBODY_TAG       b                \n);\n\n/**\n* @brief 获取平滑的面列表\n* @details 向面的列表中添加一个面,并添加这个面与列表中的面的平滑连接\n* \n* @param TAG_ENTITY_LIST * listP\n* @param FACE_TAG face\n* @param bool addSmoothFaces\n* @param int allowedFaceTypeMask\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getSmoothFaceList\n(\nTAG_ENTITY_LIST *listP,\nFACE_TAG        face,\nbool            addSmoothFaces,\nint             allowedFaceTypeMask\n);\n\nenum SmoothEdgeType\n    {\n    SMOOTH_TYPE_NONE  = 0,\n    SMOOTH_TYPE_BLEND = 1,\n    SMOOTH_TYPE_TANGENT = 2\n    };\n\n/**\n* @brief 面的所有边\n* @details 返回构成面的所有边\n* \n* @param TAG_ENTITY_LIST * edgeListP\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_getEdgeListFromFace\n(\nTAG_ENTITY_LIST *edgeListP,         \nFACE_TAG        face                \n);\n\n/**\n* @brief 线体是否G1连续\n* @details 查询线体是否关于所有点G1连续\n* \n* @param BODY_TAG wire\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_wireIsG1\n(\nBODY_TAG        wire\n);\n\n/**\n* @brief 实体最小距离\n* @details 计算两个实体之间的最小距离\n* \n* @param ATEC::XPoint3dP pPoint1\n* @param ATEC::XPoint3dP pPoint2\n* @param double * pDistance\n* @param ENTITY_TAG entity1\n* @param ENTITY_TAG entity2\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_minimumDistanceBetweenEntities\n(\nATEC::XPoint3dP           pPoint1,\nATEC::XPoint3dP           pPoint2,\ndouble              *pDist,\nENTITY_TAG          entity1,\nENTITY_TAG          entity2\n);\n\n/**\n* @brief 简化体\n* @details 尝试将B样条曲线和曲面简化为分析曲线和曲面\n* \n* @param BODY_TAG * bodyP\n* @param bool local\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_simplifyBody\n(\nBODY_TAG        *bodyP,\nbool            local\n);\n\n/**\n* @brief 开始转换\n* @details 将变换矩阵推入堆栈中\n* \n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_beginCurrTrans (ATEC::ATDataCore::ATSceneRefP SceneRef);\n\n/**\n* @brief 结束转换\n* @details 从堆栈中弹出brSolid_beginCurrTrans推入的变换矩阵\n* \n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_endCurrTrans ();\n\n/**\n* @brief 应用变换\n* @details 对体应用给定变换\n* \n* @param ENTITY_TAG entity\n* @param ATEC::TransformP transformP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_applyTransform\n(\nENTITY_TAG      entity,            \nATEC::TransformP      transformP         \n);\n\n/**\n* @brief 给薄面体加盖\n* @details 通过添加其他面封闭给定的薄面体并转换为体\n* \n* @param TAG_ENTITY_LIST * faces\n* @param BODY_TAG * lamina\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_capSurface\n(\nTAG_ENTITY_LIST *faces,             \nBODY_TAG        *lamina             \n);\n\n/**\n* @brief 逆转体\n* @details 将体中的所有面逆转方向\n* \n* @param BODY_TAG body\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_reverseBody\n(\nBODY_TAG        body               \n);\n\n/**\n* @brief 删除实体\n* @details 删除给定的实体\n* \n* @param ENTITY_TAG e\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_deleteEntity\n(\nENTITY_TAG      e                  \n);\n\n/**\n* @brief 复制体\n* @details 创建给定体的一个复制\n* \n* @param BODY_TAG * copy\n* @param BODY_TAG source\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_copyBody\n(\nBODY_TAG        *copy,\nBODY_TAG        source\n);\n\n/**\n* @brief 删除体\n* @details 释放体所分配的内存\n* \n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_freeBody\n(\nBODY_TAG        body               \n);\n\n/**\n* @brief 释放内存\n* @details 释放列表所分配的内存\n* \n* @param void * v\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_free\n(\nvoid            *v\n);\n\n/**\n* @brief 边缘数据\n* @details 返回边缘的拓扑和几何信息\n* \n* @param VERTEX_TAG * startVertexP\n* @param VERTEX_TAG * endVertexP\n* @param ATEC::XPoint3d * startPointP\n* @param ATEC::XPoint3d * endPointP\n* @param double * startParamP\n* @param double * endParamP\n* @param COEDGE_TAG * coEdgeP\n* @param CURVE_TAG * curveP\n* @param bool * reversedP\n* @param EDGE_TAG edge\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_edgeData\n(\nVERTEX_TAG      *startVertexP,  \nVERTEX_TAG      *endVertexP,    \nATEC::XPoint3d        *startPointP,   \nATEC::XPoint3d        *endPointP,     \ndouble          *startParamP,   \ndouble          *endParamP,     \nCOEDGE_TAG      *coEdgeP,       \nCURVE_TAG       *curveP,        \nbool            *reversedP,     \nEDGE_TAG        edge            \n);\n\n/**\n* @brief 获取所有边\n* @details 返回体的所有边列表\n* \n* @param TAG_ENTITY_LIST * listP\n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getEdgeList\n(\nTAG_ENTITY_LIST *listP,             \nBODY_TAG        body                \n);\n\n/**\n* @brief 获取所有面\n* @details 返回体的所有面列表\n* \n* @param TAG_ENTITY_LIST * listP\n* @param BODY_TAG body\n* @return void\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT void atSolid_getFaceList\n(\nTAG_ENTITY_LIST *listP,             \nBODY_TAG        body                \n);\n\n/**\n* @brief 体的首条边\n* @details 返回体的第一条边\n* \n* @param EDGE_TAG * pEdge\n* @param BODY_TAG body\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_bodyAskFirstEdge\n(\nEDGE_TAG        *pEdge,\nBODY_TAG        body\n);\n\n/**\n* @brief 创建空体\n* @details 创建一个最小的仅包含一个点的体\n* \n* @param BODY_TAG * b\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/21\n*/\nENTITYUTIL_EXPORT int atSolid_body\n(\nBODY_TAG        *b                  \n);\n\n/**\n* @brief 面集到薄面体\n* @details 将输入的面拼接并创建一个薄面体,所有的面必须来自同一个体\n* \n* @param BODY_TAG * sheetP\n* @param TAG_ENTITY_LIST * faceListP\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sheetFromFaces\n(\nBODY_TAG        *sheetP,            \nTAG_ENTITY_LIST *faceListP          \n);\n\n/**\n* @brief 面到薄面体\n* @details 根据输入的单个面创建一个薄面体\n* \n* @param BODY_TAG * sheetP\n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sheetFromFace\n(\nBODY_TAG        *sheetP,          \nFACE_TAG        face              \n);\n\n/**\n* @brief 揭开面\n* @details 将输入的面从所属的薄面体中移除\n* \n* @param FACE_TAG face\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_uncoverFace\n(\nFACE_TAG        face\n);\n\n/**\n* @brief 两个体压印\n* @details 计算两个体的交并把交压印到目标体或两个体上\n* \n* @param TAG_ENTITY_LIST * pTargetEdges\n* @param TAG_ENTITY_LIST * pToolEdges\n* @param BODY_TAG target\n* @param BODY_TAG tool\n* @param double tolerance\n* @param bool imprintTool\n* @return ATEC\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintBodies\n(\nTAG_ENTITY_LIST *pTargetEdges,  \nTAG_ENTITY_LIST *pToolEdges,    \nBODY_TAG        target,         \nBODY_TAG        tool,           \ndouble          tolerance,      \nbool            imprintTool     \n);\n\nENTITYUTIL_EXPORT bool atSolid_isSmartObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetOrSolidObject (ATEC::ATDataCore::ATObjectDescrP odP, ATEC::ATDataCore::ATSceneRefP SceneRef);\n\nENTITYUTIL_EXPORT bool atSolid_isSceneerObject (ATEC::ATDataCore::ATObjectDescrP odP);\n\nENTITYUTIL_EXPORT bool atSolid_isSheetBody (BODY_TAG bodyTag);\n\nENTITYUTIL_EXPORT bool atSolid_isWireBody (BODY_TAG bodyTag);\n\nENTITYUTIL_EXPORT bool atSolid_isFace (ENTITY_TAG entityTag);\n\nENTITYUTIL_EXPORT bool atSolid_isEdge (ENTITY_TAG entityTag);\n\n/**\n* @brief 获取FACE_TYPE\n* @details 返回FACE_TYPE常数\n* \n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_faceType ();\n\n/**\n* @brief 获取EDGE_TYPE\n* @details 返回EDGE_TYPE常数\n* \n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_edgeType ();\n\nENTITYUTIL_EXPORT void atSolid_moveBoresiteToEyePoint\n(\nATEC::XPoint3d        *pBorePoint,\nATEC::XPoint3d        *pBoreDirection,\nBODY_TAG        pBody\n);\n\nENTITYUTIL_EXPORT void atSolid_displayFace\n(\nTransDescrP     *transientPP,   \nFACE_TAG        faceP,\nbool            display,\nbool            showSmoothFaces,\nint             allowedFaceTypeMask,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             weight,\nint             style\n);\n\nENTITYUTIL_EXPORT void atSolid_displayEdge\n(\nTransDescrP     *transientPP,   \nEDGE_TAG        edgeP,          \nbool            display,        \nSmoothEdgeType  smoothSequence, \nbool            showStart,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             weight,\nint             style\n);\n\nENTITYUTIL_EXPORT int atSolid_createMark\n(\nint             *markP\n);\n\nENTITYUTIL_EXPORT int atSolid_gotoMark\n(\nint             mark\n);\n\nENTITYUTIL_EXPORT int atSolid_deleteMark\n(\nint             mark\n);\n\nENTITYUTIL_EXPORT void atSolid_getBoresiteWithBodyTransform\n(\nATEC::XPoint3dP       borePointP,         \nATEC::XPoint3dP       boreDirectionP,     \nATEC::XPoint3dCP      pntP,             \nint             view,               \nATEC::ATDataCore::ATSceneRefP    SceneRef,           \nATEC::TransformCP     bodyTransformP,     \nbool            useACS,             \nbool            frontClipBorePoint  \n);\n\nENTITYUTIL_EXPORT void atSolid_displayFaceWithBodyTransform\n(\nTransDescrP     *transientPP,       \nFACE_TAG        faceP,\nATEC::TransformP      bodyTransformP,     \nbool            display,\nbool            showSmoothFaces,\nint             nIsoParametrics,    \nint             allowedFaceTypeMask,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nint             color,\nint             style,\nint             weight\n);\n\nENTITYUTIL_EXPORT void atSolid_displayEdgeWithBodyTransform\n(\nTransDescrP     *transientPP,       \nEDGE_TAG        edgeP,              \nATEC::TransformP      bodyTransformP,     \nbool            display,            \nSmoothEdgeType  smoothSequence,     \nbool            showStart,\nATEC::ATDataCore::ATSceneRefP    SceneRef,\nATEC::ATDataCore::ATObjectP      tempP,\nUInt32          color,\nlong            style,\nUInt32          weight,\nbool            showAllEdgesWithSameId\n);\n\nENTITYUTIL_EXPORT int atSolid_getSharedEdgesOfFaces\n(\nTAG_ENTITY_LIST     *edgeListP,\nTAG_ENTITY_LIST     *faceListP\n);\n\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_getBSplineFromSmartSurface\n(\nATEC::ATBsplineSurface*   pBSurface,\nBODY_TAG            bodyP\n);\n\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_getBSplineFromSmartSurface2\n(\nATEC::ATBsplineSurface*   pBSurface,\nBODY_TAG            bodyP,\nATEC::TransformP          bodyTransformP,\nATEC::ATDataCore::ATSceneRefP        SceneRef\n);\n\n#define     SOLIDTEMPLATE_OPTION_None               0\n#define     SOLIDTEMPLATE_OPTION_PreserveElemId     1\n#define     SOLIDTEMPLATE_OPTION_PrimaryClass       2\n\nENTITYUTIL_EXPORT ATEC::ATDataCore::ATObjectP  atSolid_createBrepTemplateForOdP\n(\nATEC::ATDataCore::ATObjectP          objectP,   \nATEC::ATDataCore::ATObjectDescrCP    odP,        \nUInt32              options     \n);\n\n/**\n* @brief 沿线拉伸体\n* @details 沿着输入的线体拉伸线体或薄面体\n* \n* @param BODY_TAG * bodyP\n* @param BODY_TAG wireBody\n* @param ATEC::XPoint3d * pathStartP\n* @param double shell\n* @param bool capped\n* @param ATEC::ATDataCore::ATSceneRefP SceneRef\n* @return int\n*\n* @author SZEWEC\n* @since 2022/04/22\n*/\nENTITYUTIL_EXPORT int atSolid_sweepBodyWire\n(\n\tBODY_TAG        *bodyP,\n\tBODY_TAG        wireBody,\n\tATEC::XPoint3d        *pathStartP,\n\tdouble          shell,\n\tbool            capped,\n\tATEC::ATDataCore::ATSceneRefP    SceneRef\n);\n\n/**\n* @brief 根据面ID从输入的体中寻找面\n* \n* @param FACE_TAG * faceP \n* @param ATEC::FaceId * faceIdP \n* @param BODY_TAG body \n* @return ENTITYUTIL_EXPORT int \n*\n* @author SZEWEC\n* @since 2022/04/29\n*/\nENTITYUTIL_EXPORT int atSolid_faceFromId\n(\n\tFACE_TAG        *faceP,\n\tATEC::FaceId          *faceIdP,\n\tBODY_TAG        body\n);\n\n/**\n* @brief 使用输入的边生成元素,当元素代表边的一部分的时候该接口接收一个起始和终止参数\n* \n* @param ATEC::ATDataCore::ATObjectDescrH edPP\t\t生成的元素\n* @param ATEC::ATDataCore::ATObjectP templateP\t\t生成元素的模板,传NULL时使用默认样式\n* @param EDGE_TAG edge\t\t\t\t\t\t\t\t边\n* @param double * startParameterP\t\t\t\t\t传NULL时使用边的起点,否则为该参数指定的点（位于边上）作为起点\n* @param double * endParameterP\t\t\t\t\t\t传NULL时使用边的终点,否则为该参数指定的点（位于边上）作为终点\n* @param ATEC::ATDataCore::ATScenesRefP SceneRef\t生成的元素所在的场景\n* @return ENTITYUTIL_EXPORT int\t\t\t\t\t\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/05\n*/\nENTITYUTIL_EXPORT int atSolid_elementFromEdge\n(\n\tATEC::ATDataCore::ATObjectDescrH edPP,\n\tATEC::ATDataCore::ATObjectP      tempP,\n\tEDGE_TAG        edge,\n\tdouble          *startParameterP,\n\tdouble          *endParameterP,\n\tATEC::ATDataCore::ATSceneRefP    SceneRef\n);\n\n/**\n* @brief 将给定的曲线压印到实体上\n*\n* @param TAG_ENTITY_LIST * pImprintList\t\t[out] 压印到实体上的结果曲线,或者NULL\n* @param BODY_TAG body\t\t\t\t\t\t[in ] 实体\n* @param TAG_ENTITY_LIST * pEdgeList\t\t[in ] 待压印的曲线\n* @param ATEC::XPoint3d * pVector\t\t\t[in ] 压印（投影）的方向\n* @param double tolerance\t\t\t\t\t[in ] 容差,用于解决容差问题与计算参数空间曲线需要\n* @return ENTITYUTIL_EXPORT ATEC::StatusInt\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/30\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintCurveSet\n(\n\tTAG_ENTITY_LIST *pImprintList,\n\tBODY_TAG        body,\n\tTAG_ENTITY_LIST *pEdgeList,\n\tATEC::XPoint3d        *pVector,\n\tdouble          tolerance\n);\n\n/**\n* @brief 将给定的曲线沿着面的法线方向压印到实体上\n*\n* @param TAG_ENTITY_LIST * pImprintList\t\t[out] 压印到实体上的结果曲线,或者NULL\n* @param BODY_TAG body\t\t\t\t\t\t[in ] 实体\n* @param TAG_ENTITY_LIST * pEdgeList\t\t[in ] 待压印的曲线\n* @param double tolerance\t\t\t\t\t[in ] 容差,用于解决容差问题与计算参数空间曲线需要\n* @return ENTITYUTIL_EXPORT ATEC::StatusInt\t成功时返回SUCCESS\n*\n* @author SZEWEC\n* @since 2022/08/30\n*/\nENTITYUTIL_EXPORT ATEC::StatusInt atSolid_imprintCurveNormal\n(\n\tTAG_ENTITY_LIST *pImprintList,\n\tBODY_TAG        body,\n\tTAG_ENTITY_LIST *pEdgeList,\n\tdouble          tolerance\n);\n\n\n code of file CreateEntityExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nenum class BooleanEnum\n{\n\tIntersect = 0,//求交\n\tSubtract,//求差\n\tUnion//求并\n};\n\nenum class EntityExampleCMDType\n{\n\tCreateEntity = 0,\n\tBooleanIntersectExample,\n\tBooleanUnionExample,\n\tBooleanSubtractExample,\n\tBlendEdgesExample,\n\tBooleanCutExample,\n\tSewBodiesExample,\n\tEvaluateVertexExample,\n};\n\nclass CreateEntityExamples\n{\nprivate:\n\t/************************************\n\t* Desc: 创建体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void CreateEntity();\n\n\t/************************************\n\t* Desc: 求交\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanIntersectExample();\n\n\t/************************************\n\t* Desc: 求并\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanUnionExample();\n\n\t/************************************\n\t* Desc: 求差\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanSubtractExample();\n\n\t/************************************\n\t* Desc: 倒圆角\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BlendEdgesExample();\n\n\t/************************************\n\t* Desc: 面剪切体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void BooleanCutExample();\n\n\t/************************************\n\t* Desc: 缝合体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void SewBodiesExample();\n\n\t/************************************\n\t* Desc: 提取顶点\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic void EvaluateVertexExample();\n\n\t/************************************\n\t* Desc: 创建圆台\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCircularEntity();\n\n\t/************************************\n\t* Desc: 创建圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr GetCircle();\n\n\t/************************************\n\t* Desc: 变换圆\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic CurveSetPtr TransformCircle(CurveSetPtr crvPtr);\n\n\t/************************************\n\t* Desc: 创建长方体\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ISolidCoreEntityPtr GetCuboidEntity();\n\n\t/************************************\n\t* Desc: 布尔运算示例\n\t** [return] void\n\t* SZEWEC      2023/07/27\n\t************************************/\n\tstatic ATECStatus BooleanExample(BooleanEnum booleanEnum);\n\npublic:\n\tSSDPATLoad_EXPORT static void EntityExampleCmd(EntityExampleCMDType cmdType);\n};", "output": "\nATECStatus CreateEntityExamples::BooleanExample(BooleanEnum booleanEnum)\n{\n    ISolidCoreEntityPtr circularEntityPtr = GetCircularEntity();//圆台\n    ISolidCoreEntityPtr cuboidEntityPtr = GetCuboidEntity();//长方()\n    xvector<ISolidCoreEntityPtr> tools = { circularEntityPtr };\n    ATECStatus status = ATECStatus::ERROR;\n    switch (booleanEnum)\n    {\n    case BooleanEnum::Intersect:\n        status = EntityUtl::Modify::BooleanIntersect(cuboidEntityPtr, tools.data(), tools.size());\n        break;\n    case BooleanEnum::Subtract:\n        status = EntityUtl::Modify::BooleanSubtract(cuboidEntityPtr, tools.data(), tools.size());\n        break;\n    case BooleanEnum::Union:\n        status = EntityUtl::Modify::BooleanUnion(cuboidEntityPtr, tools.data(), tools.size());\n        break;\n    default:\n        break;\n    }\n\n    //获得当前激活的场景\n    ATSceneRefP pSceneref = atSceneRef_getActive();\n    if (pSceneref == nullptr)\n        return ATECStatus::ERROR;\n\n    HEATObject cuboidObj;\n    GeometryToATObject::ToObject(cuboidObj, *cuboidEntityPtr, nullptr, *pSceneref);\n    if (cuboidObj.IsValid())\n        cuboidObj.AddToScene();\n\n    return ATECStatus::ATISUCCESS;\n}\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};. You need to implement the function CreateXSegment in the interface. Here are some apis that you can use and remember:\n code of file IBasicCurve.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 基本线元类\n* @author SZEWC\n* @since 2022/04/28\n*/\nstruct IBasicCurve : public RefCountedBase\n{\nprivate: virtual void IAmAbstractClass() = 0;\n\npublic:\n\tenum BasicCurveType\n\t{\n\t\tBCURVE_TYPE_Invalid = 0,\n\t\tBCURVE_TYPE_Line = 1,\n\t\tBCURVE_TYPE_LineString = 2,\n\t\tBCURVE_TYPE_Arc = 3,\n\t\tBCURVE_TYPE_BsplineCurve = 4,\n\t\tBCURVE_TYPE_InterpolationCurve = 5,\n\t\tBCURVE_TYPE_AkimaCurve = 6,\n\t\tBCURVE_TYPE_PointString = 7,\n\t\tBCURVE_TYPE_CurveSet = 8,\n\t\tBCURVE_TYPE_Spiral = 9,\n\t\tBCURVE_TYPE_PartialCurve = 10,\n\t\tBCURVE_TYPE_NotClassified = -1,\n\t};\n\n\tATGEOSET_EXPORT int64_t GetTag() const;\n\n\tATGEOSET_EXPORT int GetIntTag() const;\n\n\tATGEOSET_EXPORT void SetTag(int64_t tag);\n\n\tATGEOSET_EXPORT void SetTag(int tag);\n\n\tATGEOSET_EXPORT CurveSetPtr GetChildCurveSetP();\n\npublic:\n\tATGEOSET_EXPORT xvector<XPoint3d> * GetLineStringP();\n\n\tATGEOSET_EXPORT BasicCurveType           GetBasicCurveType() const;\n\n\tATGEOSET_EXPORT bool TryGetLine(XSegment3dR segment) const;\n\n\tATGEOSET_EXPORT bool TryGetArc(XEllipse3dR arc) const;\n\n\tATGEOSET_EXPORT XSegment3dCP                 GetLineCP() const;\n\n\tATGEOSET_EXPORT xvector<XPoint3d> const* GetLineStringCP() const;\n\n\tATGEOSET_EXPORT bool TryGetSegmentInLineString(XSegment3dR segment, size_t startPointIndex) const;\n\n\tATGEOSET_EXPORT XEllipse3dCP                 GetArcCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurveCP             GetBsplineCurveCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr             GetBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr            GetProxyBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT XSpiral2dPlacementCP         GetSpiralPlacementCP() const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLine(XSegment3dCR segment);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(XPoint3dCP points, size_t nPoints);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(xvector<XPoint3d> const &points);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateArc(XEllipse3dCR ellipse);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurveCR curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurvePtr& curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiral(XSpiral2dBaseCR spiral, TransformCR frame,\n\t\tdouble fractionA, double fractionB);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusBearingRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble endRadians,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusLengthRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble length,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT IBasicCurvePtr Clone() const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneComponent(ptrdiff_t componentIndex) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneAsSingleOffsetPrimitiveXY(CurveOffsetOptionsCR options) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XRay3dR ray) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, CurveDescInfo &detail) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2, XVec3dR derivative3) const;\n\n\tATGEOSET_EXPORT bool FractionToFrenetFrame(double f, TransformR frame) const;\n\n\tATGEOSET_EXPORT bool Length(double &length) const;\n\n\tATGEOSET_EXPORT bool Length(XRotMatrixCP worldToLocal, double &length) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\tATGEOSET_EXPORT size_t NumComponent() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetATBsplineCurvePtr(double fraction0 = 0.0, double fraction1 = 1.0) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(XRotMatrixCP worldToView, double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool TrySetStart(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TrySetEnd(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\tATGEOSET_EXPORT void  AppendCurvePlaneIntersections\n\t(\n\t\tXPlane3dByVectorsCR plane,\n\t\tUVBoundarySelect   bounded,\n\t\txvector<CurveAndSolidDescInfo> &intersections\n\t) const;\n\n\tATGEOSET_EXPORT bool AddStrokes(xvector <XPoint3d> &points, IFacetOptionsR options,\n\t\tbool includeStartPoint = true,\n\t\tdouble startFraction = 0.0,\n\t\tdouble endFraction = 1.0\n\t) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, double &fraction, XPoint3dR curvePoint) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneBetweenFractions(double fractionA, double fractionB, bool allowExtrapolation) const;\n\n\tATGEOSET_EXPORT CurveSetCP            GetChildCurveSetCP() const;\n\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(double startFraction, double endFraction, double &signedDist) const;\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(XRotMatrixCP worldToLocal, double startFraction, double endFraction, double &signedDist) const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateRectangle(double x0, double y0, double x1, double y1, double z, int areaSignPref = 0);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateChildCurveSet(CurveSetPtr source);\n\n\tATGEOSET_EXPORT bool  TryGetPartialCurveData(double &fractionA, double &fractionB, IBasicCurvePtr &parentCurve, int64_t &tag) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XPoint3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n /**\n * @brief 3D绌洪棿鐐圭被\n * @author SZEWC\n * @since 2022/04/13\n*/\nstruct ATGEOSET_EXPORT XPoint3d\n{\n\n\tdouble x;\n\n\tdouble y;\n\n\tdouble z;\n\n\tstatic XPoint3d From(double x, double y, double z = 0.0);\n\n\tstatic XPoint3d From(XPoint2dCR xy);\n\n\tstatic XPoint3d FromZero();\n\n\tstatic XPoint3d FromOne();\n\n\tstatic XPoint3d FromXYZ(double x, double y, double z);\n\n\tvoid Swap(XPoint3dR other);\n\n\tdouble DotDifference(XPoint3dCR origin, XVec3dCR vector) const;\n\n\tvoid Zero();\n\n\tvoid Init(XPoint2dCR source);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double ay);\n\n\tvoid SetComponent(double a, int index);\n\n\tdouble GetComponent(int index) const;\n\n\tvoid Interpolate(XPoint3dCR pnt0, double fractionParameter, XPoint3dCR point1);\n\n\tdouble Distance(XPoint3dCR point2) const;\n\n\tdouble DistanceXY(XPoint3dCR point2) const;\n\n\tbool DistanceXY(XPoint3dCR otherPoint, XMatrix4dCP matrix, double &distance) const;\n\n\tbool IsEqual(XPoint3dCR point2) const;\n\n\tbool IsEqual(XPoint3dCR point2, double tolerance) const;\n\n\tbool IsDisconnect() const;\n\n\tvoid InitDisconnect();\n\n\tvoid Init(XVec3dCR vector);\n\n\tvoid Subtract(XPoint3dCR base, XVec3dCR vector);\n\n\tvoid Add(XVec3dCR vector);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2, XVec3dCR point3, double scale3);\n\n\tvoid CrossProduct(XPoint3dCR point1, XPoint3dCR point2);\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble AngleTo(XPoint3dCR point2) const;\n\n\tvoid RotateXY(XPoint3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tdouble MagnitudeXY() const;\n\n\tvoid Scale(XPoint3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XPoint3dCR vector);\n\n\tvoid Negate();\n\n\tdouble Normalize(XPoint3dCR vector);\n\n\tdouble Normalize();\n\n\tvoid Subtract(XPoint3dCR point2);\n\n\tvoid DifferenceOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2, XPoint3dCR point3, double scale3);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2, XPoint3dCR point3, double a3);\n\n\tvoid Add(XPoint3dCR vector);\n\n\tvoid SumOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, XPoint3dCR point);\n\n\tstatic XPoint3d FromInterpolate(XPoint3dCR pntA, double fraction, XPoint3dCR pntB);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector, double scaleFactor);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1, XPoint3dCR point2, double scaleFactor2);\n\n\tstatic XPoint3d FromScale(XPoint3d point, double scale);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, XVec3dCR vector);\n\n\tbool AlmostEqual(XPoint3d const & dataB) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB) const;\n\n\tbool AlmostEqual(XPoint3d const & dataB, double abstol) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB, double abstol) const;\n\n\tstatic bool AlmostEqual(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tstatic bool AlmostEqualXY(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tdouble DistanceSquared(XPoint3dCR point2) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file CreateGeometryExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};\n code of file CurveSet.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 线串类\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct CurveSet : RefCountedBase, xvector<IBasicCurvePtr>\n{\n\n\tenum BoundaryType\n\t{\n\n\t\tBOUNDARY_TYPE_None = 0,\n\n\t\tBOUNDARY_TYPE_Open = 1,\n\n\t\tBOUNDARY_TYPE_Outer = 2,\n\n\t\tBOUNDARY_TYPE_Inner = 3,\n\n\t\tBOUNDARY_TYPE_ParityRegion = 4,\n\n\t\tBOUNDARY_TYPE_UnionRegion = 5,\n\t};\n\n\tenum InOutClassification\n\t{\n\t\tINOUT_Unknown = 0,\n\t\tINOUT_In = 1,\n\t\tINOUT_Out = 2,\n\t\tINOUT_On = 3\n\t};\n\nprotected:\n\tBoundaryType    m_boundaryType;\n\npublic:\n\t/**\n\t* @brief 设定边界\n\t* @details 设定曲线的边界类型\n\t* \n\t* @param BoundaryType BoundaryType\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void SetBoundaryType(BoundaryType BoundaryType);\n\n\t/**\n\t* @brief 获取叶节点\n\t* @details 通过只计算叶节点的索引深度搜索以获取目标叶节点\n\t* \n\t* @param size_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr FindIndexedLeaf(size_t index) const;\n\n\t/**\n\t* @brief 获取索引值\n\t* @details 深度搜索以获取给定叶节点的索引值\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @param size_t & index\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool LeafToIndex(IBasicCurveCP primitive, size_t &index) const;\n\n\t/**\n\t* @brief 获取叶节点个数\n\t* @details 获取曲线的叶节点个数\n\t* \n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesBelow() const;\n\n\texplicit CurveSet(BoundaryType boundaryType) { m_boundaryType = boundaryType; }\n\n\t/**\n\t* @brief 是否单元素曲线\n\t* @details 查询曲线是否只有一个基本元素\n\t* \n\t* @return IBasicCurve\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurve::BasicCurveType HasSingleBasicCurve() const;\n\n\t/**\n\t* @brief 获取边界类型\n\t* @details 获取曲线的边界类型\n\t* \n\t* @return BoundaryType\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT BoundaryType GetBoundaryType() const;\n\n\t/**\n\t* @brief 查询是否开\n\t* @details 查询是否开路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsOpenPath() const;\n\n\t/**\n\t* @brief 查询是否闭\n\t* @details 查询是否闭路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsClosedPath() const;\n\n\t/**\n\t* @brief 查询实际开闭\n\t* @details 查询是否名义上是开路径但起点和终点连接\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsPhysicallyClosedPath() const;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个带有给定边界类型没有成员的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个具有单个基本元素和给定边界类型的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @param IBasicCurvePtr primitive\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType, IBasicCurvePtr primitive);\n\n\t/**\n\t* @brief 拷贝\n\t* @details 返回一个深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr Clone() const;\n\n\t/**\n\t* @brief 倒角拷贝\n\t* @details 返回一个深度拷贝,在连续曲线之间插入圆角\n\t* \n\t* @param double radius\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithFillets(double radius) const;\n\n\t/**\n\t* @brief 闭合拷贝\n\t* @details 返回一个深度拷贝,闭合终端点的间隙\n\t* \n\t* @param CurveGapOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithGapsClosed(CurveGapOptionsCR options) const;\n\n\t/**\n\t* @brief 添加元素\n\t* @details 递归遍历source, 将所有叶节点添加到this, 返回添加的数量\n\t* \n\t* @param CurveSetCR source\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t AddPrimitives(CurveSetCR source);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 添加单个基本曲线\n\t* \n\t* @param IBasicCurvePtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(IBasicCurvePtr child);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 将chile的所有元素作为曲线成员添加\n\t* \n\t* @param CurveSetPtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(CurveSetPtr child);\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过XY方向的偏移后的深度拷贝\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneOffsetCurvesXY(CurveOffsetOptionsCR options);\n\n\t/**\n\t* @brief 获取叶节点数量\n\t* @details 计算指定类型的叶节点数量\n\t* \n\t* @param IBasicCurve::BasicCurveType targetType\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesOfType(IBasicCurve::BasicCurveType targetType) const;\n\n\t/**\n\t* @brief 用区域分割曲线\n\t* @details 用指定区域分割曲线,分别返回区域内、外和区域上的曲线\n\t* \n\t* @param CurveSetCR region\n\t* @param CurveSetP insideCollector\n\t* @param CurveSetP outsideCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByRegion(CurveSetCR region, CurveSetP insideCollector, CurveSetP outsideCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 用平面分割曲线\n\t* @details 用指定平面分割曲线,分别返回平面上方、下方和平面内的曲线\n\t* \n\t* @param XPlane3dCR plane\n\t* @param CurveSetP belowCollector\n\t* @param CurveSetP aboveCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByPlane(XPlane3dCR plane, CurveSetP belowCollector, CurveSetP aboveCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 拆分拷贝\n\t* @details 返回一个深度拷贝,但所有的多线段被拆分成单条线段\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithExplodedLinestrings() const;\n\n\t/**\n\t* @brief 获取质心\n\t* @details 返回包含曲线的质心(不考虑孤立点)\n\t* \n\t* @param double & length\n\t* @param XPoint3dR centroid\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  WireCentroid(double &length, XPoint3dR centroid) const;\n\n\t/**\n\t* @brief 获取质心、法向量和面积\n\t* @details 返回质心、法向量和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param XVec3dR normal\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CentroidNormalArea(XPoint3dR centroid, XVec3dR normal, double &area) const;\n\n\t/**\n\t* @brief 获取质心和面积\n\t* @details 返回XY平面方向上的质心和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  CentroidAreaXY(XPoint3dR centroid, double &area) const;\n\n\t/**\n\t* @brief 投影范围\n\t* @details 当投影到射线的时候,返回射线参数的范围\n\t* \n\t* @param XRay3dCR ray\n\t* @return XRange1d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT XRange1d ProjectedParameterRange(XRay3dCR ray) const;\n\n    /**\n    * @brief 局部坐标拷贝\n    * @details 返回曲线的深度复制并转换为与曲线相关联的局部坐标系统。\n    * \n    * @param LocalCoordinateSelect frameType\n    * @param TransformR localToWorld\n    * @param TransformR worldToLocal\n    * @param XRange3dR localRange\n    * @return CurveSetPtr\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT CurveSetPtr CloneInLocalCoordinates\n    (\n    LocalCoordinateSelect frameType,\n    TransformR localToWorld,\n    TransformR worldToLocal,\n    XRange3dR localRange\n    ) const;\n\n\t/**\n    * @brief 获取有坐标系的元素\n    * @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame) const;\n\n\t/**\n\t* @brief 获取有坐标系的元素\n\t* @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @param int searchPreference\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame, int srchPref) const;\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param xvector<XPoint3d> const & points\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(xvector<XPoint3d> const&points,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint3dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint3dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建多边形\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint2dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint2dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建矩形\n\t* @details 根据 XY 坐标创建矩形\n\t* \n\t* @param double x0\n\t* @param double y0\n\t* @param double x1\n\t* @param double y1\n\t* @param double z\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateRectangle(double x0, double y0, double x1, double y1, double z,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由给定线段创建边界类型为 BOUNDARY_TYPE_None 的曲线\n\t* \n\t* @param xvector<XSegment3d> const & segments\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(xvector<XSegment3d> const &segs);\n\n\t/**\n\t* @brief 创建圆盘\n\t* @details 为一个完整的椭圆(圆)盘创建一个曲线向量结构\n\t* \n\t* @param XEllipse3dCR arc\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateDisk(XEllipse3dCR arc, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer, bool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个仅有单一元素的曲线结构\n\t* \n\t* @param IBasicCurvePtr child\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(IBasicCurvePtr child, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open);\n\n\t/**\n\t* @brief B样条拷贝\n\t* @details 返回一个深度拷贝,作为B样条曲线\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneAsBsplines() const;\n\n\t/**\n\t* @brief 添加边缘点\n\t* @details 为所有的子节点添加边缘点\n\t* \n\t* @param xvector <XPoint3d> & points\n\t* @param IFacetOptionsR options\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AddStrokePoints(xvector <XPoint3d> &points, IFacetOptionsR options) const;\n\n    /**\n\t* @brief 添加面点\n\t* @details 沿着曲线计算指定距离的点\n\t* \n\t* @param xvector<double> const & distances\n\t* @param xvector<CurveDescInfo> & locations\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool AddSpacedPoints(xvector<double> const &distances, xvector<CurveDescInfo> &locations) const;\n\n\t/**\n\t* @brief 添加边缘\n\t* @details 在结构中添加所有边缘\n\t* \n\t* @param xvector <xvector<xvector<XPoint3d>>> & regionsPoints\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CollectLinearGeometry(xvector <xvector<xvector<XPoint3d>> > &regionsPoints) const;\n\n\t/**\n\t* @brief 获取B样条曲线\n\t* @details 将一个表示开放或闭合路径作为单个B样条曲线\n\t* \n\t* @return ATBsplineCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetBsplineCurve() const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n    /**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索最接近曲线的点。如果曲线是一个区域类型,同时要在该区域的内部寻找投影\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XPoint3dR curveOrRegionPoint\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification ClosestCurveOrRegionPoint(XPoint3dCR spacePoint, XPoint3dR curveOrRegionPoint) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点和终点\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点终点和他们的正切值\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @param XVec3dR unitTangentA\n\t* @param XVec3dR unitTangentB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\t/**\n\t* @brief 获取起点\n\t* @details 返回曲线的起点\n\t* \n\t* @param XPoint3dR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线总长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length() const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线经过变换后的总长度\n\t* \n\t* @param XRotMatrixCP worldToLocal\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length(XRotMatrixCP worldToLocal) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线的xyz范围\n\t* \n\t* @param XRange3dR range\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线经过变换后的范围\n\t* \n\t* @param XRange3dR range\n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\t/**\n\t* @brief 查询索引\n\t* @details 返回指定元素的索引\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t FindIndexOfPrimitive(IBasicCurveCP primitive) const;\n\n\t/**\n\t* @brief 复制曲线指定范围的曲线\n\t* @details 复制曲线指定索引和比例参数范围内的部分\n\t* \n\t* @param int index0\n\t* @param double fraction0\n\t* @param int index1\n\t* @param double fraction1\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n    ATGEOSET_EXPORT CurveSetPtr CloneBetweenCyclicIndexedFractions(int index0, double fraction0, int index1, double fraction1) const;\n\n\t/**\n\t* @brief 反转拷贝\n\t* @details 返回一个所有元素都被反转的深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneReversed() const;\n\n\t/**\n\t* @brief 查询是否包含非线性元素\n\t* @details 如果曲线有一个不非线性元素,则返回true。\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ContainsNonLinearPrimitive() const;\n\n\t/**\n\t* @brief 计算交点\n\t* @details 计算曲线与给定平面的交点\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 平面选中\n\t* @details 计算封闭曲线与平面的交叉点,并以奇偶性规则为设为起始对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param double tolerance\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr PlaneSection(XPlane3dCR plane, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 空间点位置情况\n\t* @details 当以XY平面视角看,测试给定点在曲线内、曲线上还是曲线外\n\t* \n\t* @param XPoint3dCR xyz\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification PointInOnOutXY(XPoint3dCR xyz) const;\n\n\t/**\n\t* @brief 射线击中情况\n\t* @details 测试射线击中曲线在区域内、区域上还是区域外\n\t* \n\t* @param XRay3dCR ray\n\t* @param SolidDescInfoR hitDetail\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification RayPierceInOnOut\n\t(\n\t\tXRay3dCR ray,\n\t\tSolidDescInfoR hitDetail\n\t) const;\n\n\t/**\n\t* @brief 原地变换\n\t* @details 应用给定变换并修改曲线\n\t* \n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\t/**\n\t* @brief 原地反转\n\t* @details 将所有元素进行反转\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串内的单个点被消除,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串相邻的空间点被消除（可选）,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @param bool doSimplifyLinestrings\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives(bool doSimplifyLinestrings);\n\n\t/**\n\t* @brief 原地修改以简化线串\n\t* @details 消除线串相邻的空间点\n\t* \n\t* @param double distanceTol\n\t* @param bool eliminateOverdraw\n\t* @param bool wrap\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void SimplifyLinestrings(double distTol, bool eliminateOverdraw, bool wrap);\n\n\t/**\n\t* @brief 重排元素\n\t* @details 将曲线元素重新排序以缩小元素首尾相连的间隙\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT double ReorderForSmallGaps();\n\n\t/**\n\t* @brief 链接元素\n\t* @details 将曲线的元素首尾相连\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AssembleChains();\n\n\t/**\n\t* @brief 区域相并\n\t* @details 返回给定两个区域的并\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaUnion(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相减\n\t* @details 返回给定两个区域的减\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaDifference(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相交\n\t* @details 返回给定两个区域的交\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaIntersection(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 循环索引\n\t* @details 返回给定索引值关于集合大小的模\n\t* \n\t* @param int index\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT size_t CyclicIndex(int index) const;\n\n\t/**\n\t* @brief 循环获取值\n\t* @details 根据给定索引的循环索引获取元素\n\t* \n\t* @param ptrdiff_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr GetCyclic(ptrdiff_t index) const;\n\n    /**\n    * @brief 获取索引\n    * @details 返回给定曲线元素的详细细节所对应的元素索引\n    * \n    * @param CurveDescInfo const & location\n    * @return size_t\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT size_t CurveDescInfoIndex(CurveDescInfo const& location) const;\n\n\t/**\n\t* @brief 与平面相交\n\t* @details 计算封闭曲线与平面的交叉点,返回以奇偶性规则构造的起止点对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool AppendClosedCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过给定偏移后的深度拷贝.\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AreaOffset(CurveOffsetOptionsCR options) const;\n\n\t/**\n\t* @brief 返回从index0,fraction0到index1,fraction1的曲线段\n\t* \n\t* @param int index0 \n\t* @param double fraction0 \n\t* @param int index1 \n\t* @param double fraction1 \n\t* @param bool allowExtrapolation \n\t* @return ATGEOSET_EXPORT CurveSetPtr \n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/17\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneBetweenDirectedFractions(int index0, double fraction0, int index1, double fraction1, bool allowExtrapolation) const;\n\n\t/**\n\t* @brief 返回输入的曲线的布尔奇运算结果（区域）\n\t*\n\t* @param CurveSetCR regionA\t\t\t\t\t左操作数\n\t* @param CurveSetCR regionB\t\t\t\t\t右操作数\n\t* @param BasicCurvePtrPairVector * newToOld\t（可选）包含新旧曲线的数组指针\n\t* @return ATGEOSET_EXPORT CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/07/22\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaParity(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n};\n\nstruct CurveCurve\n{\nprivate: CurveCurve();\npublic:\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tCurveSetR curveA,\n\t\tCurveSetR curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB,\n\t\tXMatrix4dCP    pWorldToLocal,\n\t\tbool         extend = false\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveR curveA,\n\t\tCurveSetR     curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tCurveSetCR chainA,\n\t\tCurveSetCR chainB\n\t);\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            double &fractionA,\n            XPoint3dR pntA,\n            double &fractionB,\n            XPoint3dR pntB\n            );\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            CurveDescInfoR detailA,\n            CurveDescInfoR detailB\n            );\n};\n\nstruct PathLocationDetail\n{\nprivate:\n\tCurveDescInfo m_curveDetail;\n\tint32_t m_pathIndex;\n\tdouble m_pathDistance;\npublic:\n\n\tATGEOSET_EXPORT PathLocationDetail();\n\n\tATGEOSET_EXPORT PathLocationDetail(PathLocationDetail const &other);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, int pathIndex = -1, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, size_t pathIndex, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(double distance);\n\n\tATGEOSET_EXPORT XPoint3d Point() const;\n\n\tATGEOSET_EXPORT CurveDescInfo GetCurveDescInfo() const;\n\n    ATGEOSET_EXPORT double DistanceFromPathStart() const;\n};\n\nstruct CurveSetWithDistanceIndex : RefCountedBase\n{\nprivate:\n\n\tstruct PathEntry : PathLocationDetail\n\t{\n\t\tdouble             m_projectedDistance;\n\t\tXRange3d           m_range;\n\t\tPathEntry(PathLocationDetail const &pathDetail, double projectedDist, XRange3dCR range)\n\t\t\t: PathLocationDetail(pathDetail),\n\t\t\tm_projectedDistance(projectedDist),\n\t\t\tm_range(range)\n\t\t{\n\t\t}\n\t\tPathEntry(double distance) : PathLocationDetail(distance), m_projectedDistance(distance) {}\n\n\t\tdouble GetDistance(bool projected) const;\n\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistanceXY(PathEntry const &dataA, PathEntry const &dataB);\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistance(PathEntry const &dataA, PathEntry const &dataB);\n\t};\n\n\tCurveSetPtr m_curveVector;\n\txvector<PathEntry> m_locations;\n\tCurveSetPtr m_savedPrimitives;\n\n\tXRotMatrix m_worldToViewRotMatrix;\n\tXRotMatrix m_viewToWorldRotMatrix;\n\tXRotMatrix m_flattenToView;\n\tXMatrix4d m_worldToView;\n\n\texplicit CurveSetWithDistanceIndex(XRotMatrix worldToView);\n\n\tCurveSetWithDistanceIndex();\n\npublic:\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create(XRotMatrix worldToView);\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create();\n\n\tATGEOSET_EXPORT void SetPath(CurveSetPtr &path);\n\n\tATGEOSET_EXPORT bool SearchByDistanceFromPathStart\n\t(\n\t\tdouble targetDist,\n\t\tPathLocationDetail &detail\n\t) const;\n\n    ATGEOSET_EXPORT PathLocationDetail SearchClosestPointBounded\n    (\n    XPoint3dCR spacePoint,\n    bool computeDistAlong\n    ) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XSegment3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n /**\n * @brief 三维线段类\n * @author SZEWC\n * @since 2022/04/14\n*/\nstruct ATGEOSET_EXPORT XSegment3d\n{\n\n\tXPoint3d point[2];\n\n\t/**\n\t* @brief 创建函数\n\t* @details 根据起点和延伸向量创建线段\n\t* \n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR tangent\n\t* @return XSegment3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic XSegment3d FromOriginAndDirection\n\t(\n\t\tXPoint3dCR      pnt0,\n\t\tXPoint3dCR      tangent\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个所有坐标都为零的线段\n\t* \n\t* @return XSegment3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic XSegment3d FromZero();\n\n\tvoid InitProduct(TransformCR transform, XSegment3dCR other);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由射线创建线段\n\t* \n\t* @param XRay3dCR ray\n\t* @return XSegment3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic XSegment3d From(XRay3dCR ray);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由起止点坐标创建线段\n\t* \n\t* @param double x0\n\t* @param double y0\n\t* @param double z0\n\t* @param double x1\n\t* @param double y1\n\t* @param double z1\n\t* @return XSegment3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic XSegment3d From\n\t(\n\t\tdouble          x0,\n\t\tdouble          y0,\n\t\tdouble          z0,\n\t\tdouble          x1,\n\t\tdouble          y1,\n\t\tdouble          z1\n\t);\n\n\t/**\n    * @brief 创建函数\n    * @details 由起止点创建线段\n\t* \n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point1\n\t* @return XSegment3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic XSegment3d From\n\t(\n\t\tXPoint3dCR      pnt0,\n\t\tXPoint3dCR      point1\n\t);\n\n\t/**\n    * @brief 创建函数\n    * @details 由2D起止点创建线段\n\t* \n\t* @param XPoint2dCR point0\n\t* @param XPoint2dCR point1\n\t* @return XSegment3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic XSegment3d From(XPoint2dCR pnt0, XPoint2dCR point1);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由起止点坐标创建初始化数据\n\t* \n\t* @param double x0\n\t* @param double y0\n\t* @param double z0\n\t* @param double x1\n\t* @param double y1\n\t* @param double z1\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid Init\n\t(\n\t\tdouble          x0,\n\t\tdouble          y0,\n\t\tdouble          z0,\n\t\tdouble          x1,\n\t\tdouble          y1,\n\t\tdouble          z1\n\t);\n\n\t/**\n    * @brief 初始化数据\n\t* @details 由起止点初始化数据\n\t* \n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point1\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid Init\n\t(\n\t\tXPoint3dCR      pnt0,\n\t\tXPoint3dCR      point1\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由2D起止点坐标初始化数据\n\t* \n\t* @param XPoint2dCR point0\n\t* @param XPoint2dCR point1\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid Init\n\t(\n\t\tXPoint2dCR      pnt0,\n\t\tXPoint2dCR      point1\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由起始点和延伸向量初始化数据\n\t* \n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR tangent\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid InitFromOriginAndDirection\n\t(\n\t\tXPoint3dCR      pnt0,\n\t\tXPoint3dCR      tangent\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由给定射线初始化数据\n\t* \n\t* @param XRay3dCR ray\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid InitFrom(XRay3dCR ray);\n\n\t/**\n\t* @brief 获取端点\n\t* @details 返回线段的两个端点\n\t* \n\t* @param XPoint3dR point0\n\t* @param XPoint3dR point1\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid GetEndPoints\n\t(\n\t\tXPoint3dR       pnt0,\n\t\tXPoint3dR       point1\n\t) const;\n\n\t/**\n\t* @brief 计算范围\n\t* @details 计算线段的范围盒,总是返回true\n\t* \n\t* @param XRange3dR range\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tbool GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief 投影点\n\t* @details 将给定点投影到延伸后的线段上\n\t* \n\t* @param XPoint3dR closestPoint\n\t* @param double & closestParam\n\t* @param XPoint3dCR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tbool ProjectPoint\n\t(\n\t\tXPoint3dR       closestPoint,\n\t\tdouble          &closestParam,\n\t\tXPoint3dCR      point\n\t) const;\n\n\t/**\n\t* @brief 投影点\n\t* @details 仅在XY方向上将给定点投影到延伸后的线段上\n\t* \n\t* @param XPoint3dR closestPoint\n\t* @param double & closestParam\n\t* @param XPoint3dCR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tbool ProjectPointXY\n\t(\n\t\tXPoint3dR       closestPoint,\n\t\tdouble          &closestParam,\n\t\tXPoint3dCR      point\n\t) const;\n\n\t/**\n\t* @brief 计算交点\n\t* @details 计算（无界）线段与平面的交点\n\t* \n\t* @param XPoint3dR intPoint\n\t* @param double & intParam\n\t* @param XPlane3dCR plane\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tbool Intersect\n\t(\n\t\tXPoint3dR       intPoint,\n\t\tdouble          &intParam,\n\t\tXPlane3dCR      plane\n\t) const;\n\n\t/**\n\t* @brief 获取起点\n\t* @details 返回线段的起点\n\t* \n\t* @param XPoint3dR pt\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid GetStartPoint(XPoint3dR pt) const;\n\n\t/**\n\t* @brief 获取终点\n\t* @details 返回线段的终点\n\t* \n\t* @param XPoint3dR pt\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid GetEndPoint(XPoint3dR pt) const;\n\n\t/**\n\t* @brief 设置起点\n\t* @details 设置线段的起点\n\t* \n\t* @param XPoint3dCR point\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid SetStartPoint(XPoint3dCR point);\n\n\t/**\n\t* @brief 设置终点\n\t* @details 设置线段的终点\n\t* \n\t* @param XPoint3dCR point\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid SetEndPoint(XPoint3dCR point);\n\n\t/**\n\t* @brief 比例到点\n\t* @details 根据比例参数返回线段上的点\n\t* \n\t* @param double fraction\n\t* @return XPoint3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tXPoint3d FractionToPoint(double fraction) const;\n\n\t/**\n\t* @brief 点到比例\n\t* @details 返回空间点对应的比例参数,小于0或大于1意味着在线段外\n\t* \n\t* @param double & param\n\t* @param XPoint3dCR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tbool PointToFractionParameter\n\t(\n\t\tdouble          &param,\n\t\tXPoint3dCR      point\n\t) const;\n\n\t/**\n\t* @brief 比例到切线\n\t* @details 返回线段上给定比例参数对应点的切向量\n\t* \n\t* @param XPoint3dR point\n\t* @param XVec3dR tangent\n\t* @param double param\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tbool FractionParameterToTangent\n\t(\n\t\tXPoint3dR       point,\n\t\tXVec3dR       tangent,\n\t\tdouble          param\n\t) const;\n\n\t/**\n\t* @brief 长度\n\t* @details 计算线段的长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tdouble Length() const;\n\n    /**\n    * @brief 两条有界线段最近的点\n    * \n    * @param double & fraction0\n    * @param double & fraction1\n    * @param XPoint3dR point0\n    * @param XPoint3dR point1\n    * @param XSegment3dCR segment0\n    * @param XSegment3dCR segment1\n    * @return void\n    *\n    * @author SZEWEC\n    * @since 2022/04/27\n    */\n    static void   ClosestApproachBounded\n        (\n        double      &fraction0,\n        double      &fraction1,\n        XPoint3dR    pnt0,\n        XPoint3dR    point1,\n        XSegment3dCR seg0,\n        XSegment3dCR seg1\n        );\n\n\t/**\n\t* @brief 两条线段（视为无界）最近的点\n\t* \n\t* @param double & fraction0\n\t* @param double & fraction1\n\t* @param XPoint3dR point0\n\t* @param XPoint3dR point1\n\t* @param XSegment3dCR segment0\n\t* @param XSegment3dCR segment1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic bool ClosestApproachUnbounded\n\t(\n\t\tdouble      &fraction0,\n\t\tdouble      &fraction1,\n\t\tXPoint3dR    pnt0,\n\t\tXPoint3dR    point1,\n\t\tXSegment3dCR seg0,\n\t\tXSegment3dCR seg1\n\t);\n\n    /**\n    * @brief XY方向上两条有界线段最近的点\n    * \n    * @param double & fraction0\n    * @param double & fraction1\n    * @param XPoint3dR point0\n    * @param XPoint3dR point1\n    * @param XSegment3dCR segment0\n    * @param XSegment3dCR segment1\n    * @return void\n    *\n    * @author SZEWEC\n    * @since 2022/04/27\n    */\n    static void   ClosestApproachBoundedXY\n    (\n    double      &fraction0,\n    double      &fraction1,\n    XPoint3dR    pnt0,\n    XPoint3dR    point1,\n    XSegment3dCR seg0,\n    XSegment3dCR seg1\n    );\n\n\t/**\n\t* @brief XY相交\n\t* @details 计算两条（视为无界）线段仅在XY方向上的交点,当线段平行时返回false\n\t* \n\t* @param double & fractionA\n\t* @param double & fractionB\n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @param XSegment3dCR segmentA\n\t* @param XSegment3dCR segmentB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic bool IntersectXY\n\t(\n\t\tdouble          &fractionA,\n\t\tdouble          &fractionB,\n\t\tXPoint3dR       pntA,\n\t\tXPoint3dR       pntB,\n\t\tXSegment3dCR    segA,\n\t\tXSegment3dCR    segB\n\t);\n\n};\n\nEND_ATEC_NAMESPACE\n\n", "output": "#include \"..\\..\\PublicAPI\\CreateGeometryExamples.h\"\n#include \"..\\..\\PublicAPI\\AddGeometryToSceneUtil.h\"\n\n#pragma region XSegment\nvoid CreateGeometryExamples::CreateXSegment()\n{\n\t//通过两个点创建线段\n\tXPoint3d st = XPoint3d::From(0, -10, 0);\n\tXPoint3d ed = XPoint3d::From(-100, 50, 0);\n\tXSegment3d seg = XSegment3d::From(st, ed);\n\n\t//添加到视口\n\tCurveSetPtr curve = CurveSet::Create(IBasicCurve::CreateLine(seg));\n\tAddGeometryToScene(curve);\n}\n\n#pragma endregion\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};. You need to implement the function CreateXEllipse_FromCenterNormalRadius in the interface. Here are some apis that you can use and remember:\n code of file IBasicCurve.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 基本线元类\n* @author SZEWC\n* @since 2022/04/28\n*/\nstruct IBasicCurve : public RefCountedBase\n{\nprivate: virtual void IAmAbstractClass() = 0;\n\npublic:\n\tenum BasicCurveType\n\t{\n\t\tBCURVE_TYPE_Invalid = 0,\n\t\tBCURVE_TYPE_Line = 1,\n\t\tBCURVE_TYPE_LineString = 2,\n\t\tBCURVE_TYPE_Arc = 3,\n\t\tBCURVE_TYPE_BsplineCurve = 4,\n\t\tBCURVE_TYPE_InterpolationCurve = 5,\n\t\tBCURVE_TYPE_AkimaCurve = 6,\n\t\tBCURVE_TYPE_PointString = 7,\n\t\tBCURVE_TYPE_CurveSet = 8,\n\t\tBCURVE_TYPE_Spiral = 9,\n\t\tBCURVE_TYPE_PartialCurve = 10,\n\t\tBCURVE_TYPE_NotClassified = -1,\n\t};\n\n\tATGEOSET_EXPORT int64_t GetTag() const;\n\n\tATGEOSET_EXPORT int GetIntTag() const;\n\n\tATGEOSET_EXPORT void SetTag(int64_t tag);\n\n\tATGEOSET_EXPORT void SetTag(int tag);\n\n\tATGEOSET_EXPORT CurveSetPtr GetChildCurveSetP();\n\npublic:\n\tATGEOSET_EXPORT xvector<XPoint3d> * GetLineStringP();\n\n\tATGEOSET_EXPORT BasicCurveType           GetBasicCurveType() const;\n\n\tATGEOSET_EXPORT bool TryGetLine(XSegment3dR segment) const;\n\n\tATGEOSET_EXPORT bool TryGetArc(XEllipse3dR arc) const;\n\n\tATGEOSET_EXPORT XSegment3dCP                 GetLineCP() const;\n\n\tATGEOSET_EXPORT xvector<XPoint3d> const* GetLineStringCP() const;\n\n\tATGEOSET_EXPORT bool TryGetSegmentInLineString(XSegment3dR segment, size_t startPointIndex) const;\n\n\tATGEOSET_EXPORT XEllipse3dCP                 GetArcCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurveCP             GetBsplineCurveCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr             GetBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr            GetProxyBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT XSpiral2dPlacementCP         GetSpiralPlacementCP() const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLine(XSegment3dCR segment);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(XPoint3dCP points, size_t nPoints);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(xvector<XPoint3d> const &points);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateArc(XEllipse3dCR ellipse);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurveCR curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurvePtr& curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiral(XSpiral2dBaseCR spiral, TransformCR frame,\n\t\tdouble fractionA, double fractionB);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusBearingRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble endRadians,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusLengthRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble length,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT IBasicCurvePtr Clone() const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneComponent(ptrdiff_t componentIndex) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneAsSingleOffsetPrimitiveXY(CurveOffsetOptionsCR options) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XRay3dR ray) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, CurveDescInfo &detail) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2, XVec3dR derivative3) const;\n\n\tATGEOSET_EXPORT bool FractionToFrenetFrame(double f, TransformR frame) const;\n\n\tATGEOSET_EXPORT bool Length(double &length) const;\n\n\tATGEOSET_EXPORT bool Length(XRotMatrixCP worldToLocal, double &length) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\tATGEOSET_EXPORT size_t NumComponent() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetATBsplineCurvePtr(double fraction0 = 0.0, double fraction1 = 1.0) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(XRotMatrixCP worldToView, double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool TrySetStart(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TrySetEnd(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\tATGEOSET_EXPORT void  AppendCurvePlaneIntersections\n\t(\n\t\tXPlane3dByVectorsCR plane,\n\t\tUVBoundarySelect   bounded,\n\t\txvector<CurveAndSolidDescInfo> &intersections\n\t) const;\n\n\tATGEOSET_EXPORT bool AddStrokes(xvector <XPoint3d> &points, IFacetOptionsR options,\n\t\tbool includeStartPoint = true,\n\t\tdouble startFraction = 0.0,\n\t\tdouble endFraction = 1.0\n\t) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, double &fraction, XPoint3dR curvePoint) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneBetweenFractions(double fractionA, double fractionB, bool allowExtrapolation) const;\n\n\tATGEOSET_EXPORT CurveSetCP            GetChildCurveSetCP() const;\n\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(double startFraction, double endFraction, double &signedDist) const;\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(XRotMatrixCP worldToLocal, double startFraction, double endFraction, double &signedDist) const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateRectangle(double x0, double y0, double x1, double y1, double z, int areaSignPref = 0);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateChildCurveSet(CurveSetPtr source);\n\n\tATGEOSET_EXPORT bool  TryGetPartialCurveData(double &fractionA, double &fractionB, IBasicCurvePtr &parentCurve, int64_t &tag) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XEllipse3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 椭圆弧\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct ATGEOSET_EXPORT XEllipse3d\n{\n\tXPoint3d center;\n\tXVec3d   vector0;\n\tXVec3d   vector90;\n\tdouble start;\n\tdouble sweep;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 返回由已有椭圆的起始和终止比例定义的椭圆弧\n\t* \n\t* @param XEllipse3dCR parent\n\t* @param double startFraction\n\t* @param double endFraction\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromFractionInterval\n\t(\n\t\tXEllipse3dCR parent,\n\t\tdouble startFraction,\n\t\tdouble endFraction\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 根据椭圆的中心点、角度为0度和90度的点,以及扫掠角度创建一个椭圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point90\n\t* @param double theta0\n\t* @param double sweep\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromPoints(XPoint3dCR center, XPoint3dCR pnt0, XPoint3dCR pnt90, double theta0, double sweep);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由起始点,起始切线,半径,扫掠角度和面法向量创建椭圆弧\n\t* \n\t* @param XPoint3dCR pointA\n\t* @param XVec3dCR tangent\n\t* @param XVec3dCR planeNormal\n\t* @param double radius\n\t* @param double sweepRadians\n\t* @return ValidatedXEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic ValidatedXEllipse3d FromStartTangentNormalRadiusSweep(\n\n\t\tXPoint3dCR pntA,\n\t\tXVec3dCR tangent,\n\t\tXVec3dCR planeNormal,\n\t\tdouble radius,\n\t\tdouble sweepRadians\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由弧上的点创建椭圆弧\n\t* \n\t* @param XPoint3dCR start\n\t* @param XPoint3dCR middle\n\t* @param XPoint3dCR end\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromPointsOnArc(XPoint3dCR start, XPoint3dCR middle, XPoint3dCR end);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、起始点和终止点的切线创建椭圆弧（扫掠角取较小的一个）\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endTarget\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromArcCenterStartEnd(XPoint3dCR center, XPoint3dCR startPoint, XPoint3dCR endTarget);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、半径和面法向量创建完整的圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param XVec3dCR normal\n\t* @param double radius\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromCenterNormalRadius(XPoint3dCR center, XVec3dCR normal, double radius);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、半径创建XY平面上完整的圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param double radius\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromCenterRadiusXY(XPoint3dCR center, double radius);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 返回给定椭圆弧以反方向扫掠得到的椭圆弧\n\t* \n\t* @param XEllipse3dCR source\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromReversed(XEllipse3dCR source);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由给定点和扫掠角初始化数据\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point90\n\t* @param double theta0\n\t* @param double sweep\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid InitFromPoints\n\t(\n\t\tXPoint3dCR      center,\n\t\tXPoint3dCR      pnt0,\n\t\tXPoint3dCR      pnt90,\n\t\tdouble          theta0,\n\t\tdouble          sweep\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由椭圆弧上的点初始化数据\n\t* \n\t* @param XPoint3dCR start\n\t* @param XPoint3dCR middle\n\t* @param XPoint3dCR end\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool InitFromPointsOnArc\n\t(\n\t\tXPoint3dCR      start,\n\t\tXPoint3dCR      middle,\n\t\tXPoint3dCR      end\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由中心点、起始点和终止点的切线初始化数据（扫掠角取较小的一个）\n\t* \n\t* @param XPoint3dCR centerIN\n\t* @param XPoint3dCR startIN\n\t* @param XPoint3dCR end\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool InitFromArcCenterStartEnd\n\t(\n\t\tXPoint3dCR      centerIN,\n\t\tXPoint3dCR      startIN,\n\t\tXPoint3dCR      end\n\t);\n\n\t/**\n\t* @brief 设置起始点\n\t* @details 修改椭圆弧的起点和终点\n\t* \n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endPoint\n\t* @param bool ccw\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool SetStartEnd\n\t(\n\t\tXPoint3dCR      startPoint,\n\t\tXPoint3dCR      endPoint,\n\t\tbool            ccw\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由中心点、半径和面法向量初始化数据\n\t* \n\t* @param XPoint3dCR centerIN\n\t* @param XVec3dCR normal\n\t* @param double radius\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid InitFromCenterNormalRadius\n\t(\n\t\tXPoint3dCR      centerIN,\n\t\tXVec3dCR      normal,\n\t\tdouble          radius\n\t);\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点\n\t* \n\t* @param XPoint3dR point\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       point,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 角到点\n\t* @details 返回椭圆弧给定参数角对应的空间点\n\t* \n\t* @param double theta\n\t* @return XPoint3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tXPoint3d RadiansToPoint(double theta) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 返回椭圆弧给定参数坐标对应的空间点\n\t* \n\t* @param XPoint3dR point\n\t* @param double xx\n\t* @param double yy\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       point,\n\t\tdouble          xx,\n\t\tdouble          yy\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点\n\t* \n\t* @param XPoint4dR point\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint4dR       point,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 获取椭圆弧的起点和终点\n\t* \n\t* @param XPoint3dR startPoint\n\t* @param XPoint3dR endPoint\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid EvaluateEndPoints\n\t(\n\t\tXPoint3dR       startPoint,\n\t\tXPoint3dR       endPoint\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点以及在参数值处的导数\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param XVec3dR dX\n\t* @param XVec3dR ddX\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tXVec3dR       dX,\n\t\tXVec3dR       ddX,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算给定的参数角比例对应的空间点\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param double fraction\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid FractionParameterToPoint\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tdouble          fraction\n\t) const;\n\n\t/**\n\t* @brief 比例到点\n\t* @details 返回给定的参数角比例对应的空间点\n\t* \n\t* @param double fraction\n\t* @return XPoint3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tXPoint3d FractionToPoint(double fraction) const;\n\n\t/**\n\t* @brief 比例到导数\n\t* @details 返回给定的参数角比例对应的空间点及在该点处的导数\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param XVec3dR dX\n\t* @param XVec3dR ddX\n\t* @param double fraction\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid FractionParameterToDerivatives\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tXVec3dR       dX,\n\t\tXVec3dR       ddX,\n\t\tdouble          fraction\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算给定的参数角比例对应的空间点及在该点处的导数,以数组形式返回\n\t* \n\t* @param XPoint3dP point3dX\n\t* @param int numDerivative\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dP       pnt3dX,\n\t\tint             numDerivative,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 点到角\n\t* @details 计算椭圆弧上的点对应的参数角\n\t* \n\t* @param XPoint3dCR point\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble PointToAngle(XPoint3dCR point) const;\n\n\t/**\n\t* @brief 投影点\n\t* @details 将给定点投影到椭圆弧所在的平面上\n\t* \n\t* @param XPoint3dR xYZNear\n\t* @param double & coff0\n\t* @param double & coff90\n\t* @param XPoint3dCR xYZ\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool ProjectPointToPlane\n\t(\n\t\tXPoint3dR       xYZNear,\n\t\tdouble          &coff0,\n\t\tdouble          &coff90,\n\t\tXPoint3dCR      xYZ\n\t) const;\n\n\t/**\n\t* @brief 角到比例\n\t* @details 计算给定参数角所对应椭圆弧上的比例\n\t* \n\t* @param double angle\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble AngleToFraction(double angle) const;\n\n\t/**\n\t* @brief 弧长\n\t* @details 返回椭圆弧的长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble ArcLength() const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 计算椭圆弧空间点的范围\n\t* \n\t* @param XRange3dR range\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief XY方向上与直线相交\n\t* @details 计算XY方向上与直线相交的交点,椭圆弧和直线都视为无界的\n\t* \n\t* @param XPoint3dP cartesianPoints\n\t* @param double * pLineParams\n\t* @param XPoint3dP ellipseCoffs\n\t* @param double * pEllipseAngle\n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endPoint\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectXYLine\n\t(\n\t\tXPoint3dP       cartesianPoints,\n\t\tdouble          *pLineParams,\n\t\tXPoint3dP       ellipseCoffs,\n\t\tdouble          *pEllipseAngle,\n\t\tXPoint3dCR      startPoint,\n\t\tXPoint3dCR      endPoint\n\t) const;\n\n\t/**\n\t* @brief 是否完整\n\t* @details 查询椭圆弧是否完整\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCircular() const;\n\n\t/**\n\t* @brief 是否完整\n\t* @details 查询椭圆弧是否完整\n\t* \n\t* @param double & radius\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCircular(double &radius) const;\n\n\t/**\n\t* @brief 是否逆时针\n\t* @details 查询椭圆弧在XY平面内的投影是否逆时针扫掠\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCCWSweepXY() const;\n\n\t/**\n\t* @brief 与线段相交\n\t* @details 计算与给定椭圆弧相交的交点,椭圆弧和线段都视为无界的\n\t* \n\t* @param XPoint3dP pointArray\n\t* @param XPoint3dP ellipseParams\n\t* @param double * pLineParams\n\t* @param XSegment3dCR segment\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectSweptXSegment3d\n\t(\n\t\tXPoint3dP       pntArray,\n\t\tXPoint3dP       ellipseParams,\n\t\tdouble          *pLineParams,\n\t\tXSegment3dCR    segment\n\t) const;\n\n\t/**\n\t* @brief 与线段相交\n\t* @details 计算与给定线段相交的交点,椭圆弧和线段都视为有界的\n\t* \n\t* @param XPoint3dP pointArray\n\t* @param XPoint3dP ellipseParams\n\t* @param double * pLineParams\n\t* @param XSegment3dCR segment\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectSweptXSegment3dBounded\n\t(\n\t\tXPoint3dP       pntArray,\n\t\tXPoint3dP       ellipseParams,\n\t\tdouble          *pLineParams,\n\t\tXSegment3dCR    segment\n\t) const;\n\n\t/**\n\t* @brief 转换为BR类型3D元素\n\t* @details 将椭圆弧转换为BR类型的3D元素\n\t* \n\t* @param XPoint3dR centerOUT\n\t* @param double * pQuatWXYZ\n\t* @param XVec3dR directionX\n\t* @param XVec3dR directionY\n\t* @param double & rx\n\t* @param double & ry\n\t* @param double & startAngle\n\t* @param double & sweepAngle\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetATFields3d\n\t(\n\t\tXPoint3dR       centerOUT,\n\t\tdouble *        pQuatWXYZ,\n\t\tXVec3dR         directionX,\n\t\tXVec3dR         directionY,\n\t\tdouble          &rx,\n\t\tdouble          &ry,\n\t\tdouble          &startAngle,\n\t\tdouble          &sweepAngle\n\t) const;\n\n\t/**\n\t* @brief 设置扫掠角\n\t* @details 设置椭圆弧的扫掠角\n\t* \n\t* @param double startAngle\n\t* @param double sweepIN\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid SetSweep\n\t(\n\t\tdouble          startAngle,\n\t\tdouble          sweepIN\n\t);\n\n\t/**\n    * @brief 获取扫掠角\n    * @details 获取椭圆弧的扫掠角\n\t* \n\t* @param double & startAngle\n\t* @param double & sweepAngle\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetSweep\n\t(\n\t\tdouble          &startAngle,\n\t\tdouble          &sweepAngle\n\t) const;\n\n\t/**\n\t* @brief 补全扫掠角\n\t* @details 根据当前的角度范围补全扫掠角\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid ComplementSweep();\n\n\t/**\n    * @brief 与弧相交\n    * @details 计算与给定椭圆弧相交的交点,椭圆弧都视为有界的\n\t* \n\t* @param XPoint3dP cartesianPoints\n\t* @param XPoint3dP ellipse0Coffs\n\t* @param double * pEllipse0Angle\n\t* @param XPoint3dP ellipse1Coffs\n\t* @param double * pEllipse1Angle\n\t* @param XEllipse3dCR ellipse1\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectXYXEllipse3dBounded\n\t(\n\t\tXPoint3dP       cartesianPoints,\n\t\tXPoint3dP       ellipse0Coffs,\n\t\tdouble          *pEllipse0Angle,\n\t\tXPoint3dP       ellipse1Coffs,\n\t\tdouble          *pEllipse1Angle,\n\t\tXEllipse3dCR    ellipse1\n\t) const;\n\n\t/**\n\t* @brief 比例到角\n\t* @details 计算给定比例参数对应的参数角\n\t* \n\t* @param double fraction\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble FractionToAngle(double fraction) const;\n\n\t/**\n\t* @brief 获取最近点\n\t* @details 获取有界椭圆弧在XY方向上离给定空间点最近的点\n\t* \n\t* @param double & minAngle\n\t* @param double & minDistanceSquared\n\t* @param XPoint3dR minPoint\n\t* @param XPoint3dCR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool ClosestPointXYBounded\n\t(\n\t\tdouble          &minAngle,\n\t\tdouble          &minDistSquared,\n\t\tXPoint3dR       minPoint,\n\t\tXPoint3dCR      point\n\t) const;\n\n\t/**\n\t* @brief 完全扫掠\n\t* @details 将椭圆弧以现有的方向扫掠完整的360°\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid MakeFullSweep();\n\n    /**\n    * @brief 获取最近点\n    * @details 在应用变换矩阵（可选）后,计算椭圆弧在XY方向上离给定点最近的点（投影或端点）\n    * \n    * @param XPoint3dR closePoint\n    * @param double & closeParam\n    * @param double & distanceXY\n    * @param XPoint3dCR spacePoint\n    * @param XMatrix4dCP worldToLocal\n    * @return bool\n    *\n    * @author SZEWEC\n    * @since 2022/04/22\n    */\n    bool ClosestPointBoundedXY\n    (\n    XPoint3dR   closePoint,\n    double&     closeParam,\n    double&     distXY,\n    XPoint3dCR  spacePoint,\n    XMatrix4dCP worldToLocal\n    ) const;\n\n    /**\n    * @brief 获取最近点\n    * @details 在应用变换矩阵（可选）后,计算椭圆弧在XY方向上离给定点最近的点（投影或端点）\n    * \n    * @param XPoint3dR closePoint\n    * @param double & closeParam\n    * @param double & distanceXY\n    * @param XPoint3dCR spacePoint\n    * @param XMatrix4dCP worldToLocal\n    * @param bool extend0\n    * @param bool extend1\n    * @return bool\n    *\n    * @author SZEWEC\n    * @since 2022/04/22\n    */\n    bool ClosestPointBoundedXY\n    (\n    XPoint3dR   closePoint,\n    double&     closeParam,\n    double&     distXY,\n    XPoint3dCR  spacePoint,\n    XMatrix4dCP worldToLocal,\n    bool extend0,\n    bool extend1\n    ) const;\n\n\t/**\n\t* @brief 获取椭圆弧的起始与终止角度\n\t*\n\t* @param double & startAngle 起始角度\n\t* @param double & endAngle 终止角度\n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/30\n\t*/\n\tvoid GetLimits\n\t(\n\t\tdouble &startAngle,\n\t\tdouble &endAngle\n\t) const;\n\n\t/**\n\t* @brief 给定0°和90°的向量创建椭圆弧\n\t*\n\t* @param XPoint3dCR center\t\t\t\t\t中心点\n\t* @param XVec3dCR vector0\t\t\t\t\t0°向量（通常为沿着主轴的方向）\n\t* @param XVec3dCR vector90\t\t\t\t\t90°向量（通常为沿着短轴的方向）\n\t* @param double theta0\t\t\t\t\t\t起始点对应的角度\n\t* @param double sweep\t\t\t\t\t\t扫掠角度\n\t* @return ATEC_NAMESPACE_NAME::XEllipse3d\t椭圆弧\n\t*\n\t* @author SZEWEC\n\t* @since 2022/06/20\n\t*/\n\tstatic XEllipse3d FromVectors\n\t(\n\t\tXPoint3dCR center,\n\t\tXVec3dCR vector0,\n\t\tXVec3dCR vector90,\n\t\tdouble theta0,\n\t\tdouble sweep\n\t);\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XVec3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\nstruct ATGEOSET_EXPORT XVec3d : public XPoint3d\n{\n\tstatic XVec3d FromInterpolate(XVec3dCR vector0, double fraction, XVec3dCR vector1);\n\n\tstatic XVec3d From(double ax, double ay, double az = 0.0);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double  ay);\n\n\tstatic XVec3d From(XPoint3dCR point);\n\n\tvoid Init(XPoint3dCR point);\n\n\tstatic XVec3d FromStartEnd(XPoint3dCR start, XPoint3dCR end);\n\n\tstatic XVec3d FromStartEndNormalize(XPoint3dCR start, XPoint3dCR end);\n\n\tstatic XVec3d FromCCWPerpendicularXY(XVec3d source);\n\n\tstatic XVec3d FromRotate90Towards(XVec3dCR source, XVec3dCR target);\n\n\tstatic XVec3d FromRotate90Around(XVec3dCR source, XVec3dCR axis);\n\n\tstatic ValidatedXVec3d FromRotateVectorAroundVector(XVec3dCR source, XVec3dCR axis, XAngle angle);\n\n\tstatic XVec3d FromZero();\n\n\tstatic XVec3d UnitX();\n\n\tstatic XVec3d UnitY();\n\n\tstatic XVec3d UnitZ();\n\n\tdouble Normalize(XVec3dCR vector);\n\n\tdouble Normalize();\n\n\tdouble ScaleToLength(XVec3dCR vector, double length);\n\n\tdouble ScaleToLength(double length);\n\n\tstatic XVec3d FromXYAngleAndMagnitude\n\t(\n\t\tdouble          theta,\n\t\tdouble          magnitude\n\t);\n\n\tvoid InitFromXYAngleAndMagnitude\n\t(\n\t\tdouble          theta,\n\t\tdouble          magnitude\n\t);\n\n\tstatic XVec3d FromColumn(XRotMatrixCR matrix, int i);\n\n\tvoid InitFromColumn\n\t(\n\t\tXRotMatrixCR     matrix,\n\t\tint             col\n\t);\n\n\tvoid MultiplyTranspose(XRotMatrixCR matrix, XVec3dCR vector);\n\n\tvoid MultiplyTranspose(XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XVec3d FromStartEnd(XPoint4dCR start, XPoint4dCR end);\n\n\tstatic XVec3d FromCrossProduct(XVec3dCR vector0, XVec3dCR vector1);\n\n\tvoid CrossProduct(XVec3dCR vector1, XVec3dCR vector2);\n\n\tvoid CrossProduct(XVec3dCR vector1, XPoint3dCR point2);\n\n\tvoid CrossProduct(XPoint3dCR point1, XVec3dCR vector2);\n\n\tstatic XVec3d FromNormalizedCrossProductToPoints(XPoint3dCR origin, XPoint3dCR target1, XPoint3dCR target2);\n\n\tstatic XVec3d FromNormalizedCrossProduct(XVec3dCR vector0, XVec3dCR vector1);\n\n\tdouble NormalizedCrossProduct(XVec3dCR  vector1, XVec3dCR vector2);\n\n\tstatic XVec3d FromCrossProduct(double x0, double y0, double z0, double x1, double y1, double z1);\n\n\tvoid RotateXY(XVec3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tbool UnitPerpendicularXY(XVec3dCR vector);\n\n\tstatic ValidatedXVec3d FromUnitPerpendicularXY(XVec3dCR vector);\n\n\tstatic XVec3d FromSumOf(XVec3dCR vector0, XVec3dCR vector1);\n\n\tstatic XVec3d FromSumOf(XVec3dCR vector0, double scale0, XVec3dCR vector1, double scale1);\n\n\tvoid SumOf(XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2);\n\n\tstatic XVec3d FromSumOf(XVec3dCR vector0, double scale0, XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2);\n\n\tvoid SumOf(XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2, XVec3dCR vector3, double scale3);\n\n\tvoid SumOf(XVec3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XVec3dCR origin, XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2);\n\n\tvoid SumOf(XVec3dCR origin, XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2, XVec3dCR vector3, double scale3);\n\n\tstatic XVec3d FromScale(XVec3dCR vector, double scale);\n\n\tvoid Scale(XVec3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XVec3dCR vector);\n\n\tvoid Negate();\n\n\tdouble DotProduct(XVec3dCR vector2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n    double DotProductXY(XVec3dCR vector2) const;\n\n\tdouble TripleProduct(XVec3dCR vector2, XVec3dCR vector3) const;\n\n\tdouble Magnitude() const;\n\n\tdouble AngleTo(XVec3dCR vector2) const;\n\n\tdouble AngleToXY(XVec3dCR vector2) const;\n\n\tdouble SignedAngleTo\n\t(\n\t\tXVec3dCR        vector2,\n\t\tXVec3dCR        orientationVector\n\t) const;\n\n\tbool IsParallelTo(XVec3dCR vector2) const;\n\n\tbool IsPerpendicularTo(XVec3dCR vector2) const;\n\n\tbool      IsZero();\n\n\tvoid Multiply(XRotMatrixCR matrix, XVec3dCR vector);\n\n\tvoid Multiply(XRotMatrixCR matrix, double x, double y, double z);\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XPoint3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n /**\n * @brief 3D绌洪棿鐐圭被\n * @author SZEWC\n * @since 2022/04/13\n*/\nstruct ATGEOSET_EXPORT XPoint3d\n{\n\n\tdouble x;\n\n\tdouble y;\n\n\tdouble z;\n\n\tstatic XPoint3d From(double x, double y, double z = 0.0);\n\n\tstatic XPoint3d From(XPoint2dCR xy);\n\n\tstatic XPoint3d FromZero();\n\n\tstatic XPoint3d FromOne();\n\n\tstatic XPoint3d FromXYZ(double x, double y, double z);\n\n\tvoid Swap(XPoint3dR other);\n\n\tdouble DotDifference(XPoint3dCR origin, XVec3dCR vector) const;\n\n\tvoid Zero();\n\n\tvoid Init(XPoint2dCR source);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double ay);\n\n\tvoid SetComponent(double a, int index);\n\n\tdouble GetComponent(int index) const;\n\n\tvoid Interpolate(XPoint3dCR pnt0, double fractionParameter, XPoint3dCR point1);\n\n\tdouble Distance(XPoint3dCR point2) const;\n\n\tdouble DistanceXY(XPoint3dCR point2) const;\n\n\tbool DistanceXY(XPoint3dCR otherPoint, XMatrix4dCP matrix, double &distance) const;\n\n\tbool IsEqual(XPoint3dCR point2) const;\n\n\tbool IsEqual(XPoint3dCR point2, double tolerance) const;\n\n\tbool IsDisconnect() const;\n\n\tvoid InitDisconnect();\n\n\tvoid Init(XVec3dCR vector);\n\n\tvoid Subtract(XPoint3dCR base, XVec3dCR vector);\n\n\tvoid Add(XVec3dCR vector);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2, XVec3dCR point3, double scale3);\n\n\tvoid CrossProduct(XPoint3dCR point1, XPoint3dCR point2);\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble AngleTo(XPoint3dCR point2) const;\n\n\tvoid RotateXY(XPoint3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tdouble MagnitudeXY() const;\n\n\tvoid Scale(XPoint3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XPoint3dCR vector);\n\n\tvoid Negate();\n\n\tdouble Normalize(XPoint3dCR vector);\n\n\tdouble Normalize();\n\n\tvoid Subtract(XPoint3dCR point2);\n\n\tvoid DifferenceOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2, XPoint3dCR point3, double scale3);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2, XPoint3dCR point3, double a3);\n\n\tvoid Add(XPoint3dCR vector);\n\n\tvoid SumOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, XPoint3dCR point);\n\n\tstatic XPoint3d FromInterpolate(XPoint3dCR pntA, double fraction, XPoint3dCR pntB);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector, double scaleFactor);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1, XPoint3dCR point2, double scaleFactor2);\n\n\tstatic XPoint3d FromScale(XPoint3d point, double scale);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, XVec3dCR vector);\n\n\tbool AlmostEqual(XPoint3d const & dataB) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB) const;\n\n\tbool AlmostEqual(XPoint3d const & dataB, double abstol) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB, double abstol) const;\n\n\tstatic bool AlmostEqual(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tstatic bool AlmostEqualXY(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tdouble DistanceSquared(XPoint3dCR point2) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file CreateGeometryExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};\n code of file CurveSet.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 线串类\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct CurveSet : RefCountedBase, xvector<IBasicCurvePtr>\n{\n\n\tenum BoundaryType\n\t{\n\n\t\tBOUNDARY_TYPE_None = 0,\n\n\t\tBOUNDARY_TYPE_Open = 1,\n\n\t\tBOUNDARY_TYPE_Outer = 2,\n\n\t\tBOUNDARY_TYPE_Inner = 3,\n\n\t\tBOUNDARY_TYPE_ParityRegion = 4,\n\n\t\tBOUNDARY_TYPE_UnionRegion = 5,\n\t};\n\n\tenum InOutClassification\n\t{\n\t\tINOUT_Unknown = 0,\n\t\tINOUT_In = 1,\n\t\tINOUT_Out = 2,\n\t\tINOUT_On = 3\n\t};\n\nprotected:\n\tBoundaryType    m_boundaryType;\n\npublic:\n\t/**\n\t* @brief 设定边界\n\t* @details 设定曲线的边界类型\n\t* \n\t* @param BoundaryType BoundaryType\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void SetBoundaryType(BoundaryType BoundaryType);\n\n\t/**\n\t* @brief 获取叶节点\n\t* @details 通过只计算叶节点的索引深度搜索以获取目标叶节点\n\t* \n\t* @param size_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr FindIndexedLeaf(size_t index) const;\n\n\t/**\n\t* @brief 获取索引值\n\t* @details 深度搜索以获取给定叶节点的索引值\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @param size_t & index\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool LeafToIndex(IBasicCurveCP primitive, size_t &index) const;\n\n\t/**\n\t* @brief 获取叶节点个数\n\t* @details 获取曲线的叶节点个数\n\t* \n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesBelow() const;\n\n\texplicit CurveSet(BoundaryType boundaryType) { m_boundaryType = boundaryType; }\n\n\t/**\n\t* @brief 是否单元素曲线\n\t* @details 查询曲线是否只有一个基本元素\n\t* \n\t* @return IBasicCurve\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurve::BasicCurveType HasSingleBasicCurve() const;\n\n\t/**\n\t* @brief 获取边界类型\n\t* @details 获取曲线的边界类型\n\t* \n\t* @return BoundaryType\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT BoundaryType GetBoundaryType() const;\n\n\t/**\n\t* @brief 查询是否开\n\t* @details 查询是否开路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsOpenPath() const;\n\n\t/**\n\t* @brief 查询是否闭\n\t* @details 查询是否闭路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsClosedPath() const;\n\n\t/**\n\t* @brief 查询实际开闭\n\t* @details 查询是否名义上是开路径但起点和终点连接\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsPhysicallyClosedPath() const;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个带有给定边界类型没有成员的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个具有单个基本元素和给定边界类型的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @param IBasicCurvePtr primitive\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType, IBasicCurvePtr primitive);\n\n\t/**\n\t* @brief 拷贝\n\t* @details 返回一个深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr Clone() const;\n\n\t/**\n\t* @brief 倒角拷贝\n\t* @details 返回一个深度拷贝,在连续曲线之间插入圆角\n\t* \n\t* @param double radius\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithFillets(double radius) const;\n\n\t/**\n\t* @brief 闭合拷贝\n\t* @details 返回一个深度拷贝,闭合终端点的间隙\n\t* \n\t* @param CurveGapOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithGapsClosed(CurveGapOptionsCR options) const;\n\n\t/**\n\t* @brief 添加元素\n\t* @details 递归遍历source, 将所有叶节点添加到this, 返回添加的数量\n\t* \n\t* @param CurveSetCR source\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t AddPrimitives(CurveSetCR source);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 添加单个基本曲线\n\t* \n\t* @param IBasicCurvePtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(IBasicCurvePtr child);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 将chile的所有元素作为曲线成员添加\n\t* \n\t* @param CurveSetPtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(CurveSetPtr child);\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过XY方向的偏移后的深度拷贝\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneOffsetCurvesXY(CurveOffsetOptionsCR options);\n\n\t/**\n\t* @brief 获取叶节点数量\n\t* @details 计算指定类型的叶节点数量\n\t* \n\t* @param IBasicCurve::BasicCurveType targetType\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesOfType(IBasicCurve::BasicCurveType targetType) const;\n\n\t/**\n\t* @brief 用区域分割曲线\n\t* @details 用指定区域分割曲线,分别返回区域内、外和区域上的曲线\n\t* \n\t* @param CurveSetCR region\n\t* @param CurveSetP insideCollector\n\t* @param CurveSetP outsideCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByRegion(CurveSetCR region, CurveSetP insideCollector, CurveSetP outsideCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 用平面分割曲线\n\t* @details 用指定平面分割曲线,分别返回平面上方、下方和平面内的曲线\n\t* \n\t* @param XPlane3dCR plane\n\t* @param CurveSetP belowCollector\n\t* @param CurveSetP aboveCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByPlane(XPlane3dCR plane, CurveSetP belowCollector, CurveSetP aboveCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 拆分拷贝\n\t* @details 返回一个深度拷贝,但所有的多线段被拆分成单条线段\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithExplodedLinestrings() const;\n\n\t/**\n\t* @brief 获取质心\n\t* @details 返回包含曲线的质心(不考虑孤立点)\n\t* \n\t* @param double & length\n\t* @param XPoint3dR centroid\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  WireCentroid(double &length, XPoint3dR centroid) const;\n\n\t/**\n\t* @brief 获取质心、法向量和面积\n\t* @details 返回质心、法向量和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param XVec3dR normal\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CentroidNormalArea(XPoint3dR centroid, XVec3dR normal, double &area) const;\n\n\t/**\n\t* @brief 获取质心和面积\n\t* @details 返回XY平面方向上的质心和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  CentroidAreaXY(XPoint3dR centroid, double &area) const;\n\n\t/**\n\t* @brief 投影范围\n\t* @details 当投影到射线的时候,返回射线参数的范围\n\t* \n\t* @param XRay3dCR ray\n\t* @return XRange1d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT XRange1d ProjectedParameterRange(XRay3dCR ray) const;\n\n    /**\n    * @brief 局部坐标拷贝\n    * @details 返回曲线的深度复制并转换为与曲线相关联的局部坐标系统。\n    * \n    * @param LocalCoordinateSelect frameType\n    * @param TransformR localToWorld\n    * @param TransformR worldToLocal\n    * @param XRange3dR localRange\n    * @return CurveSetPtr\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT CurveSetPtr CloneInLocalCoordinates\n    (\n    LocalCoordinateSelect frameType,\n    TransformR localToWorld,\n    TransformR worldToLocal,\n    XRange3dR localRange\n    ) const;\n\n\t/**\n    * @brief 获取有坐标系的元素\n    * @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame) const;\n\n\t/**\n\t* @brief 获取有坐标系的元素\n\t* @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @param int searchPreference\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame, int srchPref) const;\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param xvector<XPoint3d> const & points\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(xvector<XPoint3d> const&points,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint3dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint3dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建多边形\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint2dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint2dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建矩形\n\t* @details 根据 XY 坐标创建矩形\n\t* \n\t* @param double x0\n\t* @param double y0\n\t* @param double x1\n\t* @param double y1\n\t* @param double z\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateRectangle(double x0, double y0, double x1, double y1, double z,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由给定线段创建边界类型为 BOUNDARY_TYPE_None 的曲线\n\t* \n\t* @param xvector<XSegment3d> const & segments\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(xvector<XSegment3d> const &segs);\n\n\t/**\n\t* @brief 创建圆盘\n\t* @details 为一个完整的椭圆(圆)盘创建一个曲线向量结构\n\t* \n\t* @param XEllipse3dCR arc\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateDisk(XEllipse3dCR arc, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer, bool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个仅有单一元素的曲线结构\n\t* \n\t* @param IBasicCurvePtr child\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(IBasicCurvePtr child, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open);\n\n\t/**\n\t* @brief B样条拷贝\n\t* @details 返回一个深度拷贝,作为B样条曲线\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneAsBsplines() const;\n\n\t/**\n\t* @brief 添加边缘点\n\t* @details 为所有的子节点添加边缘点\n\t* \n\t* @param xvector <XPoint3d> & points\n\t* @param IFacetOptionsR options\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AddStrokePoints(xvector <XPoint3d> &points, IFacetOptionsR options) const;\n\n    /**\n\t* @brief 添加面点\n\t* @details 沿着曲线计算指定距离的点\n\t* \n\t* @param xvector<double> const & distances\n\t* @param xvector<CurveDescInfo> & locations\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool AddSpacedPoints(xvector<double> const &distances, xvector<CurveDescInfo> &locations) const;\n\n\t/**\n\t* @brief 添加边缘\n\t* @details 在结构中添加所有边缘\n\t* \n\t* @param xvector <xvector<xvector<XPoint3d>>> & regionsPoints\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CollectLinearGeometry(xvector <xvector<xvector<XPoint3d>> > &regionsPoints) const;\n\n\t/**\n\t* @brief 获取B样条曲线\n\t* @details 将一个表示开放或闭合路径作为单个B样条曲线\n\t* \n\t* @return ATBsplineCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetBsplineCurve() const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n    /**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索最接近曲线的点。如果曲线是一个区域类型,同时要在该区域的内部寻找投影\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XPoint3dR curveOrRegionPoint\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification ClosestCurveOrRegionPoint(XPoint3dCR spacePoint, XPoint3dR curveOrRegionPoint) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点和终点\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点终点和他们的正切值\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @param XVec3dR unitTangentA\n\t* @param XVec3dR unitTangentB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\t/**\n\t* @brief 获取起点\n\t* @details 返回曲线的起点\n\t* \n\t* @param XPoint3dR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线总长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length() const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线经过变换后的总长度\n\t* \n\t* @param XRotMatrixCP worldToLocal\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length(XRotMatrixCP worldToLocal) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线的xyz范围\n\t* \n\t* @param XRange3dR range\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线经过变换后的范围\n\t* \n\t* @param XRange3dR range\n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\t/**\n\t* @brief 查询索引\n\t* @details 返回指定元素的索引\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t FindIndexOfPrimitive(IBasicCurveCP primitive) const;\n\n\t/**\n\t* @brief 复制曲线指定范围的曲线\n\t* @details 复制曲线指定索引和比例参数范围内的部分\n\t* \n\t* @param int index0\n\t* @param double fraction0\n\t* @param int index1\n\t* @param double fraction1\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n    ATGEOSET_EXPORT CurveSetPtr CloneBetweenCyclicIndexedFractions(int index0, double fraction0, int index1, double fraction1) const;\n\n\t/**\n\t* @brief 反转拷贝\n\t* @details 返回一个所有元素都被反转的深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneReversed() const;\n\n\t/**\n\t* @brief 查询是否包含非线性元素\n\t* @details 如果曲线有一个不非线性元素,则返回true。\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ContainsNonLinearPrimitive() const;\n\n\t/**\n\t* @brief 计算交点\n\t* @details 计算曲线与给定平面的交点\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 平面选中\n\t* @details 计算封闭曲线与平面的交叉点,并以奇偶性规则为设为起始对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param double tolerance\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr PlaneSection(XPlane3dCR plane, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 空间点位置情况\n\t* @details 当以XY平面视角看,测试给定点在曲线内、曲线上还是曲线外\n\t* \n\t* @param XPoint3dCR xyz\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification PointInOnOutXY(XPoint3dCR xyz) const;\n\n\t/**\n\t* @brief 射线击中情况\n\t* @details 测试射线击中曲线在区域内、区域上还是区域外\n\t* \n\t* @param XRay3dCR ray\n\t* @param SolidDescInfoR hitDetail\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification RayPierceInOnOut\n\t(\n\t\tXRay3dCR ray,\n\t\tSolidDescInfoR hitDetail\n\t) const;\n\n\t/**\n\t* @brief 原地变换\n\t* @details 应用给定变换并修改曲线\n\t* \n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\t/**\n\t* @brief 原地反转\n\t* @details 将所有元素进行反转\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串内的单个点被消除,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串相邻的空间点被消除（可选）,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @param bool doSimplifyLinestrings\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives(bool doSimplifyLinestrings);\n\n\t/**\n\t* @brief 原地修改以简化线串\n\t* @details 消除线串相邻的空间点\n\t* \n\t* @param double distanceTol\n\t* @param bool eliminateOverdraw\n\t* @param bool wrap\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void SimplifyLinestrings(double distTol, bool eliminateOverdraw, bool wrap);\n\n\t/**\n\t* @brief 重排元素\n\t* @details 将曲线元素重新排序以缩小元素首尾相连的间隙\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT double ReorderForSmallGaps();\n\n\t/**\n\t* @brief 链接元素\n\t* @details 将曲线的元素首尾相连\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AssembleChains();\n\n\t/**\n\t* @brief 区域相并\n\t* @details 返回给定两个区域的并\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaUnion(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相减\n\t* @details 返回给定两个区域的减\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaDifference(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相交\n\t* @details 返回给定两个区域的交\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaIntersection(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 循环索引\n\t* @details 返回给定索引值关于集合大小的模\n\t* \n\t* @param int index\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT size_t CyclicIndex(int index) const;\n\n\t/**\n\t* @brief 循环获取值\n\t* @details 根据给定索引的循环索引获取元素\n\t* \n\t* @param ptrdiff_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr GetCyclic(ptrdiff_t index) const;\n\n    /**\n    * @brief 获取索引\n    * @details 返回给定曲线元素的详细细节所对应的元素索引\n    * \n    * @param CurveDescInfo const & location\n    * @return size_t\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT size_t CurveDescInfoIndex(CurveDescInfo const& location) const;\n\n\t/**\n\t* @brief 与平面相交\n\t* @details 计算封闭曲线与平面的交叉点,返回以奇偶性规则构造的起止点对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool AppendClosedCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过给定偏移后的深度拷贝.\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AreaOffset(CurveOffsetOptionsCR options) const;\n\n\t/**\n\t* @brief 返回从index0,fraction0到index1,fraction1的曲线段\n\t* \n\t* @param int index0 \n\t* @param double fraction0 \n\t* @param int index1 \n\t* @param double fraction1 \n\t* @param bool allowExtrapolation \n\t* @return ATGEOSET_EXPORT CurveSetPtr \n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/17\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneBetweenDirectedFractions(int index0, double fraction0, int index1, double fraction1, bool allowExtrapolation) const;\n\n\t/**\n\t* @brief 返回输入的曲线的布尔奇运算结果（区域）\n\t*\n\t* @param CurveSetCR regionA\t\t\t\t\t左操作数\n\t* @param CurveSetCR regionB\t\t\t\t\t右操作数\n\t* @param BasicCurvePtrPairVector * newToOld\t（可选）包含新旧曲线的数组指针\n\t* @return ATGEOSET_EXPORT CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/07/22\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaParity(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n};\n\nstruct CurveCurve\n{\nprivate: CurveCurve();\npublic:\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tCurveSetR curveA,\n\t\tCurveSetR curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB,\n\t\tXMatrix4dCP    pWorldToLocal,\n\t\tbool         extend = false\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveR curveA,\n\t\tCurveSetR     curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tCurveSetCR chainA,\n\t\tCurveSetCR chainB\n\t);\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            double &fractionA,\n            XPoint3dR pntA,\n            double &fractionB,\n            XPoint3dR pntB\n            );\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            CurveDescInfoR detailA,\n            CurveDescInfoR detailB\n            );\n};\n\nstruct PathLocationDetail\n{\nprivate:\n\tCurveDescInfo m_curveDetail;\n\tint32_t m_pathIndex;\n\tdouble m_pathDistance;\npublic:\n\n\tATGEOSET_EXPORT PathLocationDetail();\n\n\tATGEOSET_EXPORT PathLocationDetail(PathLocationDetail const &other);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, int pathIndex = -1, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, size_t pathIndex, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(double distance);\n\n\tATGEOSET_EXPORT XPoint3d Point() const;\n\n\tATGEOSET_EXPORT CurveDescInfo GetCurveDescInfo() const;\n\n    ATGEOSET_EXPORT double DistanceFromPathStart() const;\n};\n\nstruct CurveSetWithDistanceIndex : RefCountedBase\n{\nprivate:\n\n\tstruct PathEntry : PathLocationDetail\n\t{\n\t\tdouble             m_projectedDistance;\n\t\tXRange3d           m_range;\n\t\tPathEntry(PathLocationDetail const &pathDetail, double projectedDist, XRange3dCR range)\n\t\t\t: PathLocationDetail(pathDetail),\n\t\t\tm_projectedDistance(projectedDist),\n\t\t\tm_range(range)\n\t\t{\n\t\t}\n\t\tPathEntry(double distance) : PathLocationDetail(distance), m_projectedDistance(distance) {}\n\n\t\tdouble GetDistance(bool projected) const;\n\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistanceXY(PathEntry const &dataA, PathEntry const &dataB);\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistance(PathEntry const &dataA, PathEntry const &dataB);\n\t};\n\n\tCurveSetPtr m_curveVector;\n\txvector<PathEntry> m_locations;\n\tCurveSetPtr m_savedPrimitives;\n\n\tXRotMatrix m_worldToViewRotMatrix;\n\tXRotMatrix m_viewToWorldRotMatrix;\n\tXRotMatrix m_flattenToView;\n\tXMatrix4d m_worldToView;\n\n\texplicit CurveSetWithDistanceIndex(XRotMatrix worldToView);\n\n\tCurveSetWithDistanceIndex();\n\npublic:\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create(XRotMatrix worldToView);\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create();\n\n\tATGEOSET_EXPORT void SetPath(CurveSetPtr &path);\n\n\tATGEOSET_EXPORT bool SearchByDistanceFromPathStart\n\t(\n\t\tdouble targetDist,\n\t\tPathLocationDetail &detail\n\t) const;\n\n    ATGEOSET_EXPORT PathLocationDetail SearchClosestPointBounded\n    (\n    XPoint3dCR spacePoint,\n    bool computeDistAlong\n    ) const;\n};\n\nEND_ATEC_NAMESPACE\n\n", "output": "\n#pragma region XEllipse\nvoid CreateGeometryExamples::CreateXEllipse_FromCenterNormalRadius()\n{\n\t//根据圆心,半径,法向量创建圆\n\tXPoint3d center = XPoint3d::FromZero();\n\tdouble radius = 50;\n\tXVec3d normal = XVec3d::UnitZ();\n\tXEllipse3d arc1 = XEllipse3d::FromCenterNormalRadius(center, normal, radius);\n\n\t//添加到视口\n\tCurveSetPtr curve = CurveSet::Create(IBasicCurve::CreateArc(arc1));\n\tAddGeometryToScene(curve);\n\n}\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};. You need to implement the function CreateXEllipse3d_FromCenterStartEndPts in the interface. Here are some apis that you can use and remember:\n code of file IBasicCurve.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 基本线元类\n* @author SZEWC\n* @since 2022/04/28\n*/\nstruct IBasicCurve : public RefCountedBase\n{\nprivate: virtual void IAmAbstractClass() = 0;\n\npublic:\n\tenum BasicCurveType\n\t{\n\t\tBCURVE_TYPE_Invalid = 0,\n\t\tBCURVE_TYPE_Line = 1,\n\t\tBCURVE_TYPE_LineString = 2,\n\t\tBCURVE_TYPE_Arc = 3,\n\t\tBCURVE_TYPE_BsplineCurve = 4,\n\t\tBCURVE_TYPE_InterpolationCurve = 5,\n\t\tBCURVE_TYPE_AkimaCurve = 6,\n\t\tBCURVE_TYPE_PointString = 7,\n\t\tBCURVE_TYPE_CurveSet = 8,\n\t\tBCURVE_TYPE_Spiral = 9,\n\t\tBCURVE_TYPE_PartialCurve = 10,\n\t\tBCURVE_TYPE_NotClassified = -1,\n\t};\n\n\tATGEOSET_EXPORT int64_t GetTag() const;\n\n\tATGEOSET_EXPORT int GetIntTag() const;\n\n\tATGEOSET_EXPORT void SetTag(int64_t tag);\n\n\tATGEOSET_EXPORT void SetTag(int tag);\n\n\tATGEOSET_EXPORT CurveSetPtr GetChildCurveSetP();\n\npublic:\n\tATGEOSET_EXPORT xvector<XPoint3d> * GetLineStringP();\n\n\tATGEOSET_EXPORT BasicCurveType           GetBasicCurveType() const;\n\n\tATGEOSET_EXPORT bool TryGetLine(XSegment3dR segment) const;\n\n\tATGEOSET_EXPORT bool TryGetArc(XEllipse3dR arc) const;\n\n\tATGEOSET_EXPORT XSegment3dCP                 GetLineCP() const;\n\n\tATGEOSET_EXPORT xvector<XPoint3d> const* GetLineStringCP() const;\n\n\tATGEOSET_EXPORT bool TryGetSegmentInLineString(XSegment3dR segment, size_t startPointIndex) const;\n\n\tATGEOSET_EXPORT XEllipse3dCP                 GetArcCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurveCP             GetBsplineCurveCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr             GetBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr            GetProxyBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT XSpiral2dPlacementCP         GetSpiralPlacementCP() const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLine(XSegment3dCR segment);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(XPoint3dCP points, size_t nPoints);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(xvector<XPoint3d> const &points);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateArc(XEllipse3dCR ellipse);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurveCR curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurvePtr& curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiral(XSpiral2dBaseCR spiral, TransformCR frame,\n\t\tdouble fractionA, double fractionB);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusBearingRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble endRadians,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusLengthRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble length,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT IBasicCurvePtr Clone() const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneComponent(ptrdiff_t componentIndex) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneAsSingleOffsetPrimitiveXY(CurveOffsetOptionsCR options) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XRay3dR ray) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, CurveDescInfo &detail) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2, XVec3dR derivative3) const;\n\n\tATGEOSET_EXPORT bool FractionToFrenetFrame(double f, TransformR frame) const;\n\n\tATGEOSET_EXPORT bool Length(double &length) const;\n\n\tATGEOSET_EXPORT bool Length(XRotMatrixCP worldToLocal, double &length) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\tATGEOSET_EXPORT size_t NumComponent() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetATBsplineCurvePtr(double fraction0 = 0.0, double fraction1 = 1.0) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(XRotMatrixCP worldToView, double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool TrySetStart(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TrySetEnd(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\tATGEOSET_EXPORT void  AppendCurvePlaneIntersections\n\t(\n\t\tXPlane3dByVectorsCR plane,\n\t\tUVBoundarySelect   bounded,\n\t\txvector<CurveAndSolidDescInfo> &intersections\n\t) const;\n\n\tATGEOSET_EXPORT bool AddStrokes(xvector <XPoint3d> &points, IFacetOptionsR options,\n\t\tbool includeStartPoint = true,\n\t\tdouble startFraction = 0.0,\n\t\tdouble endFraction = 1.0\n\t) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, double &fraction, XPoint3dR curvePoint) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneBetweenFractions(double fractionA, double fractionB, bool allowExtrapolation) const;\n\n\tATGEOSET_EXPORT CurveSetCP            GetChildCurveSetCP() const;\n\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(double startFraction, double endFraction, double &signedDist) const;\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(XRotMatrixCP worldToLocal, double startFraction, double endFraction, double &signedDist) const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateRectangle(double x0, double y0, double x1, double y1, double z, int areaSignPref = 0);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateChildCurveSet(CurveSetPtr source);\n\n\tATGEOSET_EXPORT bool  TryGetPartialCurveData(double &fractionA, double &fractionB, IBasicCurvePtr &parentCurve, int64_t &tag) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XEllipse3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 椭圆弧\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct ATGEOSET_EXPORT XEllipse3d\n{\n\tXPoint3d center;\n\tXVec3d   vector0;\n\tXVec3d   vector90;\n\tdouble start;\n\tdouble sweep;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 返回由已有椭圆的起始和终止比例定义的椭圆弧\n\t* \n\t* @param XEllipse3dCR parent\n\t* @param double startFraction\n\t* @param double endFraction\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromFractionInterval\n\t(\n\t\tXEllipse3dCR parent,\n\t\tdouble startFraction,\n\t\tdouble endFraction\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 根据椭圆的中心点、角度为0度和90度的点,以及扫掠角度创建一个椭圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point90\n\t* @param double theta0\n\t* @param double sweep\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromPoints(XPoint3dCR center, XPoint3dCR pnt0, XPoint3dCR pnt90, double theta0, double sweep);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由起始点,起始切线,半径,扫掠角度和面法向量创建椭圆弧\n\t* \n\t* @param XPoint3dCR pointA\n\t* @param XVec3dCR tangent\n\t* @param XVec3dCR planeNormal\n\t* @param double radius\n\t* @param double sweepRadians\n\t* @return ValidatedXEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic ValidatedXEllipse3d FromStartTangentNormalRadiusSweep(\n\n\t\tXPoint3dCR pntA,\n\t\tXVec3dCR tangent,\n\t\tXVec3dCR planeNormal,\n\t\tdouble radius,\n\t\tdouble sweepRadians\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由弧上的点创建椭圆弧\n\t* \n\t* @param XPoint3dCR start\n\t* @param XPoint3dCR middle\n\t* @param XPoint3dCR end\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromPointsOnArc(XPoint3dCR start, XPoint3dCR middle, XPoint3dCR end);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、起始点和终止点的切线创建椭圆弧（扫掠角取较小的一个）\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endTarget\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromArcCenterStartEnd(XPoint3dCR center, XPoint3dCR startPoint, XPoint3dCR endTarget);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、半径和面法向量创建完整的圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param XVec3dCR normal\n\t* @param double radius\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromCenterNormalRadius(XPoint3dCR center, XVec3dCR normal, double radius);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、半径创建XY平面上完整的圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param double radius\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromCenterRadiusXY(XPoint3dCR center, double radius);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 返回给定椭圆弧以反方向扫掠得到的椭圆弧\n\t* \n\t* @param XEllipse3dCR source\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromReversed(XEllipse3dCR source);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由给定点和扫掠角初始化数据\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point90\n\t* @param double theta0\n\t* @param double sweep\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid InitFromPoints\n\t(\n\t\tXPoint3dCR      center,\n\t\tXPoint3dCR      pnt0,\n\t\tXPoint3dCR      pnt90,\n\t\tdouble          theta0,\n\t\tdouble          sweep\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由椭圆弧上的点初始化数据\n\t* \n\t* @param XPoint3dCR start\n\t* @param XPoint3dCR middle\n\t* @param XPoint3dCR end\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool InitFromPointsOnArc\n\t(\n\t\tXPoint3dCR      start,\n\t\tXPoint3dCR      middle,\n\t\tXPoint3dCR      end\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由中心点、起始点和终止点的切线初始化数据（扫掠角取较小的一个）\n\t* \n\t* @param XPoint3dCR centerIN\n\t* @param XPoint3dCR startIN\n\t* @param XPoint3dCR end\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool InitFromArcCenterStartEnd\n\t(\n\t\tXPoint3dCR      centerIN,\n\t\tXPoint3dCR      startIN,\n\t\tXPoint3dCR      end\n\t);\n\n\t/**\n\t* @brief 设置起始点\n\t* @details 修改椭圆弧的起点和终点\n\t* \n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endPoint\n\t* @param bool ccw\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool SetStartEnd\n\t(\n\t\tXPoint3dCR      startPoint,\n\t\tXPoint3dCR      endPoint,\n\t\tbool            ccw\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由中心点、半径和面法向量初始化数据\n\t* \n\t* @param XPoint3dCR centerIN\n\t* @param XVec3dCR normal\n\t* @param double radius\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid InitFromCenterNormalRadius\n\t(\n\t\tXPoint3dCR      centerIN,\n\t\tXVec3dCR      normal,\n\t\tdouble          radius\n\t);\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点\n\t* \n\t* @param XPoint3dR point\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       point,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 角到点\n\t* @details 返回椭圆弧给定参数角对应的空间点\n\t* \n\t* @param double theta\n\t* @return XPoint3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tXPoint3d RadiansToPoint(double theta) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 返回椭圆弧给定参数坐标对应的空间点\n\t* \n\t* @param XPoint3dR point\n\t* @param double xx\n\t* @param double yy\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       point,\n\t\tdouble          xx,\n\t\tdouble          yy\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点\n\t* \n\t* @param XPoint4dR point\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint4dR       point,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 获取椭圆弧的起点和终点\n\t* \n\t* @param XPoint3dR startPoint\n\t* @param XPoint3dR endPoint\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid EvaluateEndPoints\n\t(\n\t\tXPoint3dR       startPoint,\n\t\tXPoint3dR       endPoint\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点以及在参数值处的导数\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param XVec3dR dX\n\t* @param XVec3dR ddX\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tXVec3dR       dX,\n\t\tXVec3dR       ddX,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算给定的参数角比例对应的空间点\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param double fraction\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid FractionParameterToPoint\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tdouble          fraction\n\t) const;\n\n\t/**\n\t* @brief 比例到点\n\t* @details 返回给定的参数角比例对应的空间点\n\t* \n\t* @param double fraction\n\t* @return XPoint3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tXPoint3d FractionToPoint(double fraction) const;\n\n\t/**\n\t* @brief 比例到导数\n\t* @details 返回给定的参数角比例对应的空间点及在该点处的导数\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param XVec3dR dX\n\t* @param XVec3dR ddX\n\t* @param double fraction\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid FractionParameterToDerivatives\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tXVec3dR       dX,\n\t\tXVec3dR       ddX,\n\t\tdouble          fraction\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算给定的参数角比例对应的空间点及在该点处的导数,以数组形式返回\n\t* \n\t* @param XPoint3dP point3dX\n\t* @param int numDerivative\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dP       pnt3dX,\n\t\tint             numDerivative,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 点到角\n\t* @details 计算椭圆弧上的点对应的参数角\n\t* \n\t* @param XPoint3dCR point\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble PointToAngle(XPoint3dCR point) const;\n\n\t/**\n\t* @brief 投影点\n\t* @details 将给定点投影到椭圆弧所在的平面上\n\t* \n\t* @param XPoint3dR xYZNear\n\t* @param double & coff0\n\t* @param double & coff90\n\t* @param XPoint3dCR xYZ\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool ProjectPointToPlane\n\t(\n\t\tXPoint3dR       xYZNear,\n\t\tdouble          &coff0,\n\t\tdouble          &coff90,\n\t\tXPoint3dCR      xYZ\n\t) const;\n\n\t/**\n\t* @brief 角到比例\n\t* @details 计算给定参数角所对应椭圆弧上的比例\n\t* \n\t* @param double angle\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble AngleToFraction(double angle) const;\n\n\t/**\n\t* @brief 弧长\n\t* @details 返回椭圆弧的长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble ArcLength() const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 计算椭圆弧空间点的范围\n\t* \n\t* @param XRange3dR range\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief XY方向上与直线相交\n\t* @details 计算XY方向上与直线相交的交点,椭圆弧和直线都视为无界的\n\t* \n\t* @param XPoint3dP cartesianPoints\n\t* @param double * pLineParams\n\t* @param XPoint3dP ellipseCoffs\n\t* @param double * pEllipseAngle\n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endPoint\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectXYLine\n\t(\n\t\tXPoint3dP       cartesianPoints,\n\t\tdouble          *pLineParams,\n\t\tXPoint3dP       ellipseCoffs,\n\t\tdouble          *pEllipseAngle,\n\t\tXPoint3dCR      startPoint,\n\t\tXPoint3dCR      endPoint\n\t) const;\n\n\t/**\n\t* @brief 是否完整\n\t* @details 查询椭圆弧是否完整\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCircular() const;\n\n\t/**\n\t* @brief 是否完整\n\t* @details 查询椭圆弧是否完整\n\t* \n\t* @param double & radius\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCircular(double &radius) const;\n\n\t/**\n\t* @brief 是否逆时针\n\t* @details 查询椭圆弧在XY平面内的投影是否逆时针扫掠\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCCWSweepXY() const;\n\n\t/**\n\t* @brief 与线段相交\n\t* @details 计算与给定椭圆弧相交的交点,椭圆弧和线段都视为无界的\n\t* \n\t* @param XPoint3dP pointArray\n\t* @param XPoint3dP ellipseParams\n\t* @param double * pLineParams\n\t* @param XSegment3dCR segment\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectSweptXSegment3d\n\t(\n\t\tXPoint3dP       pntArray,\n\t\tXPoint3dP       ellipseParams,\n\t\tdouble          *pLineParams,\n\t\tXSegment3dCR    segment\n\t) const;\n\n\t/**\n\t* @brief 与线段相交\n\t* @details 计算与给定线段相交的交点,椭圆弧和线段都视为有界的\n\t* \n\t* @param XPoint3dP pointArray\n\t* @param XPoint3dP ellipseParams\n\t* @param double * pLineParams\n\t* @param XSegment3dCR segment\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectSweptXSegment3dBounded\n\t(\n\t\tXPoint3dP       pntArray,\n\t\tXPoint3dP       ellipseParams,\n\t\tdouble          *pLineParams,\n\t\tXSegment3dCR    segment\n\t) const;\n\n\t/**\n\t* @brief 转换为BR类型3D元素\n\t* @details 将椭圆弧转换为BR类型的3D元素\n\t* \n\t* @param XPoint3dR centerOUT\n\t* @param double * pQuatWXYZ\n\t* @param XVec3dR directionX\n\t* @param XVec3dR directionY\n\t* @param double & rx\n\t* @param double & ry\n\t* @param double & startAngle\n\t* @param double & sweepAngle\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetATFields3d\n\t(\n\t\tXPoint3dR       centerOUT,\n\t\tdouble *        pQuatWXYZ,\n\t\tXVec3dR         directionX,\n\t\tXVec3dR         directionY,\n\t\tdouble          &rx,\n\t\tdouble          &ry,\n\t\tdouble          &startAngle,\n\t\tdouble          &sweepAngle\n\t) const;\n\n\t/**\n\t* @brief 设置扫掠角\n\t* @details 设置椭圆弧的扫掠角\n\t* \n\t* @param double startAngle\n\t* @param double sweepIN\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid SetSweep\n\t(\n\t\tdouble          startAngle,\n\t\tdouble          sweepIN\n\t);\n\n\t/**\n    * @brief 获取扫掠角\n    * @details 获取椭圆弧的扫掠角\n\t* \n\t* @param double & startAngle\n\t* @param double & sweepAngle\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetSweep\n\t(\n\t\tdouble          &startAngle,\n\t\tdouble          &sweepAngle\n\t) const;\n\n\t/**\n\t* @brief 补全扫掠角\n\t* @details 根据当前的角度范围补全扫掠角\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid ComplementSweep();\n\n\t/**\n    * @brief 与弧相交\n    * @details 计算与给定椭圆弧相交的交点,椭圆弧都视为有界的\n\t* \n\t* @param XPoint3dP cartesianPoints\n\t* @param XPoint3dP ellipse0Coffs\n\t* @param double * pEllipse0Angle\n\t* @param XPoint3dP ellipse1Coffs\n\t* @param double * pEllipse1Angle\n\t* @param XEllipse3dCR ellipse1\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectXYXEllipse3dBounded\n\t(\n\t\tXPoint3dP       cartesianPoints,\n\t\tXPoint3dP       ellipse0Coffs,\n\t\tdouble          *pEllipse0Angle,\n\t\tXPoint3dP       ellipse1Coffs,\n\t\tdouble          *pEllipse1Angle,\n\t\tXEllipse3dCR    ellipse1\n\t) const;\n\n\t/**\n\t* @brief 比例到角\n\t* @details 计算给定比例参数对应的参数角\n\t* \n\t* @param double fraction\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble FractionToAngle(double fraction) const;\n\n\t/**\n\t* @brief 获取最近点\n\t* @details 获取有界椭圆弧在XY方向上离给定空间点最近的点\n\t* \n\t* @param double & minAngle\n\t* @param double & minDistanceSquared\n\t* @param XPoint3dR minPoint\n\t* @param XPoint3dCR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool ClosestPointXYBounded\n\t(\n\t\tdouble          &minAngle,\n\t\tdouble          &minDistSquared,\n\t\tXPoint3dR       minPoint,\n\t\tXPoint3dCR      point\n\t) const;\n\n\t/**\n\t* @brief 完全扫掠\n\t* @details 将椭圆弧以现有的方向扫掠完整的360°\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid MakeFullSweep();\n\n    /**\n    * @brief 获取最近点\n    * @details 在应用变换矩阵（可选）后,计算椭圆弧在XY方向上离给定点最近的点（投影或端点）\n    * \n    * @param XPoint3dR closePoint\n    * @param double & closeParam\n    * @param double & distanceXY\n    * @param XPoint3dCR spacePoint\n    * @param XMatrix4dCP worldToLocal\n    * @return bool\n    *\n    * @author SZEWEC\n    * @since 2022/04/22\n    */\n    bool ClosestPointBoundedXY\n    (\n    XPoint3dR   closePoint,\n    double&     closeParam,\n    double&     distXY,\n    XPoint3dCR  spacePoint,\n    XMatrix4dCP worldToLocal\n    ) const;\n\n    /**\n    * @brief 获取最近点\n    * @details 在应用变换矩阵（可选）后,计算椭圆弧在XY方向上离给定点最近的点（投影或端点）\n    * \n    * @param XPoint3dR closePoint\n    * @param double & closeParam\n    * @param double & distanceXY\n    * @param XPoint3dCR spacePoint\n    * @param XMatrix4dCP worldToLocal\n    * @param bool extend0\n    * @param bool extend1\n    * @return bool\n    *\n    * @author SZEWEC\n    * @since 2022/04/22\n    */\n    bool ClosestPointBoundedXY\n    (\n    XPoint3dR   closePoint,\n    double&     closeParam,\n    double&     distXY,\n    XPoint3dCR  spacePoint,\n    XMatrix4dCP worldToLocal,\n    bool extend0,\n    bool extend1\n    ) const;\n\n\t/**\n\t* @brief 获取椭圆弧的起始与终止角度\n\t*\n\t* @param double & startAngle 起始角度\n\t* @param double & endAngle 终止角度\n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/30\n\t*/\n\tvoid GetLimits\n\t(\n\t\tdouble &startAngle,\n\t\tdouble &endAngle\n\t) const;\n\n\t/**\n\t* @brief 给定0°和90°的向量创建椭圆弧\n\t*\n\t* @param XPoint3dCR center\t\t\t\t\t中心点\n\t* @param XVec3dCR vector0\t\t\t\t\t0°向量（通常为沿着主轴的方向）\n\t* @param XVec3dCR vector90\t\t\t\t\t90°向量（通常为沿着短轴的方向）\n\t* @param double theta0\t\t\t\t\t\t起始点对应的角度\n\t* @param double sweep\t\t\t\t\t\t扫掠角度\n\t* @return ATEC_NAMESPACE_NAME::XEllipse3d\t椭圆弧\n\t*\n\t* @author SZEWEC\n\t* @since 2022/06/20\n\t*/\n\tstatic XEllipse3d FromVectors\n\t(\n\t\tXPoint3dCR center,\n\t\tXVec3dCR vector0,\n\t\tXVec3dCR vector90,\n\t\tdouble theta0,\n\t\tdouble sweep\n\t);\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XVec3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\nstruct ATGEOSET_EXPORT XVec3d : public XPoint3d\n{\n\tstatic XVec3d FromInterpolate(XVec3dCR vector0, double fraction, XVec3dCR vector1);\n\n\tstatic XVec3d From(double ax, double ay, double az = 0.0);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double  ay);\n\n\tstatic XVec3d From(XPoint3dCR point);\n\n\tvoid Init(XPoint3dCR point);\n\n\tstatic XVec3d FromStartEnd(XPoint3dCR start, XPoint3dCR end);\n\n\tstatic XVec3d FromStartEndNormalize(XPoint3dCR start, XPoint3dCR end);\n\n\tstatic XVec3d FromCCWPerpendicularXY(XVec3d source);\n\n\tstatic XVec3d FromRotate90Towards(XVec3dCR source, XVec3dCR target);\n\n\tstatic XVec3d FromRotate90Around(XVec3dCR source, XVec3dCR axis);\n\n\tstatic ValidatedXVec3d FromRotateVectorAroundVector(XVec3dCR source, XVec3dCR axis, XAngle angle);\n\n\tstatic XVec3d FromZero();\n\n\tstatic XVec3d UnitX();\n\n\tstatic XVec3d UnitY();\n\n\tstatic XVec3d UnitZ();\n\n\tdouble Normalize(XVec3dCR vector);\n\n\tdouble Normalize();\n\n\tdouble ScaleToLength(XVec3dCR vector, double length);\n\n\tdouble ScaleToLength(double length);\n\n\tstatic XVec3d FromXYAngleAndMagnitude\n\t(\n\t\tdouble          theta,\n\t\tdouble          magnitude\n\t);\n\n\tvoid InitFromXYAngleAndMagnitude\n\t(\n\t\tdouble          theta,\n\t\tdouble          magnitude\n\t);\n\n\tstatic XVec3d FromColumn(XRotMatrixCR matrix, int i);\n\n\tvoid InitFromColumn\n\t(\n\t\tXRotMatrixCR     matrix,\n\t\tint             col\n\t);\n\n\tvoid MultiplyTranspose(XRotMatrixCR matrix, XVec3dCR vector);\n\n\tvoid MultiplyTranspose(XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XVec3d FromStartEnd(XPoint4dCR start, XPoint4dCR end);\n\n\tstatic XVec3d FromCrossProduct(XVec3dCR vector0, XVec3dCR vector1);\n\n\tvoid CrossProduct(XVec3dCR vector1, XVec3dCR vector2);\n\n\tvoid CrossProduct(XVec3dCR vector1, XPoint3dCR point2);\n\n\tvoid CrossProduct(XPoint3dCR point1, XVec3dCR vector2);\n\n\tstatic XVec3d FromNormalizedCrossProductToPoints(XPoint3dCR origin, XPoint3dCR target1, XPoint3dCR target2);\n\n\tstatic XVec3d FromNormalizedCrossProduct(XVec3dCR vector0, XVec3dCR vector1);\n\n\tdouble NormalizedCrossProduct(XVec3dCR  vector1, XVec3dCR vector2);\n\n\tstatic XVec3d FromCrossProduct(double x0, double y0, double z0, double x1, double y1, double z1);\n\n\tvoid RotateXY(XVec3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tbool UnitPerpendicularXY(XVec3dCR vector);\n\n\tstatic ValidatedXVec3d FromUnitPerpendicularXY(XVec3dCR vector);\n\n\tstatic XVec3d FromSumOf(XVec3dCR vector0, XVec3dCR vector1);\n\n\tstatic XVec3d FromSumOf(XVec3dCR vector0, double scale0, XVec3dCR vector1, double scale1);\n\n\tvoid SumOf(XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2);\n\n\tstatic XVec3d FromSumOf(XVec3dCR vector0, double scale0, XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2);\n\n\tvoid SumOf(XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2, XVec3dCR vector3, double scale3);\n\n\tvoid SumOf(XVec3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XVec3dCR origin, XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2);\n\n\tvoid SumOf(XVec3dCR origin, XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2, XVec3dCR vector3, double scale3);\n\n\tstatic XVec3d FromScale(XVec3dCR vector, double scale);\n\n\tvoid Scale(XVec3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XVec3dCR vector);\n\n\tvoid Negate();\n\n\tdouble DotProduct(XVec3dCR vector2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n    double DotProductXY(XVec3dCR vector2) const;\n\n\tdouble TripleProduct(XVec3dCR vector2, XVec3dCR vector3) const;\n\n\tdouble Magnitude() const;\n\n\tdouble AngleTo(XVec3dCR vector2) const;\n\n\tdouble AngleToXY(XVec3dCR vector2) const;\n\n\tdouble SignedAngleTo\n\t(\n\t\tXVec3dCR        vector2,\n\t\tXVec3dCR        orientationVector\n\t) const;\n\n\tbool IsParallelTo(XVec3dCR vector2) const;\n\n\tbool IsPerpendicularTo(XVec3dCR vector2) const;\n\n\tbool      IsZero();\n\n\tvoid Multiply(XRotMatrixCR matrix, XVec3dCR vector);\n\n\tvoid Multiply(XRotMatrixCR matrix, double x, double y, double z);\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XPoint3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n /**\n * @brief 3D绌洪棿鐐圭被\n * @author SZEWC\n * @since 2022/04/13\n*/\nstruct ATGEOSET_EXPORT XPoint3d\n{\n\n\tdouble x;\n\n\tdouble y;\n\n\tdouble z;\n\n\tstatic XPoint3d From(double x, double y, double z = 0.0);\n\n\tstatic XPoint3d From(XPoint2dCR xy);\n\n\tstatic XPoint3d FromZero();\n\n\tstatic XPoint3d FromOne();\n\n\tstatic XPoint3d FromXYZ(double x, double y, double z);\n\n\tvoid Swap(XPoint3dR other);\n\n\tdouble DotDifference(XPoint3dCR origin, XVec3dCR vector) const;\n\n\tvoid Zero();\n\n\tvoid Init(XPoint2dCR source);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double ay);\n\n\tvoid SetComponent(double a, int index);\n\n\tdouble GetComponent(int index) const;\n\n\tvoid Interpolate(XPoint3dCR pnt0, double fractionParameter, XPoint3dCR point1);\n\n\tdouble Distance(XPoint3dCR point2) const;\n\n\tdouble DistanceXY(XPoint3dCR point2) const;\n\n\tbool DistanceXY(XPoint3dCR otherPoint, XMatrix4dCP matrix, double &distance) const;\n\n\tbool IsEqual(XPoint3dCR point2) const;\n\n\tbool IsEqual(XPoint3dCR point2, double tolerance) const;\n\n\tbool IsDisconnect() const;\n\n\tvoid InitDisconnect();\n\n\tvoid Init(XVec3dCR vector);\n\n\tvoid Subtract(XPoint3dCR base, XVec3dCR vector);\n\n\tvoid Add(XVec3dCR vector);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2, XVec3dCR point3, double scale3);\n\n\tvoid CrossProduct(XPoint3dCR point1, XPoint3dCR point2);\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble AngleTo(XPoint3dCR point2) const;\n\n\tvoid RotateXY(XPoint3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tdouble MagnitudeXY() const;\n\n\tvoid Scale(XPoint3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XPoint3dCR vector);\n\n\tvoid Negate();\n\n\tdouble Normalize(XPoint3dCR vector);\n\n\tdouble Normalize();\n\n\tvoid Subtract(XPoint3dCR point2);\n\n\tvoid DifferenceOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2, XPoint3dCR point3, double scale3);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2, XPoint3dCR point3, double a3);\n\n\tvoid Add(XPoint3dCR vector);\n\n\tvoid SumOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, XPoint3dCR point);\n\n\tstatic XPoint3d FromInterpolate(XPoint3dCR pntA, double fraction, XPoint3dCR pntB);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector, double scaleFactor);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1, XPoint3dCR point2, double scaleFactor2);\n\n\tstatic XPoint3d FromScale(XPoint3d point, double scale);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, XVec3dCR vector);\n\n\tbool AlmostEqual(XPoint3d const & dataB) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB) const;\n\n\tbool AlmostEqual(XPoint3d const & dataB, double abstol) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB, double abstol) const;\n\n\tstatic bool AlmostEqual(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tstatic bool AlmostEqualXY(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tdouble DistanceSquared(XPoint3dCR point2) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file CreateGeometryExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};\n code of file CurveSet.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 线串类\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct CurveSet : RefCountedBase, xvector<IBasicCurvePtr>\n{\n\n\tenum BoundaryType\n\t{\n\n\t\tBOUNDARY_TYPE_None = 0,\n\n\t\tBOUNDARY_TYPE_Open = 1,\n\n\t\tBOUNDARY_TYPE_Outer = 2,\n\n\t\tBOUNDARY_TYPE_Inner = 3,\n\n\t\tBOUNDARY_TYPE_ParityRegion = 4,\n\n\t\tBOUNDARY_TYPE_UnionRegion = 5,\n\t};\n\n\tenum InOutClassification\n\t{\n\t\tINOUT_Unknown = 0,\n\t\tINOUT_In = 1,\n\t\tINOUT_Out = 2,\n\t\tINOUT_On = 3\n\t};\n\nprotected:\n\tBoundaryType    m_boundaryType;\n\npublic:\n\t/**\n\t* @brief 设定边界\n\t* @details 设定曲线的边界类型\n\t* \n\t* @param BoundaryType BoundaryType\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void SetBoundaryType(BoundaryType BoundaryType);\n\n\t/**\n\t* @brief 获取叶节点\n\t* @details 通过只计算叶节点的索引深度搜索以获取目标叶节点\n\t* \n\t* @param size_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr FindIndexedLeaf(size_t index) const;\n\n\t/**\n\t* @brief 获取索引值\n\t* @details 深度搜索以获取给定叶节点的索引值\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @param size_t & index\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool LeafToIndex(IBasicCurveCP primitive, size_t &index) const;\n\n\t/**\n\t* @brief 获取叶节点个数\n\t* @details 获取曲线的叶节点个数\n\t* \n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesBelow() const;\n\n\texplicit CurveSet(BoundaryType boundaryType) { m_boundaryType = boundaryType; }\n\n\t/**\n\t* @brief 是否单元素曲线\n\t* @details 查询曲线是否只有一个基本元素\n\t* \n\t* @return IBasicCurve\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurve::BasicCurveType HasSingleBasicCurve() const;\n\n\t/**\n\t* @brief 获取边界类型\n\t* @details 获取曲线的边界类型\n\t* \n\t* @return BoundaryType\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT BoundaryType GetBoundaryType() const;\n\n\t/**\n\t* @brief 查询是否开\n\t* @details 查询是否开路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsOpenPath() const;\n\n\t/**\n\t* @brief 查询是否闭\n\t* @details 查询是否闭路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsClosedPath() const;\n\n\t/**\n\t* @brief 查询实际开闭\n\t* @details 查询是否名义上是开路径但起点和终点连接\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsPhysicallyClosedPath() const;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个带有给定边界类型没有成员的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个具有单个基本元素和给定边界类型的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @param IBasicCurvePtr primitive\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType, IBasicCurvePtr primitive);\n\n\t/**\n\t* @brief 拷贝\n\t* @details 返回一个深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr Clone() const;\n\n\t/**\n\t* @brief 倒角拷贝\n\t* @details 返回一个深度拷贝,在连续曲线之间插入圆角\n\t* \n\t* @param double radius\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithFillets(double radius) const;\n\n\t/**\n\t* @brief 闭合拷贝\n\t* @details 返回一个深度拷贝,闭合终端点的间隙\n\t* \n\t* @param CurveGapOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithGapsClosed(CurveGapOptionsCR options) const;\n\n\t/**\n\t* @brief 添加元素\n\t* @details 递归遍历source, 将所有叶节点添加到this, 返回添加的数量\n\t* \n\t* @param CurveSetCR source\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t AddPrimitives(CurveSetCR source);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 添加单个基本曲线\n\t* \n\t* @param IBasicCurvePtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(IBasicCurvePtr child);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 将chile的所有元素作为曲线成员添加\n\t* \n\t* @param CurveSetPtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(CurveSetPtr child);\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过XY方向的偏移后的深度拷贝\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneOffsetCurvesXY(CurveOffsetOptionsCR options);\n\n\t/**\n\t* @brief 获取叶节点数量\n\t* @details 计算指定类型的叶节点数量\n\t* \n\t* @param IBasicCurve::BasicCurveType targetType\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesOfType(IBasicCurve::BasicCurveType targetType) const;\n\n\t/**\n\t* @brief 用区域分割曲线\n\t* @details 用指定区域分割曲线,分别返回区域内、外和区域上的曲线\n\t* \n\t* @param CurveSetCR region\n\t* @param CurveSetP insideCollector\n\t* @param CurveSetP outsideCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByRegion(CurveSetCR region, CurveSetP insideCollector, CurveSetP outsideCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 用平面分割曲线\n\t* @details 用指定平面分割曲线,分别返回平面上方、下方和平面内的曲线\n\t* \n\t* @param XPlane3dCR plane\n\t* @param CurveSetP belowCollector\n\t* @param CurveSetP aboveCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByPlane(XPlane3dCR plane, CurveSetP belowCollector, CurveSetP aboveCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 拆分拷贝\n\t* @details 返回一个深度拷贝,但所有的多线段被拆分成单条线段\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithExplodedLinestrings() const;\n\n\t/**\n\t* @brief 获取质心\n\t* @details 返回包含曲线的质心(不考虑孤立点)\n\t* \n\t* @param double & length\n\t* @param XPoint3dR centroid\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  WireCentroid(double &length, XPoint3dR centroid) const;\n\n\t/**\n\t* @brief 获取质心、法向量和面积\n\t* @details 返回质心、法向量和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param XVec3dR normal\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CentroidNormalArea(XPoint3dR centroid, XVec3dR normal, double &area) const;\n\n\t/**\n\t* @brief 获取质心和面积\n\t* @details 返回XY平面方向上的质心和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  CentroidAreaXY(XPoint3dR centroid, double &area) const;\n\n\t/**\n\t* @brief 投影范围\n\t* @details 当投影到射线的时候,返回射线参数的范围\n\t* \n\t* @param XRay3dCR ray\n\t* @return XRange1d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT XRange1d ProjectedParameterRange(XRay3dCR ray) const;\n\n    /**\n    * @brief 局部坐标拷贝\n    * @details 返回曲线的深度复制并转换为与曲线相关联的局部坐标系统。\n    * \n    * @param LocalCoordinateSelect frameType\n    * @param TransformR localToWorld\n    * @param TransformR worldToLocal\n    * @param XRange3dR localRange\n    * @return CurveSetPtr\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT CurveSetPtr CloneInLocalCoordinates\n    (\n    LocalCoordinateSelect frameType,\n    TransformR localToWorld,\n    TransformR worldToLocal,\n    XRange3dR localRange\n    ) const;\n\n\t/**\n    * @brief 获取有坐标系的元素\n    * @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame) const;\n\n\t/**\n\t* @brief 获取有坐标系的元素\n\t* @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @param int searchPreference\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame, int srchPref) const;\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param xvector<XPoint3d> const & points\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(xvector<XPoint3d> const&points,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint3dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint3dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建多边形\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint2dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint2dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建矩形\n\t* @details 根据 XY 坐标创建矩形\n\t* \n\t* @param double x0\n\t* @param double y0\n\t* @param double x1\n\t* @param double y1\n\t* @param double z\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateRectangle(double x0, double y0, double x1, double y1, double z,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由给定线段创建边界类型为 BOUNDARY_TYPE_None 的曲线\n\t* \n\t* @param xvector<XSegment3d> const & segments\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(xvector<XSegment3d> const &segs);\n\n\t/**\n\t* @brief 创建圆盘\n\t* @details 为一个完整的椭圆(圆)盘创建一个曲线向量结构\n\t* \n\t* @param XEllipse3dCR arc\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateDisk(XEllipse3dCR arc, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer, bool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个仅有单一元素的曲线结构\n\t* \n\t* @param IBasicCurvePtr child\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(IBasicCurvePtr child, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open);\n\n\t/**\n\t* @brief B样条拷贝\n\t* @details 返回一个深度拷贝,作为B样条曲线\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneAsBsplines() const;\n\n\t/**\n\t* @brief 添加边缘点\n\t* @details 为所有的子节点添加边缘点\n\t* \n\t* @param xvector <XPoint3d> & points\n\t* @param IFacetOptionsR options\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AddStrokePoints(xvector <XPoint3d> &points, IFacetOptionsR options) const;\n\n    /**\n\t* @brief 添加面点\n\t* @details 沿着曲线计算指定距离的点\n\t* \n\t* @param xvector<double> const & distances\n\t* @param xvector<CurveDescInfo> & locations\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool AddSpacedPoints(xvector<double> const &distances, xvector<CurveDescInfo> &locations) const;\n\n\t/**\n\t* @brief 添加边缘\n\t* @details 在结构中添加所有边缘\n\t* \n\t* @param xvector <xvector<xvector<XPoint3d>>> & regionsPoints\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CollectLinearGeometry(xvector <xvector<xvector<XPoint3d>> > &regionsPoints) const;\n\n\t/**\n\t* @brief 获取B样条曲线\n\t* @details 将一个表示开放或闭合路径作为单个B样条曲线\n\t* \n\t* @return ATBsplineCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetBsplineCurve() const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n    /**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索最接近曲线的点。如果曲线是一个区域类型,同时要在该区域的内部寻找投影\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XPoint3dR curveOrRegionPoint\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification ClosestCurveOrRegionPoint(XPoint3dCR spacePoint, XPoint3dR curveOrRegionPoint) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点和终点\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点终点和他们的正切值\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @param XVec3dR unitTangentA\n\t* @param XVec3dR unitTangentB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\t/**\n\t* @brief 获取起点\n\t* @details 返回曲线的起点\n\t* \n\t* @param XPoint3dR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线总长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length() const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线经过变换后的总长度\n\t* \n\t* @param XRotMatrixCP worldToLocal\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length(XRotMatrixCP worldToLocal) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线的xyz范围\n\t* \n\t* @param XRange3dR range\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线经过变换后的范围\n\t* \n\t* @param XRange3dR range\n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\t/**\n\t* @brief 查询索引\n\t* @details 返回指定元素的索引\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t FindIndexOfPrimitive(IBasicCurveCP primitive) const;\n\n\t/**\n\t* @brief 复制曲线指定范围的曲线\n\t* @details 复制曲线指定索引和比例参数范围内的部分\n\t* \n\t* @param int index0\n\t* @param double fraction0\n\t* @param int index1\n\t* @param double fraction1\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n    ATGEOSET_EXPORT CurveSetPtr CloneBetweenCyclicIndexedFractions(int index0, double fraction0, int index1, double fraction1) const;\n\n\t/**\n\t* @brief 反转拷贝\n\t* @details 返回一个所有元素都被反转的深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneReversed() const;\n\n\t/**\n\t* @brief 查询是否包含非线性元素\n\t* @details 如果曲线有一个不非线性元素,则返回true。\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ContainsNonLinearPrimitive() const;\n\n\t/**\n\t* @brief 计算交点\n\t* @details 计算曲线与给定平面的交点\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 平面选中\n\t* @details 计算封闭曲线与平面的交叉点,并以奇偶性规则为设为起始对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param double tolerance\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr PlaneSection(XPlane3dCR plane, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 空间点位置情况\n\t* @details 当以XY平面视角看,测试给定点在曲线内、曲线上还是曲线外\n\t* \n\t* @param XPoint3dCR xyz\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification PointInOnOutXY(XPoint3dCR xyz) const;\n\n\t/**\n\t* @brief 射线击中情况\n\t* @details 测试射线击中曲线在区域内、区域上还是区域外\n\t* \n\t* @param XRay3dCR ray\n\t* @param SolidDescInfoR hitDetail\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification RayPierceInOnOut\n\t(\n\t\tXRay3dCR ray,\n\t\tSolidDescInfoR hitDetail\n\t) const;\n\n\t/**\n\t* @brief 原地变换\n\t* @details 应用给定变换并修改曲线\n\t* \n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\t/**\n\t* @brief 原地反转\n\t* @details 将所有元素进行反转\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串内的单个点被消除,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串相邻的空间点被消除（可选）,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @param bool doSimplifyLinestrings\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives(bool doSimplifyLinestrings);\n\n\t/**\n\t* @brief 原地修改以简化线串\n\t* @details 消除线串相邻的空间点\n\t* \n\t* @param double distanceTol\n\t* @param bool eliminateOverdraw\n\t* @param bool wrap\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void SimplifyLinestrings(double distTol, bool eliminateOverdraw, bool wrap);\n\n\t/**\n\t* @brief 重排元素\n\t* @details 将曲线元素重新排序以缩小元素首尾相连的间隙\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT double ReorderForSmallGaps();\n\n\t/**\n\t* @brief 链接元素\n\t* @details 将曲线的元素首尾相连\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AssembleChains();\n\n\t/**\n\t* @brief 区域相并\n\t* @details 返回给定两个区域的并\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaUnion(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相减\n\t* @details 返回给定两个区域的减\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaDifference(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相交\n\t* @details 返回给定两个区域的交\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaIntersection(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 循环索引\n\t* @details 返回给定索引值关于集合大小的模\n\t* \n\t* @param int index\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT size_t CyclicIndex(int index) const;\n\n\t/**\n\t* @brief 循环获取值\n\t* @details 根据给定索引的循环索引获取元素\n\t* \n\t* @param ptrdiff_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr GetCyclic(ptrdiff_t index) const;\n\n    /**\n    * @brief 获取索引\n    * @details 返回给定曲线元素的详细细节所对应的元素索引\n    * \n    * @param CurveDescInfo const & location\n    * @return size_t\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT size_t CurveDescInfoIndex(CurveDescInfo const& location) const;\n\n\t/**\n\t* @brief 与平面相交\n\t* @details 计算封闭曲线与平面的交叉点,返回以奇偶性规则构造的起止点对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool AppendClosedCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过给定偏移后的深度拷贝.\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AreaOffset(CurveOffsetOptionsCR options) const;\n\n\t/**\n\t* @brief 返回从index0,fraction0到index1,fraction1的曲线段\n\t* \n\t* @param int index0 \n\t* @param double fraction0 \n\t* @param int index1 \n\t* @param double fraction1 \n\t* @param bool allowExtrapolation \n\t* @return ATGEOSET_EXPORT CurveSetPtr \n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/17\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneBetweenDirectedFractions(int index0, double fraction0, int index1, double fraction1, bool allowExtrapolation) const;\n\n\t/**\n\t* @brief 返回输入的曲线的布尔奇运算结果（区域）\n\t*\n\t* @param CurveSetCR regionA\t\t\t\t\t左操作数\n\t* @param CurveSetCR regionB\t\t\t\t\t右操作数\n\t* @param BasicCurvePtrPairVector * newToOld\t（可选）包含新旧曲线的数组指针\n\t* @return ATGEOSET_EXPORT CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/07/22\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaParity(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n};\n\nstruct CurveCurve\n{\nprivate: CurveCurve();\npublic:\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tCurveSetR curveA,\n\t\tCurveSetR curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB,\n\t\tXMatrix4dCP    pWorldToLocal,\n\t\tbool         extend = false\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveR curveA,\n\t\tCurveSetR     curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tCurveSetCR chainA,\n\t\tCurveSetCR chainB\n\t);\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            double &fractionA,\n            XPoint3dR pntA,\n            double &fractionB,\n            XPoint3dR pntB\n            );\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            CurveDescInfoR detailA,\n            CurveDescInfoR detailB\n            );\n};\n\nstruct PathLocationDetail\n{\nprivate:\n\tCurveDescInfo m_curveDetail;\n\tint32_t m_pathIndex;\n\tdouble m_pathDistance;\npublic:\n\n\tATGEOSET_EXPORT PathLocationDetail();\n\n\tATGEOSET_EXPORT PathLocationDetail(PathLocationDetail const &other);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, int pathIndex = -1, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, size_t pathIndex, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(double distance);\n\n\tATGEOSET_EXPORT XPoint3d Point() const;\n\n\tATGEOSET_EXPORT CurveDescInfo GetCurveDescInfo() const;\n\n    ATGEOSET_EXPORT double DistanceFromPathStart() const;\n};\n\nstruct CurveSetWithDistanceIndex : RefCountedBase\n{\nprivate:\n\n\tstruct PathEntry : PathLocationDetail\n\t{\n\t\tdouble             m_projectedDistance;\n\t\tXRange3d           m_range;\n\t\tPathEntry(PathLocationDetail const &pathDetail, double projectedDist, XRange3dCR range)\n\t\t\t: PathLocationDetail(pathDetail),\n\t\t\tm_projectedDistance(projectedDist),\n\t\t\tm_range(range)\n\t\t{\n\t\t}\n\t\tPathEntry(double distance) : PathLocationDetail(distance), m_projectedDistance(distance) {}\n\n\t\tdouble GetDistance(bool projected) const;\n\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistanceXY(PathEntry const &dataA, PathEntry const &dataB);\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistance(PathEntry const &dataA, PathEntry const &dataB);\n\t};\n\n\tCurveSetPtr m_curveVector;\n\txvector<PathEntry> m_locations;\n\tCurveSetPtr m_savedPrimitives;\n\n\tXRotMatrix m_worldToViewRotMatrix;\n\tXRotMatrix m_viewToWorldRotMatrix;\n\tXRotMatrix m_flattenToView;\n\tXMatrix4d m_worldToView;\n\n\texplicit CurveSetWithDistanceIndex(XRotMatrix worldToView);\n\n\tCurveSetWithDistanceIndex();\n\npublic:\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create(XRotMatrix worldToView);\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create();\n\n\tATGEOSET_EXPORT void SetPath(CurveSetPtr &path);\n\n\tATGEOSET_EXPORT bool SearchByDistanceFromPathStart\n\t(\n\t\tdouble targetDist,\n\t\tPathLocationDetail &detail\n\t) const;\n\n    ATGEOSET_EXPORT PathLocationDetail SearchClosestPointBounded\n    (\n    XPoint3dCR spacePoint,\n    bool computeDistAlong\n    ) const;\n};\n\nEND_ATEC_NAMESPACE\n\n", "output": "\nvoid CreateGeometryExamples::CreateXEllipse3d_FromCenterStartEndPts()\n{\n\t//根据圆心,起点,终点创建圆弧\n\tXPoint3d center = XPoint3d::From(55, 0, 0);\n\tXPoint3d stPt = center - XVec3d::UnitX() * 50;\n\tXPoint3d edPt = center + XVec3d::UnitY() * 50;\n\tXEllipse3d arc2 = XEllipse3d::FromArcCenterStartEnd(center, stPt, edPt);\n\n\t//添加到视口\n\tCurveSetPtr curve = CurveSet::Create(IBasicCurve::CreateArc(arc2));\n\tAddGeometryToScene(curve);\n}\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};. You need to implement the function CreateXEllipse3d_FromPoints in the interface. Here are some apis that you can use and remember:\n code of file IBasicCurve.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 基本线元类\n* @author SZEWC\n* @since 2022/04/28\n*/\nstruct IBasicCurve : public RefCountedBase\n{\nprivate: virtual void IAmAbstractClass() = 0;\n\npublic:\n\tenum BasicCurveType\n\t{\n\t\tBCURVE_TYPE_Invalid = 0,\n\t\tBCURVE_TYPE_Line = 1,\n\t\tBCURVE_TYPE_LineString = 2,\n\t\tBCURVE_TYPE_Arc = 3,\n\t\tBCURVE_TYPE_BsplineCurve = 4,\n\t\tBCURVE_TYPE_InterpolationCurve = 5,\n\t\tBCURVE_TYPE_AkimaCurve = 6,\n\t\tBCURVE_TYPE_PointString = 7,\n\t\tBCURVE_TYPE_CurveSet = 8,\n\t\tBCURVE_TYPE_Spiral = 9,\n\t\tBCURVE_TYPE_PartialCurve = 10,\n\t\tBCURVE_TYPE_NotClassified = -1,\n\t};\n\n\tATGEOSET_EXPORT int64_t GetTag() const;\n\n\tATGEOSET_EXPORT int GetIntTag() const;\n\n\tATGEOSET_EXPORT void SetTag(int64_t tag);\n\n\tATGEOSET_EXPORT void SetTag(int tag);\n\n\tATGEOSET_EXPORT CurveSetPtr GetChildCurveSetP();\n\npublic:\n\tATGEOSET_EXPORT xvector<XPoint3d> * GetLineStringP();\n\n\tATGEOSET_EXPORT BasicCurveType           GetBasicCurveType() const;\n\n\tATGEOSET_EXPORT bool TryGetLine(XSegment3dR segment) const;\n\n\tATGEOSET_EXPORT bool TryGetArc(XEllipse3dR arc) const;\n\n\tATGEOSET_EXPORT XSegment3dCP                 GetLineCP() const;\n\n\tATGEOSET_EXPORT xvector<XPoint3d> const* GetLineStringCP() const;\n\n\tATGEOSET_EXPORT bool TryGetSegmentInLineString(XSegment3dR segment, size_t startPointIndex) const;\n\n\tATGEOSET_EXPORT XEllipse3dCP                 GetArcCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurveCP             GetBsplineCurveCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr             GetBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr            GetProxyBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT XSpiral2dPlacementCP         GetSpiralPlacementCP() const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLine(XSegment3dCR segment);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(XPoint3dCP points, size_t nPoints);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(xvector<XPoint3d> const &points);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateArc(XEllipse3dCR ellipse);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurveCR curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurvePtr& curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiral(XSpiral2dBaseCR spiral, TransformCR frame,\n\t\tdouble fractionA, double fractionB);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusBearingRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble endRadians,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusLengthRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble length,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT IBasicCurvePtr Clone() const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneComponent(ptrdiff_t componentIndex) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneAsSingleOffsetPrimitiveXY(CurveOffsetOptionsCR options) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XRay3dR ray) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, CurveDescInfo &detail) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2, XVec3dR derivative3) const;\n\n\tATGEOSET_EXPORT bool FractionToFrenetFrame(double f, TransformR frame) const;\n\n\tATGEOSET_EXPORT bool Length(double &length) const;\n\n\tATGEOSET_EXPORT bool Length(XRotMatrixCP worldToLocal, double &length) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\tATGEOSET_EXPORT size_t NumComponent() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetATBsplineCurvePtr(double fraction0 = 0.0, double fraction1 = 1.0) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(XRotMatrixCP worldToView, double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool TrySetStart(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TrySetEnd(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\tATGEOSET_EXPORT void  AppendCurvePlaneIntersections\n\t(\n\t\tXPlane3dByVectorsCR plane,\n\t\tUVBoundarySelect   bounded,\n\t\txvector<CurveAndSolidDescInfo> &intersections\n\t) const;\n\n\tATGEOSET_EXPORT bool AddStrokes(xvector <XPoint3d> &points, IFacetOptionsR options,\n\t\tbool includeStartPoint = true,\n\t\tdouble startFraction = 0.0,\n\t\tdouble endFraction = 1.0\n\t) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, double &fraction, XPoint3dR curvePoint) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneBetweenFractions(double fractionA, double fractionB, bool allowExtrapolation) const;\n\n\tATGEOSET_EXPORT CurveSetCP            GetChildCurveSetCP() const;\n\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(double startFraction, double endFraction, double &signedDist) const;\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(XRotMatrixCP worldToLocal, double startFraction, double endFraction, double &signedDist) const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateRectangle(double x0, double y0, double x1, double y1, double z, int areaSignPref = 0);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateChildCurveSet(CurveSetPtr source);\n\n\tATGEOSET_EXPORT bool  TryGetPartialCurveData(double &fractionA, double &fractionB, IBasicCurvePtr &parentCurve, int64_t &tag) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XEllipse3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 椭圆弧\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct ATGEOSET_EXPORT XEllipse3d\n{\n\tXPoint3d center;\n\tXVec3d   vector0;\n\tXVec3d   vector90;\n\tdouble start;\n\tdouble sweep;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 返回由已有椭圆的起始和终止比例定义的椭圆弧\n\t* \n\t* @param XEllipse3dCR parent\n\t* @param double startFraction\n\t* @param double endFraction\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromFractionInterval\n\t(\n\t\tXEllipse3dCR parent,\n\t\tdouble startFraction,\n\t\tdouble endFraction\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 根据椭圆的中心点、角度为0度和90度的点,以及扫掠角度创建一个椭圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point90\n\t* @param double theta0\n\t* @param double sweep\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromPoints(XPoint3dCR center, XPoint3dCR pnt0, XPoint3dCR pnt90, double theta0, double sweep);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由起始点,起始切线,半径,扫掠角度和面法向量创建椭圆弧\n\t* \n\t* @param XPoint3dCR pointA\n\t* @param XVec3dCR tangent\n\t* @param XVec3dCR planeNormal\n\t* @param double radius\n\t* @param double sweepRadians\n\t* @return ValidatedXEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic ValidatedXEllipse3d FromStartTangentNormalRadiusSweep(\n\n\t\tXPoint3dCR pntA,\n\t\tXVec3dCR tangent,\n\t\tXVec3dCR planeNormal,\n\t\tdouble radius,\n\t\tdouble sweepRadians\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由弧上的点创建椭圆弧\n\t* \n\t* @param XPoint3dCR start\n\t* @param XPoint3dCR middle\n\t* @param XPoint3dCR end\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromPointsOnArc(XPoint3dCR start, XPoint3dCR middle, XPoint3dCR end);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、起始点和终止点的切线创建椭圆弧（扫掠角取较小的一个）\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endTarget\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromArcCenterStartEnd(XPoint3dCR center, XPoint3dCR startPoint, XPoint3dCR endTarget);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、半径和面法向量创建完整的圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param XVec3dCR normal\n\t* @param double radius\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromCenterNormalRadius(XPoint3dCR center, XVec3dCR normal, double radius);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、半径创建XY平面上完整的圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param double radius\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromCenterRadiusXY(XPoint3dCR center, double radius);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 返回给定椭圆弧以反方向扫掠得到的椭圆弧\n\t* \n\t* @param XEllipse3dCR source\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromReversed(XEllipse3dCR source);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由给定点和扫掠角初始化数据\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point90\n\t* @param double theta0\n\t* @param double sweep\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid InitFromPoints\n\t(\n\t\tXPoint3dCR      center,\n\t\tXPoint3dCR      pnt0,\n\t\tXPoint3dCR      pnt90,\n\t\tdouble          theta0,\n\t\tdouble          sweep\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由椭圆弧上的点初始化数据\n\t* \n\t* @param XPoint3dCR start\n\t* @param XPoint3dCR middle\n\t* @param XPoint3dCR end\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool InitFromPointsOnArc\n\t(\n\t\tXPoint3dCR      start,\n\t\tXPoint3dCR      middle,\n\t\tXPoint3dCR      end\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由中心点、起始点和终止点的切线初始化数据（扫掠角取较小的一个）\n\t* \n\t* @param XPoint3dCR centerIN\n\t* @param XPoint3dCR startIN\n\t* @param XPoint3dCR end\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool InitFromArcCenterStartEnd\n\t(\n\t\tXPoint3dCR      centerIN,\n\t\tXPoint3dCR      startIN,\n\t\tXPoint3dCR      end\n\t);\n\n\t/**\n\t* @brief 设置起始点\n\t* @details 修改椭圆弧的起点和终点\n\t* \n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endPoint\n\t* @param bool ccw\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool SetStartEnd\n\t(\n\t\tXPoint3dCR      startPoint,\n\t\tXPoint3dCR      endPoint,\n\t\tbool            ccw\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由中心点、半径和面法向量初始化数据\n\t* \n\t* @param XPoint3dCR centerIN\n\t* @param XVec3dCR normal\n\t* @param double radius\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid InitFromCenterNormalRadius\n\t(\n\t\tXPoint3dCR      centerIN,\n\t\tXVec3dCR      normal,\n\t\tdouble          radius\n\t);\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点\n\t* \n\t* @param XPoint3dR point\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       point,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 角到点\n\t* @details 返回椭圆弧给定参数角对应的空间点\n\t* \n\t* @param double theta\n\t* @return XPoint3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tXPoint3d RadiansToPoint(double theta) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 返回椭圆弧给定参数坐标对应的空间点\n\t* \n\t* @param XPoint3dR point\n\t* @param double xx\n\t* @param double yy\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       point,\n\t\tdouble          xx,\n\t\tdouble          yy\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点\n\t* \n\t* @param XPoint4dR point\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint4dR       point,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 获取椭圆弧的起点和终点\n\t* \n\t* @param XPoint3dR startPoint\n\t* @param XPoint3dR endPoint\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid EvaluateEndPoints\n\t(\n\t\tXPoint3dR       startPoint,\n\t\tXPoint3dR       endPoint\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点以及在参数值处的导数\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param XVec3dR dX\n\t* @param XVec3dR ddX\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tXVec3dR       dX,\n\t\tXVec3dR       ddX,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算给定的参数角比例对应的空间点\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param double fraction\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid FractionParameterToPoint\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tdouble          fraction\n\t) const;\n\n\t/**\n\t* @brief 比例到点\n\t* @details 返回给定的参数角比例对应的空间点\n\t* \n\t* @param double fraction\n\t* @return XPoint3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tXPoint3d FractionToPoint(double fraction) const;\n\n\t/**\n\t* @brief 比例到导数\n\t* @details 返回给定的参数角比例对应的空间点及在该点处的导数\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param XVec3dR dX\n\t* @param XVec3dR ddX\n\t* @param double fraction\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid FractionParameterToDerivatives\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tXVec3dR       dX,\n\t\tXVec3dR       ddX,\n\t\tdouble          fraction\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算给定的参数角比例对应的空间点及在该点处的导数,以数组形式返回\n\t* \n\t* @param XPoint3dP point3dX\n\t* @param int numDerivative\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dP       pnt3dX,\n\t\tint             numDerivative,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 点到角\n\t* @details 计算椭圆弧上的点对应的参数角\n\t* \n\t* @param XPoint3dCR point\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble PointToAngle(XPoint3dCR point) const;\n\n\t/**\n\t* @brief 投影点\n\t* @details 将给定点投影到椭圆弧所在的平面上\n\t* \n\t* @param XPoint3dR xYZNear\n\t* @param double & coff0\n\t* @param double & coff90\n\t* @param XPoint3dCR xYZ\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool ProjectPointToPlane\n\t(\n\t\tXPoint3dR       xYZNear,\n\t\tdouble          &coff0,\n\t\tdouble          &coff90,\n\t\tXPoint3dCR      xYZ\n\t) const;\n\n\t/**\n\t* @brief 角到比例\n\t* @details 计算给定参数角所对应椭圆弧上的比例\n\t* \n\t* @param double angle\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble AngleToFraction(double angle) const;\n\n\t/**\n\t* @brief 弧长\n\t* @details 返回椭圆弧的长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble ArcLength() const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 计算椭圆弧空间点的范围\n\t* \n\t* @param XRange3dR range\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief XY方向上与直线相交\n\t* @details 计算XY方向上与直线相交的交点,椭圆弧和直线都视为无界的\n\t* \n\t* @param XPoint3dP cartesianPoints\n\t* @param double * pLineParams\n\t* @param XPoint3dP ellipseCoffs\n\t* @param double * pEllipseAngle\n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endPoint\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectXYLine\n\t(\n\t\tXPoint3dP       cartesianPoints,\n\t\tdouble          *pLineParams,\n\t\tXPoint3dP       ellipseCoffs,\n\t\tdouble          *pEllipseAngle,\n\t\tXPoint3dCR      startPoint,\n\t\tXPoint3dCR      endPoint\n\t) const;\n\n\t/**\n\t* @brief 是否完整\n\t* @details 查询椭圆弧是否完整\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCircular() const;\n\n\t/**\n\t* @brief 是否完整\n\t* @details 查询椭圆弧是否完整\n\t* \n\t* @param double & radius\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCircular(double &radius) const;\n\n\t/**\n\t* @brief 是否逆时针\n\t* @details 查询椭圆弧在XY平面内的投影是否逆时针扫掠\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCCWSweepXY() const;\n\n\t/**\n\t* @brief 与线段相交\n\t* @details 计算与给定椭圆弧相交的交点,椭圆弧和线段都视为无界的\n\t* \n\t* @param XPoint3dP pointArray\n\t* @param XPoint3dP ellipseParams\n\t* @param double * pLineParams\n\t* @param XSegment3dCR segment\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectSweptXSegment3d\n\t(\n\t\tXPoint3dP       pntArray,\n\t\tXPoint3dP       ellipseParams,\n\t\tdouble          *pLineParams,\n\t\tXSegment3dCR    segment\n\t) const;\n\n\t/**\n\t* @brief 与线段相交\n\t* @details 计算与给定线段相交的交点,椭圆弧和线段都视为有界的\n\t* \n\t* @param XPoint3dP pointArray\n\t* @param XPoint3dP ellipseParams\n\t* @param double * pLineParams\n\t* @param XSegment3dCR segment\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectSweptXSegment3dBounded\n\t(\n\t\tXPoint3dP       pntArray,\n\t\tXPoint3dP       ellipseParams,\n\t\tdouble          *pLineParams,\n\t\tXSegment3dCR    segment\n\t) const;\n\n\t/**\n\t* @brief 转换为BR类型3D元素\n\t* @details 将椭圆弧转换为BR类型的3D元素\n\t* \n\t* @param XPoint3dR centerOUT\n\t* @param double * pQuatWXYZ\n\t* @param XVec3dR directionX\n\t* @param XVec3dR directionY\n\t* @param double & rx\n\t* @param double & ry\n\t* @param double & startAngle\n\t* @param double & sweepAngle\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetATFields3d\n\t(\n\t\tXPoint3dR       centerOUT,\n\t\tdouble *        pQuatWXYZ,\n\t\tXVec3dR         directionX,\n\t\tXVec3dR         directionY,\n\t\tdouble          &rx,\n\t\tdouble          &ry,\n\t\tdouble          &startAngle,\n\t\tdouble          &sweepAngle\n\t) const;\n\n\t/**\n\t* @brief 设置扫掠角\n\t* @details 设置椭圆弧的扫掠角\n\t* \n\t* @param double startAngle\n\t* @param double sweepIN\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid SetSweep\n\t(\n\t\tdouble          startAngle,\n\t\tdouble          sweepIN\n\t);\n\n\t/**\n    * @brief 获取扫掠角\n    * @details 获取椭圆弧的扫掠角\n\t* \n\t* @param double & startAngle\n\t* @param double & sweepAngle\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetSweep\n\t(\n\t\tdouble          &startAngle,\n\t\tdouble          &sweepAngle\n\t) const;\n\n\t/**\n\t* @brief 补全扫掠角\n\t* @details 根据当前的角度范围补全扫掠角\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid ComplementSweep();\n\n\t/**\n    * @brief 与弧相交\n    * @details 计算与给定椭圆弧相交的交点,椭圆弧都视为有界的\n\t* \n\t* @param XPoint3dP cartesianPoints\n\t* @param XPoint3dP ellipse0Coffs\n\t* @param double * pEllipse0Angle\n\t* @param XPoint3dP ellipse1Coffs\n\t* @param double * pEllipse1Angle\n\t* @param XEllipse3dCR ellipse1\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectXYXEllipse3dBounded\n\t(\n\t\tXPoint3dP       cartesianPoints,\n\t\tXPoint3dP       ellipse0Coffs,\n\t\tdouble          *pEllipse0Angle,\n\t\tXPoint3dP       ellipse1Coffs,\n\t\tdouble          *pEllipse1Angle,\n\t\tXEllipse3dCR    ellipse1\n\t) const;\n\n\t/**\n\t* @brief 比例到角\n\t* @details 计算给定比例参数对应的参数角\n\t* \n\t* @param double fraction\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble FractionToAngle(double fraction) const;\n\n\t/**\n\t* @brief 获取最近点\n\t* @details 获取有界椭圆弧在XY方向上离给定空间点最近的点\n\t* \n\t* @param double & minAngle\n\t* @param double & minDistanceSquared\n\t* @param XPoint3dR minPoint\n\t* @param XPoint3dCR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool ClosestPointXYBounded\n\t(\n\t\tdouble          &minAngle,\n\t\tdouble          &minDistSquared,\n\t\tXPoint3dR       minPoint,\n\t\tXPoint3dCR      point\n\t) const;\n\n\t/**\n\t* @brief 完全扫掠\n\t* @details 将椭圆弧以现有的方向扫掠完整的360°\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid MakeFullSweep();\n\n    /**\n    * @brief 获取最近点\n    * @details 在应用变换矩阵（可选）后,计算椭圆弧在XY方向上离给定点最近的点（投影或端点）\n    * \n    * @param XPoint3dR closePoint\n    * @param double & closeParam\n    * @param double & distanceXY\n    * @param XPoint3dCR spacePoint\n    * @param XMatrix4dCP worldToLocal\n    * @return bool\n    *\n    * @author SZEWEC\n    * @since 2022/04/22\n    */\n    bool ClosestPointBoundedXY\n    (\n    XPoint3dR   closePoint,\n    double&     closeParam,\n    double&     distXY,\n    XPoint3dCR  spacePoint,\n    XMatrix4dCP worldToLocal\n    ) const;\n\n    /**\n    * @brief 获取最近点\n    * @details 在应用变换矩阵（可选）后,计算椭圆弧在XY方向上离给定点最近的点（投影或端点）\n    * \n    * @param XPoint3dR closePoint\n    * @param double & closeParam\n    * @param double & distanceXY\n    * @param XPoint3dCR spacePoint\n    * @param XMatrix4dCP worldToLocal\n    * @param bool extend0\n    * @param bool extend1\n    * @return bool\n    *\n    * @author SZEWEC\n    * @since 2022/04/22\n    */\n    bool ClosestPointBoundedXY\n    (\n    XPoint3dR   closePoint,\n    double&     closeParam,\n    double&     distXY,\n    XPoint3dCR  spacePoint,\n    XMatrix4dCP worldToLocal,\n    bool extend0,\n    bool extend1\n    ) const;\n\n\t/**\n\t* @brief 获取椭圆弧的起始与终止角度\n\t*\n\t* @param double & startAngle 起始角度\n\t* @param double & endAngle 终止角度\n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/30\n\t*/\n\tvoid GetLimits\n\t(\n\t\tdouble &startAngle,\n\t\tdouble &endAngle\n\t) const;\n\n\t/**\n\t* @brief 给定0°和90°的向量创建椭圆弧\n\t*\n\t* @param XPoint3dCR center\t\t\t\t\t中心点\n\t* @param XVec3dCR vector0\t\t\t\t\t0°向量（通常为沿着主轴的方向）\n\t* @param XVec3dCR vector90\t\t\t\t\t90°向量（通常为沿着短轴的方向）\n\t* @param double theta0\t\t\t\t\t\t起始点对应的角度\n\t* @param double sweep\t\t\t\t\t\t扫掠角度\n\t* @return ATEC_NAMESPACE_NAME::XEllipse3d\t椭圆弧\n\t*\n\t* @author SZEWEC\n\t* @since 2022/06/20\n\t*/\n\tstatic XEllipse3d FromVectors\n\t(\n\t\tXPoint3dCR center,\n\t\tXVec3dCR vector0,\n\t\tXVec3dCR vector90,\n\t\tdouble theta0,\n\t\tdouble sweep\n\t);\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XPoint3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n /**\n * @brief 3D绌洪棿鐐圭被\n * @author SZEWC\n * @since 2022/04/13\n*/\nstruct ATGEOSET_EXPORT XPoint3d\n{\n\n\tdouble x;\n\n\tdouble y;\n\n\tdouble z;\n\n\tstatic XPoint3d From(double x, double y, double z = 0.0);\n\n\tstatic XPoint3d From(XPoint2dCR xy);\n\n\tstatic XPoint3d FromZero();\n\n\tstatic XPoint3d FromOne();\n\n\tstatic XPoint3d FromXYZ(double x, double y, double z);\n\n\tvoid Swap(XPoint3dR other);\n\n\tdouble DotDifference(XPoint3dCR origin, XVec3dCR vector) const;\n\n\tvoid Zero();\n\n\tvoid Init(XPoint2dCR source);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double ay);\n\n\tvoid SetComponent(double a, int index);\n\n\tdouble GetComponent(int index) const;\n\n\tvoid Interpolate(XPoint3dCR pnt0, double fractionParameter, XPoint3dCR point1);\n\n\tdouble Distance(XPoint3dCR point2) const;\n\n\tdouble DistanceXY(XPoint3dCR point2) const;\n\n\tbool DistanceXY(XPoint3dCR otherPoint, XMatrix4dCP matrix, double &distance) const;\n\n\tbool IsEqual(XPoint3dCR point2) const;\n\n\tbool IsEqual(XPoint3dCR point2, double tolerance) const;\n\n\tbool IsDisconnect() const;\n\n\tvoid InitDisconnect();\n\n\tvoid Init(XVec3dCR vector);\n\n\tvoid Subtract(XPoint3dCR base, XVec3dCR vector);\n\n\tvoid Add(XVec3dCR vector);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2, XVec3dCR point3, double scale3);\n\n\tvoid CrossProduct(XPoint3dCR point1, XPoint3dCR point2);\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble AngleTo(XPoint3dCR point2) const;\n\n\tvoid RotateXY(XPoint3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tdouble MagnitudeXY() const;\n\n\tvoid Scale(XPoint3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XPoint3dCR vector);\n\n\tvoid Negate();\n\n\tdouble Normalize(XPoint3dCR vector);\n\n\tdouble Normalize();\n\n\tvoid Subtract(XPoint3dCR point2);\n\n\tvoid DifferenceOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2, XPoint3dCR point3, double scale3);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2, XPoint3dCR point3, double a3);\n\n\tvoid Add(XPoint3dCR vector);\n\n\tvoid SumOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, XPoint3dCR point);\n\n\tstatic XPoint3d FromInterpolate(XPoint3dCR pntA, double fraction, XPoint3dCR pntB);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector, double scaleFactor);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1, XPoint3dCR point2, double scaleFactor2);\n\n\tstatic XPoint3d FromScale(XPoint3d point, double scale);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, XVec3dCR vector);\n\n\tbool AlmostEqual(XPoint3d const & dataB) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB) const;\n\n\tbool AlmostEqual(XPoint3d const & dataB, double abstol) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB, double abstol) const;\n\n\tstatic bool AlmostEqual(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tstatic bool AlmostEqualXY(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tdouble DistanceSquared(XPoint3dCR point2) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file CreateGeometryExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};\n code of file CurveSet.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 线串类\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct CurveSet : RefCountedBase, xvector<IBasicCurvePtr>\n{\n\n\tenum BoundaryType\n\t{\n\n\t\tBOUNDARY_TYPE_None = 0,\n\n\t\tBOUNDARY_TYPE_Open = 1,\n\n\t\tBOUNDARY_TYPE_Outer = 2,\n\n\t\tBOUNDARY_TYPE_Inner = 3,\n\n\t\tBOUNDARY_TYPE_ParityRegion = 4,\n\n\t\tBOUNDARY_TYPE_UnionRegion = 5,\n\t};\n\n\tenum InOutClassification\n\t{\n\t\tINOUT_Unknown = 0,\n\t\tINOUT_In = 1,\n\t\tINOUT_Out = 2,\n\t\tINOUT_On = 3\n\t};\n\nprotected:\n\tBoundaryType    m_boundaryType;\n\npublic:\n\t/**\n\t* @brief 设定边界\n\t* @details 设定曲线的边界类型\n\t* \n\t* @param BoundaryType BoundaryType\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void SetBoundaryType(BoundaryType BoundaryType);\n\n\t/**\n\t* @brief 获取叶节点\n\t* @details 通过只计算叶节点的索引深度搜索以获取目标叶节点\n\t* \n\t* @param size_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr FindIndexedLeaf(size_t index) const;\n\n\t/**\n\t* @brief 获取索引值\n\t* @details 深度搜索以获取给定叶节点的索引值\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @param size_t & index\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool LeafToIndex(IBasicCurveCP primitive, size_t &index) const;\n\n\t/**\n\t* @brief 获取叶节点个数\n\t* @details 获取曲线的叶节点个数\n\t* \n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesBelow() const;\n\n\texplicit CurveSet(BoundaryType boundaryType) { m_boundaryType = boundaryType; }\n\n\t/**\n\t* @brief 是否单元素曲线\n\t* @details 查询曲线是否只有一个基本元素\n\t* \n\t* @return IBasicCurve\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurve::BasicCurveType HasSingleBasicCurve() const;\n\n\t/**\n\t* @brief 获取边界类型\n\t* @details 获取曲线的边界类型\n\t* \n\t* @return BoundaryType\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT BoundaryType GetBoundaryType() const;\n\n\t/**\n\t* @brief 查询是否开\n\t* @details 查询是否开路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsOpenPath() const;\n\n\t/**\n\t* @brief 查询是否闭\n\t* @details 查询是否闭路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsClosedPath() const;\n\n\t/**\n\t* @brief 查询实际开闭\n\t* @details 查询是否名义上是开路径但起点和终点连接\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsPhysicallyClosedPath() const;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个带有给定边界类型没有成员的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个具有单个基本元素和给定边界类型的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @param IBasicCurvePtr primitive\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType, IBasicCurvePtr primitive);\n\n\t/**\n\t* @brief 拷贝\n\t* @details 返回一个深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr Clone() const;\n\n\t/**\n\t* @brief 倒角拷贝\n\t* @details 返回一个深度拷贝,在连续曲线之间插入圆角\n\t* \n\t* @param double radius\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithFillets(double radius) const;\n\n\t/**\n\t* @brief 闭合拷贝\n\t* @details 返回一个深度拷贝,闭合终端点的间隙\n\t* \n\t* @param CurveGapOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithGapsClosed(CurveGapOptionsCR options) const;\n\n\t/**\n\t* @brief 添加元素\n\t* @details 递归遍历source, 将所有叶节点添加到this, 返回添加的数量\n\t* \n\t* @param CurveSetCR source\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t AddPrimitives(CurveSetCR source);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 添加单个基本曲线\n\t* \n\t* @param IBasicCurvePtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(IBasicCurvePtr child);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 将chile的所有元素作为曲线成员添加\n\t* \n\t* @param CurveSetPtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(CurveSetPtr child);\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过XY方向的偏移后的深度拷贝\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneOffsetCurvesXY(CurveOffsetOptionsCR options);\n\n\t/**\n\t* @brief 获取叶节点数量\n\t* @details 计算指定类型的叶节点数量\n\t* \n\t* @param IBasicCurve::BasicCurveType targetType\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesOfType(IBasicCurve::BasicCurveType targetType) const;\n\n\t/**\n\t* @brief 用区域分割曲线\n\t* @details 用指定区域分割曲线,分别返回区域内、外和区域上的曲线\n\t* \n\t* @param CurveSetCR region\n\t* @param CurveSetP insideCollector\n\t* @param CurveSetP outsideCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByRegion(CurveSetCR region, CurveSetP insideCollector, CurveSetP outsideCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 用平面分割曲线\n\t* @details 用指定平面分割曲线,分别返回平面上方、下方和平面内的曲线\n\t* \n\t* @param XPlane3dCR plane\n\t* @param CurveSetP belowCollector\n\t* @param CurveSetP aboveCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByPlane(XPlane3dCR plane, CurveSetP belowCollector, CurveSetP aboveCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 拆分拷贝\n\t* @details 返回一个深度拷贝,但所有的多线段被拆分成单条线段\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithExplodedLinestrings() const;\n\n\t/**\n\t* @brief 获取质心\n\t* @details 返回包含曲线的质心(不考虑孤立点)\n\t* \n\t* @param double & length\n\t* @param XPoint3dR centroid\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  WireCentroid(double &length, XPoint3dR centroid) const;\n\n\t/**\n\t* @brief 获取质心、法向量和面积\n\t* @details 返回质心、法向量和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param XVec3dR normal\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CentroidNormalArea(XPoint3dR centroid, XVec3dR normal, double &area) const;\n\n\t/**\n\t* @brief 获取质心和面积\n\t* @details 返回XY平面方向上的质心和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  CentroidAreaXY(XPoint3dR centroid, double &area) const;\n\n\t/**\n\t* @brief 投影范围\n\t* @details 当投影到射线的时候,返回射线参数的范围\n\t* \n\t* @param XRay3dCR ray\n\t* @return XRange1d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT XRange1d ProjectedParameterRange(XRay3dCR ray) const;\n\n    /**\n    * @brief 局部坐标拷贝\n    * @details 返回曲线的深度复制并转换为与曲线相关联的局部坐标系统。\n    * \n    * @param LocalCoordinateSelect frameType\n    * @param TransformR localToWorld\n    * @param TransformR worldToLocal\n    * @param XRange3dR localRange\n    * @return CurveSetPtr\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT CurveSetPtr CloneInLocalCoordinates\n    (\n    LocalCoordinateSelect frameType,\n    TransformR localToWorld,\n    TransformR worldToLocal,\n    XRange3dR localRange\n    ) const;\n\n\t/**\n    * @brief 获取有坐标系的元素\n    * @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame) const;\n\n\t/**\n\t* @brief 获取有坐标系的元素\n\t* @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @param int searchPreference\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame, int srchPref) const;\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param xvector<XPoint3d> const & points\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(xvector<XPoint3d> const&points,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint3dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint3dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建多边形\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint2dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint2dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建矩形\n\t* @details 根据 XY 坐标创建矩形\n\t* \n\t* @param double x0\n\t* @param double y0\n\t* @param double x1\n\t* @param double y1\n\t* @param double z\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateRectangle(double x0, double y0, double x1, double y1, double z,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由给定线段创建边界类型为 BOUNDARY_TYPE_None 的曲线\n\t* \n\t* @param xvector<XSegment3d> const & segments\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(xvector<XSegment3d> const &segs);\n\n\t/**\n\t* @brief 创建圆盘\n\t* @details 为一个完整的椭圆(圆)盘创建一个曲线向量结构\n\t* \n\t* @param XEllipse3dCR arc\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateDisk(XEllipse3dCR arc, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer, bool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个仅有单一元素的曲线结构\n\t* \n\t* @param IBasicCurvePtr child\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(IBasicCurvePtr child, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open);\n\n\t/**\n\t* @brief B样条拷贝\n\t* @details 返回一个深度拷贝,作为B样条曲线\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneAsBsplines() const;\n\n\t/**\n\t* @brief 添加边缘点\n\t* @details 为所有的子节点添加边缘点\n\t* \n\t* @param xvector <XPoint3d> & points\n\t* @param IFacetOptionsR options\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AddStrokePoints(xvector <XPoint3d> &points, IFacetOptionsR options) const;\n\n    /**\n\t* @brief 添加面点\n\t* @details 沿着曲线计算指定距离的点\n\t* \n\t* @param xvector<double> const & distances\n\t* @param xvector<CurveDescInfo> & locations\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool AddSpacedPoints(xvector<double> const &distances, xvector<CurveDescInfo> &locations) const;\n\n\t/**\n\t* @brief 添加边缘\n\t* @details 在结构中添加所有边缘\n\t* \n\t* @param xvector <xvector<xvector<XPoint3d>>> & regionsPoints\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CollectLinearGeometry(xvector <xvector<xvector<XPoint3d>> > &regionsPoints) const;\n\n\t/**\n\t* @brief 获取B样条曲线\n\t* @details 将一个表示开放或闭合路径作为单个B样条曲线\n\t* \n\t* @return ATBsplineCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetBsplineCurve() const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n    /**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索最接近曲线的点。如果曲线是一个区域类型,同时要在该区域的内部寻找投影\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XPoint3dR curveOrRegionPoint\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification ClosestCurveOrRegionPoint(XPoint3dCR spacePoint, XPoint3dR curveOrRegionPoint) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点和终点\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点终点和他们的正切值\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @param XVec3dR unitTangentA\n\t* @param XVec3dR unitTangentB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\t/**\n\t* @brief 获取起点\n\t* @details 返回曲线的起点\n\t* \n\t* @param XPoint3dR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线总长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length() const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线经过变换后的总长度\n\t* \n\t* @param XRotMatrixCP worldToLocal\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length(XRotMatrixCP worldToLocal) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线的xyz范围\n\t* \n\t* @param XRange3dR range\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线经过变换后的范围\n\t* \n\t* @param XRange3dR range\n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\t/**\n\t* @brief 查询索引\n\t* @details 返回指定元素的索引\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t FindIndexOfPrimitive(IBasicCurveCP primitive) const;\n\n\t/**\n\t* @brief 复制曲线指定范围的曲线\n\t* @details 复制曲线指定索引和比例参数范围内的部分\n\t* \n\t* @param int index0\n\t* @param double fraction0\n\t* @param int index1\n\t* @param double fraction1\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n    ATGEOSET_EXPORT CurveSetPtr CloneBetweenCyclicIndexedFractions(int index0, double fraction0, int index1, double fraction1) const;\n\n\t/**\n\t* @brief 反转拷贝\n\t* @details 返回一个所有元素都被反转的深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneReversed() const;\n\n\t/**\n\t* @brief 查询是否包含非线性元素\n\t* @details 如果曲线有一个不非线性元素,则返回true。\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ContainsNonLinearPrimitive() const;\n\n\t/**\n\t* @brief 计算交点\n\t* @details 计算曲线与给定平面的交点\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 平面选中\n\t* @details 计算封闭曲线与平面的交叉点,并以奇偶性规则为设为起始对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param double tolerance\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr PlaneSection(XPlane3dCR plane, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 空间点位置情况\n\t* @details 当以XY平面视角看,测试给定点在曲线内、曲线上还是曲线外\n\t* \n\t* @param XPoint3dCR xyz\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification PointInOnOutXY(XPoint3dCR xyz) const;\n\n\t/**\n\t* @brief 射线击中情况\n\t* @details 测试射线击中曲线在区域内、区域上还是区域外\n\t* \n\t* @param XRay3dCR ray\n\t* @param SolidDescInfoR hitDetail\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification RayPierceInOnOut\n\t(\n\t\tXRay3dCR ray,\n\t\tSolidDescInfoR hitDetail\n\t) const;\n\n\t/**\n\t* @brief 原地变换\n\t* @details 应用给定变换并修改曲线\n\t* \n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\t/**\n\t* @brief 原地反转\n\t* @details 将所有元素进行反转\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串内的单个点被消除,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串相邻的空间点被消除（可选）,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @param bool doSimplifyLinestrings\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives(bool doSimplifyLinestrings);\n\n\t/**\n\t* @brief 原地修改以简化线串\n\t* @details 消除线串相邻的空间点\n\t* \n\t* @param double distanceTol\n\t* @param bool eliminateOverdraw\n\t* @param bool wrap\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void SimplifyLinestrings(double distTol, bool eliminateOverdraw, bool wrap);\n\n\t/**\n\t* @brief 重排元素\n\t* @details 将曲线元素重新排序以缩小元素首尾相连的间隙\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT double ReorderForSmallGaps();\n\n\t/**\n\t* @brief 链接元素\n\t* @details 将曲线的元素首尾相连\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AssembleChains();\n\n\t/**\n\t* @brief 区域相并\n\t* @details 返回给定两个区域的并\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaUnion(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相减\n\t* @details 返回给定两个区域的减\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaDifference(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相交\n\t* @details 返回给定两个区域的交\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaIntersection(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 循环索引\n\t* @details 返回给定索引值关于集合大小的模\n\t* \n\t* @param int index\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT size_t CyclicIndex(int index) const;\n\n\t/**\n\t* @brief 循环获取值\n\t* @details 根据给定索引的循环索引获取元素\n\t* \n\t* @param ptrdiff_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr GetCyclic(ptrdiff_t index) const;\n\n    /**\n    * @brief 获取索引\n    * @details 返回给定曲线元素的详细细节所对应的元素索引\n    * \n    * @param CurveDescInfo const & location\n    * @return size_t\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT size_t CurveDescInfoIndex(CurveDescInfo const& location) const;\n\n\t/**\n\t* @brief 与平面相交\n\t* @details 计算封闭曲线与平面的交叉点,返回以奇偶性规则构造的起止点对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool AppendClosedCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过给定偏移后的深度拷贝.\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AreaOffset(CurveOffsetOptionsCR options) const;\n\n\t/**\n\t* @brief 返回从index0,fraction0到index1,fraction1的曲线段\n\t* \n\t* @param int index0 \n\t* @param double fraction0 \n\t* @param int index1 \n\t* @param double fraction1 \n\t* @param bool allowExtrapolation \n\t* @return ATGEOSET_EXPORT CurveSetPtr \n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/17\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneBetweenDirectedFractions(int index0, double fraction0, int index1, double fraction1, bool allowExtrapolation) const;\n\n\t/**\n\t* @brief 返回输入的曲线的布尔奇运算结果（区域）\n\t*\n\t* @param CurveSetCR regionA\t\t\t\t\t左操作数\n\t* @param CurveSetCR regionB\t\t\t\t\t右操作数\n\t* @param BasicCurvePtrPairVector * newToOld\t（可选）包含新旧曲线的数组指针\n\t* @return ATGEOSET_EXPORT CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/07/22\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaParity(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n};\n\nstruct CurveCurve\n{\nprivate: CurveCurve();\npublic:\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tCurveSetR curveA,\n\t\tCurveSetR curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB,\n\t\tXMatrix4dCP    pWorldToLocal,\n\t\tbool         extend = false\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveR curveA,\n\t\tCurveSetR     curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tCurveSetCR chainA,\n\t\tCurveSetCR chainB\n\t);\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            double &fractionA,\n            XPoint3dR pntA,\n            double &fractionB,\n            XPoint3dR pntB\n            );\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            CurveDescInfoR detailA,\n            CurveDescInfoR detailB\n            );\n};\n\nstruct PathLocationDetail\n{\nprivate:\n\tCurveDescInfo m_curveDetail;\n\tint32_t m_pathIndex;\n\tdouble m_pathDistance;\npublic:\n\n\tATGEOSET_EXPORT PathLocationDetail();\n\n\tATGEOSET_EXPORT PathLocationDetail(PathLocationDetail const &other);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, int pathIndex = -1, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, size_t pathIndex, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(double distance);\n\n\tATGEOSET_EXPORT XPoint3d Point() const;\n\n\tATGEOSET_EXPORT CurveDescInfo GetCurveDescInfo() const;\n\n    ATGEOSET_EXPORT double DistanceFromPathStart() const;\n};\n\nstruct CurveSetWithDistanceIndex : RefCountedBase\n{\nprivate:\n\n\tstruct PathEntry : PathLocationDetail\n\t{\n\t\tdouble             m_projectedDistance;\n\t\tXRange3d           m_range;\n\t\tPathEntry(PathLocationDetail const &pathDetail, double projectedDist, XRange3dCR range)\n\t\t\t: PathLocationDetail(pathDetail),\n\t\t\tm_projectedDistance(projectedDist),\n\t\t\tm_range(range)\n\t\t{\n\t\t}\n\t\tPathEntry(double distance) : PathLocationDetail(distance), m_projectedDistance(distance) {}\n\n\t\tdouble GetDistance(bool projected) const;\n\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistanceXY(PathEntry const &dataA, PathEntry const &dataB);\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistance(PathEntry const &dataA, PathEntry const &dataB);\n\t};\n\n\tCurveSetPtr m_curveVector;\n\txvector<PathEntry> m_locations;\n\tCurveSetPtr m_savedPrimitives;\n\n\tXRotMatrix m_worldToViewRotMatrix;\n\tXRotMatrix m_viewToWorldRotMatrix;\n\tXRotMatrix m_flattenToView;\n\tXMatrix4d m_worldToView;\n\n\texplicit CurveSetWithDistanceIndex(XRotMatrix worldToView);\n\n\tCurveSetWithDistanceIndex();\n\npublic:\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create(XRotMatrix worldToView);\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create();\n\n\tATGEOSET_EXPORT void SetPath(CurveSetPtr &path);\n\n\tATGEOSET_EXPORT bool SearchByDistanceFromPathStart\n\t(\n\t\tdouble targetDist,\n\t\tPathLocationDetail &detail\n\t) const;\n\n    ATGEOSET_EXPORT PathLocationDetail SearchClosestPointBounded\n    (\n    XPoint3dCR spacePoint,\n    bool computeDistAlong\n    ) const;\n};\n\nEND_ATEC_NAMESPACE\n\n", "output": "\nvoid CreateGeometryExamples::CreateXEllipse3d_FromPoints()\n{\n\t//前三个参数能够绘制出一个完整的椭圆\n\tXPoint3d center = XPoint3d::FromZero();\n\tXPoint3d point0 = XPoint3d::From(50, 0, 0);\n\tXPoint3d point90 = XPoint3d::From(0, 20, 0);\n\t//设置起始角度和扫掠角获取椭圆弧\n\tdouble theta0 = PI / 2;\n\tdouble sweep = PI;\n\n\tXEllipse3d arc3 = XEllipse3d::FromPoints(center, point0, point90, theta0, sweep);\n\t//添加到视口\n\tCurveSetPtr curve = CurveSet::Create(IBasicCurve::CreateArc(arc3));\n\tAddGeometryToScene(curve);\n}\n#pragma endregion\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};. You need to implement the function CreateLineString in the interface. Here are some apis that you can use and remember:\n code of file CurveSet.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 线串类\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct CurveSet : RefCountedBase, xvector<IBasicCurvePtr>\n{\n\n\tenum BoundaryType\n\t{\n\n\t\tBOUNDARY_TYPE_None = 0,\n\n\t\tBOUNDARY_TYPE_Open = 1,\n\n\t\tBOUNDARY_TYPE_Outer = 2,\n\n\t\tBOUNDARY_TYPE_Inner = 3,\n\n\t\tBOUNDARY_TYPE_ParityRegion = 4,\n\n\t\tBOUNDARY_TYPE_UnionRegion = 5,\n\t};\n\n\tenum InOutClassification\n\t{\n\t\tINOUT_Unknown = 0,\n\t\tINOUT_In = 1,\n\t\tINOUT_Out = 2,\n\t\tINOUT_On = 3\n\t};\n\nprotected:\n\tBoundaryType    m_boundaryType;\n\npublic:\n\t/**\n\t* @brief 设定边界\n\t* @details 设定曲线的边界类型\n\t* \n\t* @param BoundaryType BoundaryType\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void SetBoundaryType(BoundaryType BoundaryType);\n\n\t/**\n\t* @brief 获取叶节点\n\t* @details 通过只计算叶节点的索引深度搜索以获取目标叶节点\n\t* \n\t* @param size_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr FindIndexedLeaf(size_t index) const;\n\n\t/**\n\t* @brief 获取索引值\n\t* @details 深度搜索以获取给定叶节点的索引值\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @param size_t & index\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool LeafToIndex(IBasicCurveCP primitive, size_t &index) const;\n\n\t/**\n\t* @brief 获取叶节点个数\n\t* @details 获取曲线的叶节点个数\n\t* \n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesBelow() const;\n\n\texplicit CurveSet(BoundaryType boundaryType) { m_boundaryType = boundaryType; }\n\n\t/**\n\t* @brief 是否单元素曲线\n\t* @details 查询曲线是否只有一个基本元素\n\t* \n\t* @return IBasicCurve\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurve::BasicCurveType HasSingleBasicCurve() const;\n\n\t/**\n\t* @brief 获取边界类型\n\t* @details 获取曲线的边界类型\n\t* \n\t* @return BoundaryType\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT BoundaryType GetBoundaryType() const;\n\n\t/**\n\t* @brief 查询是否开\n\t* @details 查询是否开路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsOpenPath() const;\n\n\t/**\n\t* @brief 查询是否闭\n\t* @details 查询是否闭路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsClosedPath() const;\n\n\t/**\n\t* @brief 查询实际开闭\n\t* @details 查询是否名义上是开路径但起点和终点连接\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsPhysicallyClosedPath() const;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个带有给定边界类型没有成员的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个具有单个基本元素和给定边界类型的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @param IBasicCurvePtr primitive\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType, IBasicCurvePtr primitive);\n\n\t/**\n\t* @brief 拷贝\n\t* @details 返回一个深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr Clone() const;\n\n\t/**\n\t* @brief 倒角拷贝\n\t* @details 返回一个深度拷贝,在连续曲线之间插入圆角\n\t* \n\t* @param double radius\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithFillets(double radius) const;\n\n\t/**\n\t* @brief 闭合拷贝\n\t* @details 返回一个深度拷贝,闭合终端点的间隙\n\t* \n\t* @param CurveGapOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithGapsClosed(CurveGapOptionsCR options) const;\n\n\t/**\n\t* @brief 添加元素\n\t* @details 递归遍历source, 将所有叶节点添加到this, 返回添加的数量\n\t* \n\t* @param CurveSetCR source\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t AddPrimitives(CurveSetCR source);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 添加单个基本曲线\n\t* \n\t* @param IBasicCurvePtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(IBasicCurvePtr child);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 将chile的所有元素作为曲线成员添加\n\t* \n\t* @param CurveSetPtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(CurveSetPtr child);\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过XY方向的偏移后的深度拷贝\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneOffsetCurvesXY(CurveOffsetOptionsCR options);\n\n\t/**\n\t* @brief 获取叶节点数量\n\t* @details 计算指定类型的叶节点数量\n\t* \n\t* @param IBasicCurve::BasicCurveType targetType\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesOfType(IBasicCurve::BasicCurveType targetType) const;\n\n\t/**\n\t* @brief 用区域分割曲线\n\t* @details 用指定区域分割曲线,分别返回区域内、外和区域上的曲线\n\t* \n\t* @param CurveSetCR region\n\t* @param CurveSetP insideCollector\n\t* @param CurveSetP outsideCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByRegion(CurveSetCR region, CurveSetP insideCollector, CurveSetP outsideCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 用平面分割曲线\n\t* @details 用指定平面分割曲线,分别返回平面上方、下方和平面内的曲线\n\t* \n\t* @param XPlane3dCR plane\n\t* @param CurveSetP belowCollector\n\t* @param CurveSetP aboveCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByPlane(XPlane3dCR plane, CurveSetP belowCollector, CurveSetP aboveCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 拆分拷贝\n\t* @details 返回一个深度拷贝,但所有的多线段被拆分成单条线段\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithExplodedLinestrings() const;\n\n\t/**\n\t* @brief 获取质心\n\t* @details 返回包含曲线的质心(不考虑孤立点)\n\t* \n\t* @param double & length\n\t* @param XPoint3dR centroid\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  WireCentroid(double &length, XPoint3dR centroid) const;\n\n\t/**\n\t* @brief 获取质心、法向量和面积\n\t* @details 返回质心、法向量和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param XVec3dR normal\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CentroidNormalArea(XPoint3dR centroid, XVec3dR normal, double &area) const;\n\n\t/**\n\t* @brief 获取质心和面积\n\t* @details 返回XY平面方向上的质心和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  CentroidAreaXY(XPoint3dR centroid, double &area) const;\n\n\t/**\n\t* @brief 投影范围\n\t* @details 当投影到射线的时候,返回射线参数的范围\n\t* \n\t* @param XRay3dCR ray\n\t* @return XRange1d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT XRange1d ProjectedParameterRange(XRay3dCR ray) const;\n\n    /**\n    * @brief 局部坐标拷贝\n    * @details 返回曲线的深度复制并转换为与曲线相关联的局部坐标系统。\n    * \n    * @param LocalCoordinateSelect frameType\n    * @param TransformR localToWorld\n    * @param TransformR worldToLocal\n    * @param XRange3dR localRange\n    * @return CurveSetPtr\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT CurveSetPtr CloneInLocalCoordinates\n    (\n    LocalCoordinateSelect frameType,\n    TransformR localToWorld,\n    TransformR worldToLocal,\n    XRange3dR localRange\n    ) const;\n\n\t/**\n    * @brief 获取有坐标系的元素\n    * @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame) const;\n\n\t/**\n\t* @brief 获取有坐标系的元素\n\t* @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @param int searchPreference\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame, int srchPref) const;\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param xvector<XPoint3d> const & points\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(xvector<XPoint3d> const&points,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint3dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint3dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建多边形\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint2dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint2dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建矩形\n\t* @details 根据 XY 坐标创建矩形\n\t* \n\t* @param double x0\n\t* @param double y0\n\t* @param double x1\n\t* @param double y1\n\t* @param double z\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateRectangle(double x0, double y0, double x1, double y1, double z,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由给定线段创建边界类型为 BOUNDARY_TYPE_None 的曲线\n\t* \n\t* @param xvector<XSegment3d> const & segments\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(xvector<XSegment3d> const &segs);\n\n\t/**\n\t* @brief 创建圆盘\n\t* @details 为一个完整的椭圆(圆)盘创建一个曲线向量结构\n\t* \n\t* @param XEllipse3dCR arc\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateDisk(XEllipse3dCR arc, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer, bool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个仅有单一元素的曲线结构\n\t* \n\t* @param IBasicCurvePtr child\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(IBasicCurvePtr child, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open);\n\n\t/**\n\t* @brief B样条拷贝\n\t* @details 返回一个深度拷贝,作为B样条曲线\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneAsBsplines() const;\n\n\t/**\n\t* @brief 添加边缘点\n\t* @details 为所有的子节点添加边缘点\n\t* \n\t* @param xvector <XPoint3d> & points\n\t* @param IFacetOptionsR options\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AddStrokePoints(xvector <XPoint3d> &points, IFacetOptionsR options) const;\n\n    /**\n\t* @brief 添加面点\n\t* @details 沿着曲线计算指定距离的点\n\t* \n\t* @param xvector<double> const & distances\n\t* @param xvector<CurveDescInfo> & locations\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool AddSpacedPoints(xvector<double> const &distances, xvector<CurveDescInfo> &locations) const;\n\n\t/**\n\t* @brief 添加边缘\n\t* @details 在结构中添加所有边缘\n\t* \n\t* @param xvector <xvector<xvector<XPoint3d>>> & regionsPoints\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CollectLinearGeometry(xvector <xvector<xvector<XPoint3d>> > &regionsPoints) const;\n\n\t/**\n\t* @brief 获取B样条曲线\n\t* @details 将一个表示开放或闭合路径作为单个B样条曲线\n\t* \n\t* @return ATBsplineCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetBsplineCurve() const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n    /**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索最接近曲线的点。如果曲线是一个区域类型,同时要在该区域的内部寻找投影\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XPoint3dR curveOrRegionPoint\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification ClosestCurveOrRegionPoint(XPoint3dCR spacePoint, XPoint3dR curveOrRegionPoint) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点和终点\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点终点和他们的正切值\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @param XVec3dR unitTangentA\n\t* @param XVec3dR unitTangentB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\t/**\n\t* @brief 获取起点\n\t* @details 返回曲线的起点\n\t* \n\t* @param XPoint3dR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线总长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length() const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线经过变换后的总长度\n\t* \n\t* @param XRotMatrixCP worldToLocal\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length(XRotMatrixCP worldToLocal) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线的xyz范围\n\t* \n\t* @param XRange3dR range\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线经过变换后的范围\n\t* \n\t* @param XRange3dR range\n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\t/**\n\t* @brief 查询索引\n\t* @details 返回指定元素的索引\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t FindIndexOfPrimitive(IBasicCurveCP primitive) const;\n\n\t/**\n\t* @brief 复制曲线指定范围的曲线\n\t* @details 复制曲线指定索引和比例参数范围内的部分\n\t* \n\t* @param int index0\n\t* @param double fraction0\n\t* @param int index1\n\t* @param double fraction1\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n    ATGEOSET_EXPORT CurveSetPtr CloneBetweenCyclicIndexedFractions(int index0, double fraction0, int index1, double fraction1) const;\n\n\t/**\n\t* @brief 反转拷贝\n\t* @details 返回一个所有元素都被反转的深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneReversed() const;\n\n\t/**\n\t* @brief 查询是否包含非线性元素\n\t* @details 如果曲线有一个不非线性元素,则返回true。\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ContainsNonLinearPrimitive() const;\n\n\t/**\n\t* @brief 计算交点\n\t* @details 计算曲线与给定平面的交点\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 平面选中\n\t* @details 计算封闭曲线与平面的交叉点,并以奇偶性规则为设为起始对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param double tolerance\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr PlaneSection(XPlane3dCR plane, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 空间点位置情况\n\t* @details 当以XY平面视角看,测试给定点在曲线内、曲线上还是曲线外\n\t* \n\t* @param XPoint3dCR xyz\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification PointInOnOutXY(XPoint3dCR xyz) const;\n\n\t/**\n\t* @brief 射线击中情况\n\t* @details 测试射线击中曲线在区域内、区域上还是区域外\n\t* \n\t* @param XRay3dCR ray\n\t* @param SolidDescInfoR hitDetail\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification RayPierceInOnOut\n\t(\n\t\tXRay3dCR ray,\n\t\tSolidDescInfoR hitDetail\n\t) const;\n\n\t/**\n\t* @brief 原地变换\n\t* @details 应用给定变换并修改曲线\n\t* \n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\t/**\n\t* @brief 原地反转\n\t* @details 将所有元素进行反转\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串内的单个点被消除,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串相邻的空间点被消除（可选）,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @param bool doSimplifyLinestrings\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives(bool doSimplifyLinestrings);\n\n\t/**\n\t* @brief 原地修改以简化线串\n\t* @details 消除线串相邻的空间点\n\t* \n\t* @param double distanceTol\n\t* @param bool eliminateOverdraw\n\t* @param bool wrap\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void SimplifyLinestrings(double distTol, bool eliminateOverdraw, bool wrap);\n\n\t/**\n\t* @brief 重排元素\n\t* @details 将曲线元素重新排序以缩小元素首尾相连的间隙\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT double ReorderForSmallGaps();\n\n\t/**\n\t* @brief 链接元素\n\t* @details 将曲线的元素首尾相连\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AssembleChains();\n\n\t/**\n\t* @brief 区域相并\n\t* @details 返回给定两个区域的并\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaUnion(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相减\n\t* @details 返回给定两个区域的减\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaDifference(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相交\n\t* @details 返回给定两个区域的交\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaIntersection(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 循环索引\n\t* @details 返回给定索引值关于集合大小的模\n\t* \n\t* @param int index\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT size_t CyclicIndex(int index) const;\n\n\t/**\n\t* @brief 循环获取值\n\t* @details 根据给定索引的循环索引获取元素\n\t* \n\t* @param ptrdiff_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr GetCyclic(ptrdiff_t index) const;\n\n    /**\n    * @brief 获取索引\n    * @details 返回给定曲线元素的详细细节所对应的元素索引\n    * \n    * @param CurveDescInfo const & location\n    * @return size_t\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT size_t CurveDescInfoIndex(CurveDescInfo const& location) const;\n\n\t/**\n\t* @brief 与平面相交\n\t* @details 计算封闭曲线与平面的交叉点,返回以奇偶性规则构造的起止点对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool AppendClosedCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过给定偏移后的深度拷贝.\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AreaOffset(CurveOffsetOptionsCR options) const;\n\n\t/**\n\t* @brief 返回从index0,fraction0到index1,fraction1的曲线段\n\t* \n\t* @param int index0 \n\t* @param double fraction0 \n\t* @param int index1 \n\t* @param double fraction1 \n\t* @param bool allowExtrapolation \n\t* @return ATGEOSET_EXPORT CurveSetPtr \n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/17\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneBetweenDirectedFractions(int index0, double fraction0, int index1, double fraction1, bool allowExtrapolation) const;\n\n\t/**\n\t* @brief 返回输入的曲线的布尔奇运算结果（区域）\n\t*\n\t* @param CurveSetCR regionA\t\t\t\t\t左操作数\n\t* @param CurveSetCR regionB\t\t\t\t\t右操作数\n\t* @param BasicCurvePtrPairVector * newToOld\t（可选）包含新旧曲线的数组指针\n\t* @return ATGEOSET_EXPORT CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/07/22\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaParity(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n};\n\nstruct CurveCurve\n{\nprivate: CurveCurve();\npublic:\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tCurveSetR curveA,\n\t\tCurveSetR curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB,\n\t\tXMatrix4dCP    pWorldToLocal,\n\t\tbool         extend = false\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveR curveA,\n\t\tCurveSetR     curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tCurveSetCR chainA,\n\t\tCurveSetCR chainB\n\t);\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            double &fractionA,\n            XPoint3dR pntA,\n            double &fractionB,\n            XPoint3dR pntB\n            );\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            CurveDescInfoR detailA,\n            CurveDescInfoR detailB\n            );\n};\n\nstruct PathLocationDetail\n{\nprivate:\n\tCurveDescInfo m_curveDetail;\n\tint32_t m_pathIndex;\n\tdouble m_pathDistance;\npublic:\n\n\tATGEOSET_EXPORT PathLocationDetail();\n\n\tATGEOSET_EXPORT PathLocationDetail(PathLocationDetail const &other);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, int pathIndex = -1, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, size_t pathIndex, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(double distance);\n\n\tATGEOSET_EXPORT XPoint3d Point() const;\n\n\tATGEOSET_EXPORT CurveDescInfo GetCurveDescInfo() const;\n\n    ATGEOSET_EXPORT double DistanceFromPathStart() const;\n};\n\nstruct CurveSetWithDistanceIndex : RefCountedBase\n{\nprivate:\n\n\tstruct PathEntry : PathLocationDetail\n\t{\n\t\tdouble             m_projectedDistance;\n\t\tXRange3d           m_range;\n\t\tPathEntry(PathLocationDetail const &pathDetail, double projectedDist, XRange3dCR range)\n\t\t\t: PathLocationDetail(pathDetail),\n\t\t\tm_projectedDistance(projectedDist),\n\t\t\tm_range(range)\n\t\t{\n\t\t}\n\t\tPathEntry(double distance) : PathLocationDetail(distance), m_projectedDistance(distance) {}\n\n\t\tdouble GetDistance(bool projected) const;\n\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistanceXY(PathEntry const &dataA, PathEntry const &dataB);\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistance(PathEntry const &dataA, PathEntry const &dataB);\n\t};\n\n\tCurveSetPtr m_curveVector;\n\txvector<PathEntry> m_locations;\n\tCurveSetPtr m_savedPrimitives;\n\n\tXRotMatrix m_worldToViewRotMatrix;\n\tXRotMatrix m_viewToWorldRotMatrix;\n\tXRotMatrix m_flattenToView;\n\tXMatrix4d m_worldToView;\n\n\texplicit CurveSetWithDistanceIndex(XRotMatrix worldToView);\n\n\tCurveSetWithDistanceIndex();\n\npublic:\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create(XRotMatrix worldToView);\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create();\n\n\tATGEOSET_EXPORT void SetPath(CurveSetPtr &path);\n\n\tATGEOSET_EXPORT bool SearchByDistanceFromPathStart\n\t(\n\t\tdouble targetDist,\n\t\tPathLocationDetail &detail\n\t) const;\n\n    ATGEOSET_EXPORT PathLocationDetail SearchClosestPointBounded\n    (\n    XPoint3dCR spacePoint,\n    bool computeDistAlong\n    ) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XPoint3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n /**\n * @brief 3D绌洪棿鐐圭被\n * @author SZEWC\n * @since 2022/04/13\n*/\nstruct ATGEOSET_EXPORT XPoint3d\n{\n\n\tdouble x;\n\n\tdouble y;\n\n\tdouble z;\n\n\tstatic XPoint3d From(double x, double y, double z = 0.0);\n\n\tstatic XPoint3d From(XPoint2dCR xy);\n\n\tstatic XPoint3d FromZero();\n\n\tstatic XPoint3d FromOne();\n\n\tstatic XPoint3d FromXYZ(double x, double y, double z);\n\n\tvoid Swap(XPoint3dR other);\n\n\tdouble DotDifference(XPoint3dCR origin, XVec3dCR vector) const;\n\n\tvoid Zero();\n\n\tvoid Init(XPoint2dCR source);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double ay);\n\n\tvoid SetComponent(double a, int index);\n\n\tdouble GetComponent(int index) const;\n\n\tvoid Interpolate(XPoint3dCR pnt0, double fractionParameter, XPoint3dCR point1);\n\n\tdouble Distance(XPoint3dCR point2) const;\n\n\tdouble DistanceXY(XPoint3dCR point2) const;\n\n\tbool DistanceXY(XPoint3dCR otherPoint, XMatrix4dCP matrix, double &distance) const;\n\n\tbool IsEqual(XPoint3dCR point2) const;\n\n\tbool IsEqual(XPoint3dCR point2, double tolerance) const;\n\n\tbool IsDisconnect() const;\n\n\tvoid InitDisconnect();\n\n\tvoid Init(XVec3dCR vector);\n\n\tvoid Subtract(XPoint3dCR base, XVec3dCR vector);\n\n\tvoid Add(XVec3dCR vector);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2, XVec3dCR point3, double scale3);\n\n\tvoid CrossProduct(XPoint3dCR point1, XPoint3dCR point2);\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble AngleTo(XPoint3dCR point2) const;\n\n\tvoid RotateXY(XPoint3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tdouble MagnitudeXY() const;\n\n\tvoid Scale(XPoint3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XPoint3dCR vector);\n\n\tvoid Negate();\n\n\tdouble Normalize(XPoint3dCR vector);\n\n\tdouble Normalize();\n\n\tvoid Subtract(XPoint3dCR point2);\n\n\tvoid DifferenceOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2, XPoint3dCR point3, double scale3);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2, XPoint3dCR point3, double a3);\n\n\tvoid Add(XPoint3dCR vector);\n\n\tvoid SumOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, XPoint3dCR point);\n\n\tstatic XPoint3d FromInterpolate(XPoint3dCR pntA, double fraction, XPoint3dCR pntB);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector, double scaleFactor);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1, XPoint3dCR point2, double scaleFactor2);\n\n\tstatic XPoint3d FromScale(XPoint3d point, double scale);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, XVec3dCR vector);\n\n\tbool AlmostEqual(XPoint3d const & dataB) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB) const;\n\n\tbool AlmostEqual(XPoint3d const & dataB, double abstol) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB, double abstol) const;\n\n\tstatic bool AlmostEqual(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tstatic bool AlmostEqualXY(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tdouble DistanceSquared(XPoint3dCR point2) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file IBasicCurve.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 基本线元类\n* @author SZEWC\n* @since 2022/04/28\n*/\nstruct IBasicCurve : public RefCountedBase\n{\nprivate: virtual void IAmAbstractClass() = 0;\n\npublic:\n\tenum BasicCurveType\n\t{\n\t\tBCURVE_TYPE_Invalid = 0,\n\t\tBCURVE_TYPE_Line = 1,\n\t\tBCURVE_TYPE_LineString = 2,\n\t\tBCURVE_TYPE_Arc = 3,\n\t\tBCURVE_TYPE_BsplineCurve = 4,\n\t\tBCURVE_TYPE_InterpolationCurve = 5,\n\t\tBCURVE_TYPE_AkimaCurve = 6,\n\t\tBCURVE_TYPE_PointString = 7,\n\t\tBCURVE_TYPE_CurveSet = 8,\n\t\tBCURVE_TYPE_Spiral = 9,\n\t\tBCURVE_TYPE_PartialCurve = 10,\n\t\tBCURVE_TYPE_NotClassified = -1,\n\t};\n\n\tATGEOSET_EXPORT int64_t GetTag() const;\n\n\tATGEOSET_EXPORT int GetIntTag() const;\n\n\tATGEOSET_EXPORT void SetTag(int64_t tag);\n\n\tATGEOSET_EXPORT void SetTag(int tag);\n\n\tATGEOSET_EXPORT CurveSetPtr GetChildCurveSetP();\n\npublic:\n\tATGEOSET_EXPORT xvector<XPoint3d> * GetLineStringP();\n\n\tATGEOSET_EXPORT BasicCurveType           GetBasicCurveType() const;\n\n\tATGEOSET_EXPORT bool TryGetLine(XSegment3dR segment) const;\n\n\tATGEOSET_EXPORT bool TryGetArc(XEllipse3dR arc) const;\n\n\tATGEOSET_EXPORT XSegment3dCP                 GetLineCP() const;\n\n\tATGEOSET_EXPORT xvector<XPoint3d> const* GetLineStringCP() const;\n\n\tATGEOSET_EXPORT bool TryGetSegmentInLineString(XSegment3dR segment, size_t startPointIndex) const;\n\n\tATGEOSET_EXPORT XEllipse3dCP                 GetArcCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurveCP             GetBsplineCurveCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr             GetBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr            GetProxyBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT XSpiral2dPlacementCP         GetSpiralPlacementCP() const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLine(XSegment3dCR segment);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(XPoint3dCP points, size_t nPoints);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(xvector<XPoint3d> const &points);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateArc(XEllipse3dCR ellipse);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurveCR curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurvePtr& curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiral(XSpiral2dBaseCR spiral, TransformCR frame,\n\t\tdouble fractionA, double fractionB);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusBearingRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble endRadians,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusLengthRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble length,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT IBasicCurvePtr Clone() const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneComponent(ptrdiff_t componentIndex) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneAsSingleOffsetPrimitiveXY(CurveOffsetOptionsCR options) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XRay3dR ray) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, CurveDescInfo &detail) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2, XVec3dR derivative3) const;\n\n\tATGEOSET_EXPORT bool FractionToFrenetFrame(double f, TransformR frame) const;\n\n\tATGEOSET_EXPORT bool Length(double &length) const;\n\n\tATGEOSET_EXPORT bool Length(XRotMatrixCP worldToLocal, double &length) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\tATGEOSET_EXPORT size_t NumComponent() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetATBsplineCurvePtr(double fraction0 = 0.0, double fraction1 = 1.0) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(XRotMatrixCP worldToView, double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool TrySetStart(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TrySetEnd(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\tATGEOSET_EXPORT void  AppendCurvePlaneIntersections\n\t(\n\t\tXPlane3dByVectorsCR plane,\n\t\tUVBoundarySelect   bounded,\n\t\txvector<CurveAndSolidDescInfo> &intersections\n\t) const;\n\n\tATGEOSET_EXPORT bool AddStrokes(xvector <XPoint3d> &points, IFacetOptionsR options,\n\t\tbool includeStartPoint = true,\n\t\tdouble startFraction = 0.0,\n\t\tdouble endFraction = 1.0\n\t) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, double &fraction, XPoint3dR curvePoint) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneBetweenFractions(double fractionA, double fractionB, bool allowExtrapolation) const;\n\n\tATGEOSET_EXPORT CurveSetCP            GetChildCurveSetCP() const;\n\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(double startFraction, double endFraction, double &signedDist) const;\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(XRotMatrixCP worldToLocal, double startFraction, double endFraction, double &signedDist) const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateRectangle(double x0, double y0, double x1, double y1, double z, int areaSignPref = 0);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateChildCurveSet(CurveSetPtr source);\n\n\tATGEOSET_EXPORT bool  TryGetPartialCurveData(double &fractionA, double &fractionB, IBasicCurvePtr &parentCurve, int64_t &tag) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file CreateGeometryExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};", "output": "\n#pragma region LineString\nvoid CreateGeometryExamples::CreateLineString()\n{\n\t//通过点集创建BasicCurve--表示的是LineString\n\tXPoint3d st = XPoint3d::From(0, 20, 0);\n\tXPoint3d pt2 = XPoint3d::From(10, 5, 0);\n\tXPoint3d pt3 = XPoint3d::From(30, 30, 0);\n\tXPoint3d ed = XPoint3d::From(40, 50, 0);\n\n\txvector<XPoint3d> ptList1 = { st, pt2, pt3, ed };\n\n\tIBasicCurvePtr basicCurve = IBasicCurve::CreateLineString(ptList1);\n\n\t//添加到视口\n\tCurveSetPtr curve = CurveSet::Create(basicCurve);\n\tAddGeometryToScene(curve);\n}\n\n#pragma endregion\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};. You need to implement the function GetBsplineCurves_FromControlPts in the interface. Here are some apis that you can use and remember:\n code of file ATBsplineCurve.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\nstruct RefCountedATBsplineCurve;\ntypedef RefCountedPtr <RefCountedATBsplineCurve> ATBsplineCurvePtr;\ntypedef int ATBsplineStatus;\n /**\n * @brief B样条曲线\n * @author SZEWC\n * @since 2022/04/27\n*/\nstruct ATBsplineCurve\n{\npublic:\n\tint32_t             type;\n\tint32_t             rational;\n\tBsplineDisplay      display;\n\tBsplineParam        params;\n\tXPoint3d            *poles;\n\tdouble              *knots;\n\tdouble              *weights;\n\npublic:\n\n\t/**\n    * @brief 用直接提供的极点、系数和节点生成B样条曲线并返回智能指针\n\t* @return ATGEOSET_EXPORT ATBsplineCurvePtr\n\t* @param xvector<XPoint3d> const & poles\n\t* @param xvector<double> const * weights\n\t* @param xvector<double> const * knots\n\t* @param int order\n\t* @param bool closed\n\t* @param bool inputPolesAlreadyWeighted\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT static ATBsplineCurvePtr CreateFromPolesAndOrder\n\t(\n\t\txvector<XPoint3d> const &poles,\n\t\txvector<double> const *weights,\n\t\txvector<double> const *knots,\n\t\tint order,\n\t\tbool closed,\n\t\tbool inputPolesAlreadyWeighted\n\t);\n\n\t/**\n    * @brief 用直接提供的极点、系数和节点生成B样条曲线并返回智能指针\n\t* @return ATGEOSET_EXPORT ATBsplineCurvePtr\n\t* @param XPoint3dCP poles\n\t* @param int numPoles\n\t* @param int order\n\t* @param bool closed\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT static ATBsplineCurvePtr CreateFromPolesAndOrder\n\t(\n\t\tXPoint3dCP poles,\n\t\tint numPoles,\n\t\tint order,\n\t\tbool closed = false\n\t);\n\n\t/**\n    * @brief 用直接提供的极点、系数和节点生成B样条曲线并返回智能指针\n\t* @return ATGEOSET_EXPORT ATBsplineCurvePtr\n\t* @param XPoint2dCP poles\n\t* @param int numPoles\n\t* @param int order\n\t* @param bool closed\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT static ATBsplineCurvePtr CreateFromPolesAndOrder\n\t(\n\t\tXPoint2dCP poles,\n\t\tint numPoles,\n\t\tint order,\n\t\tbool closed = false\n\t);\n\n\t/**\n    * @brief 复制曲线指定分数参数之间的部分\n\t* @return ATGEOSET_EXPORT ATBsplineCurvePtr\n\t* @param double fraction0\n\t* @param double fraction1\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT ATBsplineCurvePtr CreateCopyBetweenFractions(double fraction0, double fraction1) const;\n\n\t/**\n    * @brief 创建一个近似于BasicCurve的样条曲线\n\t* @return ATGEOSET_EXPORT ATBsplineCurvePtr\n\t* @param IBasicCurveCR curve\n\t* @param size_t numPoles\n\t* @param int order\n\t* @param bool normalizeKnots\n\t* @param int knotSelector\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tstatic ATGEOSET_EXPORT ATBsplineCurvePtr CreateFromInterpolationAtGrevilleKnots\n\t(\n\t\tIBasicCurveCR curve,\n\t\tsize_t numPoles,\n\t\tint order,\n\t\tbool normalizeKnots,\n\t\tint knotSelector = 0\n\t);\n\n\t/**\n    * @brief B样条曲线上指定点的分数参数\n\t* @return ATGEOSET_EXPORT void\n\t* @param XPoint3dR xyz\n\t* @param double f\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT void FractionToPoint(XPoint3dR xyz, double f) const;\n\n\t/**\n    * @brief B样条曲线上指定点的分数参数\n\t* @return ATGEOSET_EXPORT void\n\t* @param XPoint3dR xyz\n\t* @param XVec3dR tangent\n\t* @param double f\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT void FractionToPoint(XPoint3dR xyz, XVec3dR tangent, double f) const;\n\n\t/**\n    * @brief 通过索引返回极点,如果超出范围返回0\n\t* @return ATGEOSET_EXPORT XPoint3d\n\t* @param size_t index\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT XPoint3d GetPole(size_t index) const;\n\n\t/**\n    * @brief 通过索引返回极点,如果超出范围返回0\n\t* @return ATGEOSET_EXPORT XPoint3d\n\t* @param int index\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT XPoint3d GetPole(int index) const;\n\n\t/**\n    * @brief 根据索引设定极点,如果索引超出范围,返回false\n\t* @return ATGEOSET_EXPORT bool\n\t* @param size_t index\n\t* @param XPoint3dCR value\n\t* @param bool reverse\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT bool SetReWeightedPole(size_t index, XPoint3dCR value, bool reverse = false);\n\n\t/**\n    * @brief 根据索引设定极点,如果索引超出范围,返回false\n\t* @return ATGEOSET_EXPORT bool\n\t* @param int index\n\t* @param XPoint3dCR value\n\t* @param bool reverse\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT bool SetReWeightedPole(int index, XPoint3dCR value, bool reverse = false);\n\n\t/**\n    * @brief 获取分离权重参数后的极点\n\t* @return ATGEOSET_EXPORT void\n\t* @param xvector<XPoint3d> & outData\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT void GetUnWeightedPoles(xvector<XPoint3d> &outData) const;\n\n\t/**\n    * @brief 获取所有极点\n\t* @return ATGEOSET_EXPORT void\n\t* @param xvector<XPoint3d> & outData\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT void GetPoles(xvector<XPoint3d> &outData) const;\n\n\t/**\n    * @brief 获取极点个数\n\t* @return ATGEOSET_EXPORT int\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT int GetIntNumPoles() const;\n\n\t/**\n    * @brief 计算B样条曲线的长度\n\t* @return ATGEOSET_EXPORT double\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT double Length() const;\n\n\t/**\n    * @brief 计算经过变换的曲线长度\n\t* @return ATGEOSET_EXPORT double\n\t* @param XRotMatrixCP worldToLocal\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT double Length(XRotMatrixCP worldToLocal) const;\n\n\t/**\n    * @brief 计算与平面的交点\n\t* @return ATGEOSET_EXPORT void\n\t* @param xvector<XPoint3d> * points\n\t* @param xvector<double> * fractionParameters\n\t* @param XPlane3dCR plane\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT void AddPlaneIntersections(xvector<XPoint3d>* points, xvector<double> *fractionParameters, XPlane3dCR plane) const;\n\n\t/**\n    * @brief 计算与平面的交点\n\t* @return ATGEOSET_EXPORT void\n\t* @param xvector<XPoint3d> * points\n\t* @param xvector<double> * fractionParameters\n\t* @param XPoint4dCR planeCoffs\n\t* @author SZEWEC\n\t* @since 2022/04/07\n\t*/\n\tATGEOSET_EXPORT void AddPlaneIntersections(xvector<XPoint3d>* points, xvector<double> *fractionParameters, XPoint4dCR planeCoffs) const;\n\n\t/**\n    * @brief 在XY方向上计算与直线的交点\n\t* @return ATGEOSET_EXPORT void\n\t* @param xvector<XPoint3d> * curvePoints\n\t* @param xvector<double> * curveFractions\n\t* @param xvector<XPoint3d> * linePoints\n\t* @param xvector<double> * lineFractions\n\t* @param XSegment3dCR segment\n\t* @param bool extendSegment\n\t* @param XMatrix4dCP matrix\n\t* @author SZEWEC\n\t* @since 2022/04/07\n\t*/\n\tATGEOSET_EXPORT void AddLineIntersectionsXY(xvector<XPoint3d> *curvePoints, xvector<double> *curveFractions,\n\t\txvector<XPoint3d> *linePoints, xvector<double> *lineFractions,\n\t\tXSegment3dCR segment, bool extendSeg, XMatrix4dCP matrix) const;\n\n\t/**\n    * @brief 获取B样条曲线的起始或终止端点\n\t* @return ATGEOSET_EXPORT void\n\t* @param XPoint3dR start\n\t* @param XPoint3dR end\n\t* @author SZEWEC\n\t* @since 2022/04/07\n\t*/\n\tATGEOSET_EXPORT void ExtractEndPoints(XPoint3dR start, XPoint3dR end) const;\n\n\t/**\n    * @brief 计算近似路径\n\t* @return ATGEOSET_EXPORT void\n\t* @param xvector <XPoint3d> & points\n\t* @param double chordTol\n\t* @param double angleTol\n\t* @param double maxEdgeLength\n\t* @param bool includeStartPoint\n\t* @author SZEWEC\n\t* @since 2022/04/07\n\t*/\n\tATGEOSET_EXPORT void AddStrokes(xvector <XPoint3d> &points,\n\t\tdouble chordTol = 0.0, double angleTol = 0.20, double maxEdgeLength = 0.0, bool includeStartPoint = true) const;\n\n\t/**\n    * @brief 计算在均分角度上的点\n\t* @return ATGEOSET_EXPORT bool\n\t* @param xvector <XPoint3d> & points\n\t* @param xvector<double> & fractions\n\t* @param size_t numPoints\n\t* @author SZEWEC\n\t* @since 2022/04/07\n\t*/\n\tATGEOSET_EXPORT bool PointsAtUniformArcLength(xvector <XPoint3d> &points, xvector<double> &fractions, size_t numPoints) const;\n\n\t/**\n    * @brief 获取曲线上离给定点最接近的点和对应的分数参数\n\t* @return ATGEOSET_EXPORT void\n\t* @param XPoint3dR curvePoint\n\t* @param double & fraction\n\t* @param XPoint3dCR spacePoint\n\t* @author SZEWEC\n\t* @since 2022/04/07\n\t*/\n\tATGEOSET_EXPORT void ClosestPoint(XPoint3dR curvePoint, double &fraction, XPoint3dCR spacePoint) const;\n\n\t/**\n\t* @brief 使用Lim拟合条件创建B样条曲线\n\t*\n\t* @param xvector<XPoint3d>const & xyz\t\t\t插值点\n\t* @param size_t order\t\t\t\t\t\t\tB样条阶数\n\t* @param int knotType\t\t\t\t\t\t\t节点类型,0为uniform、1为chord length、2为centripetal\n\t* @return ATGEOSET_EXPORT ATBsplineCurvePtr\tB样条曲线\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/29\n\t*/\n\tstatic ATGEOSET_EXPORT ATBsplineCurvePtr CreateFromInterpolationAtBasisFunctionPeaks(xvector<XPoint3d>const &xyz, size_t order, int knotType = 0);\n\t/**\n\t* @brief 返回曲线阶数\n\t* \n\t* @return ATGEOSET_EXPORT size_t 阶数\n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/30\n\t*/\n\tATGEOSET_EXPORT size_t GetOrder() const;\n\n\t/**\n\t* @brief 创建在不相交节点分割的各段的拷贝\n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/31\n\t*/\n\tATGEOSET_EXPORT void GetDisjointCurves(xvector<ATBsplineCurvePtr> &curves) const;\n\n\t/**\n\t* @brief 创建在点或切线变化处分割的各段的拷贝\n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/31\n\t*/\n\tATGEOSET_EXPORT void GetC1DiscontinuousCurves(xvector<double> &fractions, xvector<ATBsplineCurvePtr> &curves) const;\n\n    //! Create the B-spline curve from point array and order.\n    ATGEOSET_EXPORT ATBsplineStatus InitFromPoints(XPoint3dCP points, int nPoints);\n};\n\nstruct RefCountedATBsplineCurve : public ATBsplineCurve, RefCountedBase\n{\nprotected:\n\tRefCountedATBsplineCurve();\n\t~RefCountedATBsplineCurve();\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XPoint3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n /**\n * @brief 3D绌洪棿鐐圭被\n * @author SZEWC\n * @since 2022/04/13\n*/\nstruct ATGEOSET_EXPORT XPoint3d\n{\n\n\tdouble x;\n\n\tdouble y;\n\n\tdouble z;\n\n\tstatic XPoint3d From(double x, double y, double z = 0.0);\n\n\tstatic XPoint3d From(XPoint2dCR xy);\n\n\tstatic XPoint3d FromZero();\n\n\tstatic XPoint3d FromOne();\n\n\tstatic XPoint3d FromXYZ(double x, double y, double z);\n\n\tvoid Swap(XPoint3dR other);\n\n\tdouble DotDifference(XPoint3dCR origin, XVec3dCR vector) const;\n\n\tvoid Zero();\n\n\tvoid Init(XPoint2dCR source);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double ay);\n\n\tvoid SetComponent(double a, int index);\n\n\tdouble GetComponent(int index) const;\n\n\tvoid Interpolate(XPoint3dCR pnt0, double fractionParameter, XPoint3dCR point1);\n\n\tdouble Distance(XPoint3dCR point2) const;\n\n\tdouble DistanceXY(XPoint3dCR point2) const;\n\n\tbool DistanceXY(XPoint3dCR otherPoint, XMatrix4dCP matrix, double &distance) const;\n\n\tbool IsEqual(XPoint3dCR point2) const;\n\n\tbool IsEqual(XPoint3dCR point2, double tolerance) const;\n\n\tbool IsDisconnect() const;\n\n\tvoid InitDisconnect();\n\n\tvoid Init(XVec3dCR vector);\n\n\tvoid Subtract(XPoint3dCR base, XVec3dCR vector);\n\n\tvoid Add(XVec3dCR vector);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2, XVec3dCR point3, double scale3);\n\n\tvoid CrossProduct(XPoint3dCR point1, XPoint3dCR point2);\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble AngleTo(XPoint3dCR point2) const;\n\n\tvoid RotateXY(XPoint3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tdouble MagnitudeXY() const;\n\n\tvoid Scale(XPoint3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XPoint3dCR vector);\n\n\tvoid Negate();\n\n\tdouble Normalize(XPoint3dCR vector);\n\n\tdouble Normalize();\n\n\tvoid Subtract(XPoint3dCR point2);\n\n\tvoid DifferenceOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2, XPoint3dCR point3, double scale3);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2, XPoint3dCR point3, double a3);\n\n\tvoid Add(XPoint3dCR vector);\n\n\tvoid SumOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, XPoint3dCR point);\n\n\tstatic XPoint3d FromInterpolate(XPoint3dCR pntA, double fraction, XPoint3dCR pntB);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector, double scaleFactor);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1, XPoint3dCR point2, double scaleFactor2);\n\n\tstatic XPoint3d FromScale(XPoint3d point, double scale);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, XVec3dCR vector);\n\n\tbool AlmostEqual(XPoint3d const & dataB) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB) const;\n\n\tbool AlmostEqual(XPoint3d const & dataB, double abstol) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB, double abstol) const;\n\n\tstatic bool AlmostEqual(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tstatic bool AlmostEqualXY(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tdouble DistanceSquared(XPoint3dCR point2) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file ATEC.h: \n/**\n* @file ATEC.h\n*\n* @author SZEWC\n* @date 2022/04/28\n*/\n\n#pragma once\n\n#if !defined (__cplusplus)\n#error \"This file is for C++ compilands only\"\n#endif\n\n#if !defined (_WIN32)\n#error \"Windows is the only platform supported\"\n#endif\n#ifndef ATEC_WIN32\n#define ATEC_WIN32\n#endif\n\n#define ATECCONFIG_GRAPHICS_DIRECTX\n\n#if defined (__unix__)\n\n#include <stddef.h>     \n\n#define override\n#define _countof(_Array) (sizeof(_Array)/sizeof((_Array)[0]))\n#define _CRT_WIDE(A) L\"\" A\n\nextern void _wassert(wchar_t const*, wchar_t const*, int);\n\n#if defined (__MINGW32__)\n\n#define EXPORT_ATTRIBUTE        __declspec(dllexport)\n#define IMPORT_ATTRIBUTE        __declspec(dllimport)\n#define DLLPUBLIC_ATTRIBUTE\n#define DLLLOCAL_ATTRIBUTE\n#define EXPORT_VTABLE_ATTRIBUTE\n#define CDECL_ATTRIBUTE         __cdecl\n#define STDCALL_ATTRIBUTE       __stdcall\n#else\n\n#define _alloca(x)              __builtin_alloca((x))\n#define EXPORT_VTABLE_ATTRIBUTE     __attribute__((visibility (\"default\")))\n#define DLLPUBLIC_ATTRIBUTE     __attribute__((visibility (\"default\")))\n#define EXPORT_ATTRIBUTE        __attribute__((visibility (\"default\")))\n#define IMPORT_ATTRIBUTE        __attribute__((visibility (\"default\")))\n#define DLLLOCAL_ATTRIBUTE      __attribute__((visibility (\"hidden\")))\n#define CDECL_ATTRIBUTE\n#define STDCALL_ATTRIBUTE\n#endif \n\n#define ENUM_UNDERLYING_TYPE(T) \n\n#define STD_TR1 std\n\ntypedef void* ULONG_PTR;\n\n#define UNREACHABLE_CODE(stmt)\n\n#define DECLARE_KEY_METHOD __attribute__((visibility (\"default\"))) virtual void DummyKeyMethod() const;\n\n#elif defined (_WIN32)\n\n#include \"suppress_warnings.h\"\n\n#define DLLPUBLIC_ATTRIBUTE\n#define EXPORT_ATTRIBUTE        __declspec(dllexport)\n#define IMPORT_ATTRIBUTE        __declspec(dllimport)\n#define DLLLOCAL_ATTRIBUTE        \n#define DLLPUBLIC_ATTRIBUTE       \n#define EXPORT_VTABLE_ATTRIBUTE   \n#define CDECL_ATTRIBUTE         __cdecl\n#define STDCALL_ATTRIBUTE       __stdcall\n#define ENUM_UNDERLYING_TYPE(T)   : T\n\n#if (_MSC_VER < 1600) \n#include <limits.h>\n#if defined(_M_X64)\n#define INTPTR_MIN      _I64_MIN\n#define INTPTR_MAX      _I64_MAX\n#define UINTPTR_MAX     _UI64_MAX\n#else \n#define INTPTR_MIN      _I32_MIN\n#define INTPTR_MAX      _I32_MAX\n#define UINTPTR_MAX     _UI32_MAX\n#endif\n#endif\n\n#define HAVE_TR1\n#define STD_TR1 std::tr1\n\n#if defined(_M_X64)\ntypedef unsigned __int64    ULONG_PTR;\n#else \ntypedef __w64 unsigned long  ULONG_PTR;\n#endif \n\n#define DECLARE_KEY_METHOD\n\n#else\n#error unknown compiler\n#endif\n\n#ifdef CREATE_STATIC_LIBRARIES\n#undef EXPORT_ATTRIBUTE\n#undef IMPORT_ATTRIBUTE\n#define EXPORT_ATTRIBUTE\n#define IMPORT_ATTRIBUTE\n#endif\n\n#include \"ATEC.r.h\"\n\n#include <limits.h>\n\n#ifndef INT32_MAX\n#define INT32_MAX   INT_MAX\n#endif\n#ifndef UINT32_MAX\n#define UINT32_MAX  UINT_MAX\n#endif\n#ifndef INT64_MAX\n#define INT64_MAX   LLONG_MAX\n#endif\n#ifndef UINT64_MAX\n#define UINT64_MAX  ULLONG_MAX\n#endif\n#ifndef INT32_MIN\n#define INT32_MIN   INT_MIN\n#endif\n#ifndef INT64_MIN\n#define INT64_MIN   LLONG_MIN\n#endif\n\n#define USING_NAMESPACE_ATEC using namespace ATEC_NAMESPACE_NAME;\n\n#define GLOBAL_TYPEDEFS(_name_) \\\n        struct _name_; \\\n        typedef _name_*          _name_##P;  \\\n        typedef _name_&          _name_##R;  \\\n        typedef _name_ const*    _name_##CP; \\\n        typedef _name_ const&    _name_##CR; \\\n\n#define ADD_ATEC_TYPEDEFS1(_namespace_,_srcName_,_name_,structclass) \\\n    namespace ATEC_NAMESPACE_NAME {\\\n    typedef structclass _namespace_ :: _srcName_*          _name_##P, &_name_##R;  \\\n    typedef structclass _namespace_ :: _srcName_ const*    _name_##CP; \\\n    typedef structclass _namespace_ :: _srcName_ const&    _name_##CR; }\n\n#define ADD_ATEC_TYPEDEFS(_namespace_,_name_) ADD_ATEC_TYPEDEFS1(_namespace_,_name_,_name_,struct)\n#define ADD_ATEC_ENUM_TYPEDEF(_namespace_,_name_,_tEnum_) namespace ATEC_NAMESPACE_NAME {typedef enum _namespace_ :: _name_ _tEnum_;}\n#define ATEC_TYPEDEF(t,tP)    namespace ATEC_NAMESPACE_NAME {struct t; typedef struct ATEC_NAMESPACE_NAME::t*   tP;}\n#define ATEC_TYPEDEFS(_name_) namespace ATEC_NAMESPACE_NAME {struct _name_;} ADD_ATEC_TYPEDEFS(ATEC_NAMESPACE_NAME,_name_)\n#define ATEC_REF_COUNTED_PTR(_sname_) namespace ATEC_NAMESPACE_NAME {struct _sname_; typedef RefCountedPtr<_sname_> _sname_##Ptr;}\n\n#define ATEC_NAMESPACE_TYPEDEFS(_name_) ATEC_TYPEDEFS(_name_)\n\n#if !defined (NULL)\n#define NULL    0\n#endif\n\n#if !defined (NO_ATEC_PUBLIC)\n#define Public\n#endif\n\n#define BEGIN_EXTERN_C extern \"C\" {\n#define END_EXTERN_C              }\n#define ALLOW_NULL_OUTPUT(var,out) _t_##var, &var(out?*out:_t_##var)\n#define DEFINE_T_SUPER(B) private: typedef B T_Super; public:\n\n#if !defined (_WINGDI_)\n#define NOGDI       \n#endif                                            \n\n#ifdef  TRUE\n#undef TRUE\n#endif\n#ifdef  FALSE\n#undef FALSE\n#endif\n#ifdef  ERROR\n#undef ERROR\n#endif\n#ifdef  SUCCESS\n#undef SUCCESS\n#endif\n\nBEGIN_ATEC_NAMESPACE\nenum ATECTrueFalse\n{\n\tTRUE = 1,\n\tFALSE = 0\n};\n\nenum ATECStatus\n{\n\tSUCCESS = 0,\n\tATISUCCESS = 0,\n\tERROR = 0x8000,\n\tATIERROR = 0x8000,\n};\n\nenum class ATECCharEncoding\n{\n\tLocale = 0,\n\tUtf8 = 1\n};\n\ntypedef int                 StatusInt;\ntypedef wchar_t             WChar;\ntypedef wchar_t const*      WCharCP;\ntypedef wchar_t*            WCharP;\ntypedef char const*         CharCP;\ntypedef char*               CharP;\ntypedef Utf8Char*           Utf8P;\ntypedef Utf8Char const*     Utf8CP;\ntypedef Utf16Char*          Utf16P;\ntypedef Utf16Char const*    Utf16CP;\n\ntypedef void*               UserDataP;\ntypedef void const*         UserDataCP;\ntypedef void*               CallbackArgP;\n\nEND_ATEC_NAMESPACE\n\n#define TRUE ATEC::TRUE\n#define FALSE ATEC::FALSE\n\nATEC_TYPEDEFS(WString)\nATEC_TYPEDEFS(AString)\nATEC_TYPEDEFS(Utf8String)\nATEC_TYPEDEFS(AtProjectName)\nATEC_TYPEDEFS(AtTextFile)\nATEC_TYPEDEFS(AtIcon)\n\n#if defined (CREATE_STATIC_LIBRARIES)\n#undef ATECDLL_EXPORT    \n#define ATECDLL_EXPORT   \n#elif !defined (ATECDLL_EXPORT)\n#ifdef __ATECDLL_BUILD__\n#define ATECDLL_EXPORT EXPORT_ATTRIBUTE\n#else\n\n#define ATECDLL_EXPORT IMPORT_ATTRIBUTE\n\n#endif\n#else\n#undef ATECDLL_EXPORT    \n#define ATECDLL_EXPORT   \n#endif\n\n\n code of file CreateGeometryExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};", "output": "\n#pragma region BsplineCurve\nATEC::ATBsplineCurvePtr CreateGeometryExamples::GetBsplineCurves_FromControlPts(bool isPrintPoints)\n{\n\t//用直接提供的极点和阶数生成B样条曲线\n\tXPoint3d pnt1 = XPoint3d::From(-30, 0, -50);\n\tXPoint3d pnt2 = XPoint3d::From(0, 0, 50);\n\tXPoint3d pnt3 = XPoint3d::From(30, 0, -50);\n\tXPoint3d pnt4 = XPoint3d::From(60, 0, 50);\n\txvector<XPoint3d> vPts = { pnt1, pnt2, pnt3, pnt4 };\n\n\t//vPts是控制点\n\tint order = (int)(vPts.size() - 1);//阶数\n\tATBsplineCurvePtr bspine = ATBsplineCurve::CreateFromPolesAndOrder(vPts.data(), (int)vPts.size(), order, false);\n\n\tif (isPrintPoints)\n\t{\n\t\t//把点添加到视口--调试信息\n\t\tfor (int i = 0; i < vPts.size(); i++)\n\t\t{\n\t\t\tAddPointToScene(vPts[i], i + 1);\n\t\t}\n\t}\n\n\treturn bspine;\n}\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};. You need to implement the function CreateATBsplineCurves_FromControlPts in the interface. Here are some apis that you can use and remember:\n code of file CurveSet.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 线串类\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct CurveSet : RefCountedBase, xvector<IBasicCurvePtr>\n{\n\n\tenum BoundaryType\n\t{\n\n\t\tBOUNDARY_TYPE_None = 0,\n\n\t\tBOUNDARY_TYPE_Open = 1,\n\n\t\tBOUNDARY_TYPE_Outer = 2,\n\n\t\tBOUNDARY_TYPE_Inner = 3,\n\n\t\tBOUNDARY_TYPE_ParityRegion = 4,\n\n\t\tBOUNDARY_TYPE_UnionRegion = 5,\n\t};\n\n\tenum InOutClassification\n\t{\n\t\tINOUT_Unknown = 0,\n\t\tINOUT_In = 1,\n\t\tINOUT_Out = 2,\n\t\tINOUT_On = 3\n\t};\n\nprotected:\n\tBoundaryType    m_boundaryType;\n\npublic:\n\t/**\n\t* @brief 设定边界\n\t* @details 设定曲线的边界类型\n\t* \n\t* @param BoundaryType BoundaryType\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void SetBoundaryType(BoundaryType BoundaryType);\n\n\t/**\n\t* @brief 获取叶节点\n\t* @details 通过只计算叶节点的索引深度搜索以获取目标叶节点\n\t* \n\t* @param size_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr FindIndexedLeaf(size_t index) const;\n\n\t/**\n\t* @brief 获取索引值\n\t* @details 深度搜索以获取给定叶节点的索引值\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @param size_t & index\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool LeafToIndex(IBasicCurveCP primitive, size_t &index) const;\n\n\t/**\n\t* @brief 获取叶节点个数\n\t* @details 获取曲线的叶节点个数\n\t* \n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesBelow() const;\n\n\texplicit CurveSet(BoundaryType boundaryType) { m_boundaryType = boundaryType; }\n\n\t/**\n\t* @brief 是否单元素曲线\n\t* @details 查询曲线是否只有一个基本元素\n\t* \n\t* @return IBasicCurve\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurve::BasicCurveType HasSingleBasicCurve() const;\n\n\t/**\n\t* @brief 获取边界类型\n\t* @details 获取曲线的边界类型\n\t* \n\t* @return BoundaryType\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT BoundaryType GetBoundaryType() const;\n\n\t/**\n\t* @brief 查询是否开\n\t* @details 查询是否开路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsOpenPath() const;\n\n\t/**\n\t* @brief 查询是否闭\n\t* @details 查询是否闭路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsClosedPath() const;\n\n\t/**\n\t* @brief 查询实际开闭\n\t* @details 查询是否名义上是开路径但起点和终点连接\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsPhysicallyClosedPath() const;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个带有给定边界类型没有成员的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个具有单个基本元素和给定边界类型的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @param IBasicCurvePtr primitive\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType, IBasicCurvePtr primitive);\n\n\t/**\n\t* @brief 拷贝\n\t* @details 返回一个深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr Clone() const;\n\n\t/**\n\t* @brief 倒角拷贝\n\t* @details 返回一个深度拷贝,在连续曲线之间插入圆角\n\t* \n\t* @param double radius\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithFillets(double radius) const;\n\n\t/**\n\t* @brief 闭合拷贝\n\t* @details 返回一个深度拷贝,闭合终端点的间隙\n\t* \n\t* @param CurveGapOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithGapsClosed(CurveGapOptionsCR options) const;\n\n\t/**\n\t* @brief 添加元素\n\t* @details 递归遍历source, 将所有叶节点添加到this, 返回添加的数量\n\t* \n\t* @param CurveSetCR source\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t AddPrimitives(CurveSetCR source);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 添加单个基本曲线\n\t* \n\t* @param IBasicCurvePtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(IBasicCurvePtr child);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 将chile的所有元素作为曲线成员添加\n\t* \n\t* @param CurveSetPtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(CurveSetPtr child);\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过XY方向的偏移后的深度拷贝\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneOffsetCurvesXY(CurveOffsetOptionsCR options);\n\n\t/**\n\t* @brief 获取叶节点数量\n\t* @details 计算指定类型的叶节点数量\n\t* \n\t* @param IBasicCurve::BasicCurveType targetType\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesOfType(IBasicCurve::BasicCurveType targetType) const;\n\n\t/**\n\t* @brief 用区域分割曲线\n\t* @details 用指定区域分割曲线,分别返回区域内、外和区域上的曲线\n\t* \n\t* @param CurveSetCR region\n\t* @param CurveSetP insideCollector\n\t* @param CurveSetP outsideCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByRegion(CurveSetCR region, CurveSetP insideCollector, CurveSetP outsideCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 用平面分割曲线\n\t* @details 用指定平面分割曲线,分别返回平面上方、下方和平面内的曲线\n\t* \n\t* @param XPlane3dCR plane\n\t* @param CurveSetP belowCollector\n\t* @param CurveSetP aboveCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByPlane(XPlane3dCR plane, CurveSetP belowCollector, CurveSetP aboveCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 拆分拷贝\n\t* @details 返回一个深度拷贝,但所有的多线段被拆分成单条线段\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithExplodedLinestrings() const;\n\n\t/**\n\t* @brief 获取质心\n\t* @details 返回包含曲线的质心(不考虑孤立点)\n\t* \n\t* @param double & length\n\t* @param XPoint3dR centroid\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  WireCentroid(double &length, XPoint3dR centroid) const;\n\n\t/**\n\t* @brief 获取质心、法向量和面积\n\t* @details 返回质心、法向量和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param XVec3dR normal\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CentroidNormalArea(XPoint3dR centroid, XVec3dR normal, double &area) const;\n\n\t/**\n\t* @brief 获取质心和面积\n\t* @details 返回XY平面方向上的质心和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  CentroidAreaXY(XPoint3dR centroid, double &area) const;\n\n\t/**\n\t* @brief 投影范围\n\t* @details 当投影到射线的时候,返回射线参数的范围\n\t* \n\t* @param XRay3dCR ray\n\t* @return XRange1d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT XRange1d ProjectedParameterRange(XRay3dCR ray) const;\n\n    /**\n    * @brief 局部坐标拷贝\n    * @details 返回曲线的深度复制并转换为与曲线相关联的局部坐标系统。\n    * \n    * @param LocalCoordinateSelect frameType\n    * @param TransformR localToWorld\n    * @param TransformR worldToLocal\n    * @param XRange3dR localRange\n    * @return CurveSetPtr\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT CurveSetPtr CloneInLocalCoordinates\n    (\n    LocalCoordinateSelect frameType,\n    TransformR localToWorld,\n    TransformR worldToLocal,\n    XRange3dR localRange\n    ) const;\n\n\t/**\n    * @brief 获取有坐标系的元素\n    * @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame) const;\n\n\t/**\n\t* @brief 获取有坐标系的元素\n\t* @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @param int searchPreference\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame, int srchPref) const;\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param xvector<XPoint3d> const & points\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(xvector<XPoint3d> const&points,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint3dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint3dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建多边形\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint2dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint2dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建矩形\n\t* @details 根据 XY 坐标创建矩形\n\t* \n\t* @param double x0\n\t* @param double y0\n\t* @param double x1\n\t* @param double y1\n\t* @param double z\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateRectangle(double x0, double y0, double x1, double y1, double z,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由给定线段创建边界类型为 BOUNDARY_TYPE_None 的曲线\n\t* \n\t* @param xvector<XSegment3d> const & segments\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(xvector<XSegment3d> const &segs);\n\n\t/**\n\t* @brief 创建圆盘\n\t* @details 为一个完整的椭圆(圆)盘创建一个曲线向量结构\n\t* \n\t* @param XEllipse3dCR arc\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateDisk(XEllipse3dCR arc, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer, bool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个仅有单一元素的曲线结构\n\t* \n\t* @param IBasicCurvePtr child\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(IBasicCurvePtr child, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open);\n\n\t/**\n\t* @brief B样条拷贝\n\t* @details 返回一个深度拷贝,作为B样条曲线\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneAsBsplines() const;\n\n\t/**\n\t* @brief 添加边缘点\n\t* @details 为所有的子节点添加边缘点\n\t* \n\t* @param xvector <XPoint3d> & points\n\t* @param IFacetOptionsR options\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AddStrokePoints(xvector <XPoint3d> &points, IFacetOptionsR options) const;\n\n    /**\n\t* @brief 添加面点\n\t* @details 沿着曲线计算指定距离的点\n\t* \n\t* @param xvector<double> const & distances\n\t* @param xvector<CurveDescInfo> & locations\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool AddSpacedPoints(xvector<double> const &distances, xvector<CurveDescInfo> &locations) const;\n\n\t/**\n\t* @brief 添加边缘\n\t* @details 在结构中添加所有边缘\n\t* \n\t* @param xvector <xvector<xvector<XPoint3d>>> & regionsPoints\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CollectLinearGeometry(xvector <xvector<xvector<XPoint3d>> > &regionsPoints) const;\n\n\t/**\n\t* @brief 获取B样条曲线\n\t* @details 将一个表示开放或闭合路径作为单个B样条曲线\n\t* \n\t* @return ATBsplineCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetBsplineCurve() const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n    /**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索最接近曲线的点。如果曲线是一个区域类型,同时要在该区域的内部寻找投影\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XPoint3dR curveOrRegionPoint\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification ClosestCurveOrRegionPoint(XPoint3dCR spacePoint, XPoint3dR curveOrRegionPoint) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点和终点\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点终点和他们的正切值\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @param XVec3dR unitTangentA\n\t* @param XVec3dR unitTangentB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\t/**\n\t* @brief 获取起点\n\t* @details 返回曲线的起点\n\t* \n\t* @param XPoint3dR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线总长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length() const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线经过变换后的总长度\n\t* \n\t* @param XRotMatrixCP worldToLocal\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length(XRotMatrixCP worldToLocal) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线的xyz范围\n\t* \n\t* @param XRange3dR range\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线经过变换后的范围\n\t* \n\t* @param XRange3dR range\n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\t/**\n\t* @brief 查询索引\n\t* @details 返回指定元素的索引\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t FindIndexOfPrimitive(IBasicCurveCP primitive) const;\n\n\t/**\n\t* @brief 复制曲线指定范围的曲线\n\t* @details 复制曲线指定索引和比例参数范围内的部分\n\t* \n\t* @param int index0\n\t* @param double fraction0\n\t* @param int index1\n\t* @param double fraction1\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n    ATGEOSET_EXPORT CurveSetPtr CloneBetweenCyclicIndexedFractions(int index0, double fraction0, int index1, double fraction1) const;\n\n\t/**\n\t* @brief 反转拷贝\n\t* @details 返回一个所有元素都被反转的深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneReversed() const;\n\n\t/**\n\t* @brief 查询是否包含非线性元素\n\t* @details 如果曲线有一个不非线性元素,则返回true。\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ContainsNonLinearPrimitive() const;\n\n\t/**\n\t* @brief 计算交点\n\t* @details 计算曲线与给定平面的交点\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 平面选中\n\t* @details 计算封闭曲线与平面的交叉点,并以奇偶性规则为设为起始对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param double tolerance\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr PlaneSection(XPlane3dCR plane, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 空间点位置情况\n\t* @details 当以XY平面视角看,测试给定点在曲线内、曲线上还是曲线外\n\t* \n\t* @param XPoint3dCR xyz\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification PointInOnOutXY(XPoint3dCR xyz) const;\n\n\t/**\n\t* @brief 射线击中情况\n\t* @details 测试射线击中曲线在区域内、区域上还是区域外\n\t* \n\t* @param XRay3dCR ray\n\t* @param SolidDescInfoR hitDetail\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification RayPierceInOnOut\n\t(\n\t\tXRay3dCR ray,\n\t\tSolidDescInfoR hitDetail\n\t) const;\n\n\t/**\n\t* @brief 原地变换\n\t* @details 应用给定变换并修改曲线\n\t* \n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\t/**\n\t* @brief 原地反转\n\t* @details 将所有元素进行反转\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串内的单个点被消除,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串相邻的空间点被消除（可选）,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @param bool doSimplifyLinestrings\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives(bool doSimplifyLinestrings);\n\n\t/**\n\t* @brief 原地修改以简化线串\n\t* @details 消除线串相邻的空间点\n\t* \n\t* @param double distanceTol\n\t* @param bool eliminateOverdraw\n\t* @param bool wrap\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void SimplifyLinestrings(double distTol, bool eliminateOverdraw, bool wrap);\n\n\t/**\n\t* @brief 重排元素\n\t* @details 将曲线元素重新排序以缩小元素首尾相连的间隙\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT double ReorderForSmallGaps();\n\n\t/**\n\t* @brief 链接元素\n\t* @details 将曲线的元素首尾相连\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AssembleChains();\n\n\t/**\n\t* @brief 区域相并\n\t* @details 返回给定两个区域的并\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaUnion(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相减\n\t* @details 返回给定两个区域的减\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaDifference(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相交\n\t* @details 返回给定两个区域的交\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaIntersection(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 循环索引\n\t* @details 返回给定索引值关于集合大小的模\n\t* \n\t* @param int index\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT size_t CyclicIndex(int index) const;\n\n\t/**\n\t* @brief 循环获取值\n\t* @details 根据给定索引的循环索引获取元素\n\t* \n\t* @param ptrdiff_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr GetCyclic(ptrdiff_t index) const;\n\n    /**\n    * @brief 获取索引\n    * @details 返回给定曲线元素的详细细节所对应的元素索引\n    * \n    * @param CurveDescInfo const & location\n    * @return size_t\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT size_t CurveDescInfoIndex(CurveDescInfo const& location) const;\n\n\t/**\n\t* @brief 与平面相交\n\t* @details 计算封闭曲线与平面的交叉点,返回以奇偶性规则构造的起止点对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool AppendClosedCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过给定偏移后的深度拷贝.\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AreaOffset(CurveOffsetOptionsCR options) const;\n\n\t/**\n\t* @brief 返回从index0,fraction0到index1,fraction1的曲线段\n\t* \n\t* @param int index0 \n\t* @param double fraction0 \n\t* @param int index1 \n\t* @param double fraction1 \n\t* @param bool allowExtrapolation \n\t* @return ATGEOSET_EXPORT CurveSetPtr \n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/17\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneBetweenDirectedFractions(int index0, double fraction0, int index1, double fraction1, bool allowExtrapolation) const;\n\n\t/**\n\t* @brief 返回输入的曲线的布尔奇运算结果（区域）\n\t*\n\t* @param CurveSetCR regionA\t\t\t\t\t左操作数\n\t* @param CurveSetCR regionB\t\t\t\t\t右操作数\n\t* @param BasicCurvePtrPairVector * newToOld\t（可选）包含新旧曲线的数组指针\n\t* @return ATGEOSET_EXPORT CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/07/22\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaParity(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n};\n\nstruct CurveCurve\n{\nprivate: CurveCurve();\npublic:\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tCurveSetR curveA,\n\t\tCurveSetR curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB,\n\t\tXMatrix4dCP    pWorldToLocal,\n\t\tbool         extend = false\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveR curveA,\n\t\tCurveSetR     curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tCurveSetCR chainA,\n\t\tCurveSetCR chainB\n\t);\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            double &fractionA,\n            XPoint3dR pntA,\n            double &fractionB,\n            XPoint3dR pntB\n            );\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            CurveDescInfoR detailA,\n            CurveDescInfoR detailB\n            );\n};\n\nstruct PathLocationDetail\n{\nprivate:\n\tCurveDescInfo m_curveDetail;\n\tint32_t m_pathIndex;\n\tdouble m_pathDistance;\npublic:\n\n\tATGEOSET_EXPORT PathLocationDetail();\n\n\tATGEOSET_EXPORT PathLocationDetail(PathLocationDetail const &other);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, int pathIndex = -1, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, size_t pathIndex, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(double distance);\n\n\tATGEOSET_EXPORT XPoint3d Point() const;\n\n\tATGEOSET_EXPORT CurveDescInfo GetCurveDescInfo() const;\n\n    ATGEOSET_EXPORT double DistanceFromPathStart() const;\n};\n\nstruct CurveSetWithDistanceIndex : RefCountedBase\n{\nprivate:\n\n\tstruct PathEntry : PathLocationDetail\n\t{\n\t\tdouble             m_projectedDistance;\n\t\tXRange3d           m_range;\n\t\tPathEntry(PathLocationDetail const &pathDetail, double projectedDist, XRange3dCR range)\n\t\t\t: PathLocationDetail(pathDetail),\n\t\t\tm_projectedDistance(projectedDist),\n\t\t\tm_range(range)\n\t\t{\n\t\t}\n\t\tPathEntry(double distance) : PathLocationDetail(distance), m_projectedDistance(distance) {}\n\n\t\tdouble GetDistance(bool projected) const;\n\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistanceXY(PathEntry const &dataA, PathEntry const &dataB);\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistance(PathEntry const &dataA, PathEntry const &dataB);\n\t};\n\n\tCurveSetPtr m_curveVector;\n\txvector<PathEntry> m_locations;\n\tCurveSetPtr m_savedPrimitives;\n\n\tXRotMatrix m_worldToViewRotMatrix;\n\tXRotMatrix m_viewToWorldRotMatrix;\n\tXRotMatrix m_flattenToView;\n\tXMatrix4d m_worldToView;\n\n\texplicit CurveSetWithDistanceIndex(XRotMatrix worldToView);\n\n\tCurveSetWithDistanceIndex();\n\npublic:\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create(XRotMatrix worldToView);\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create();\n\n\tATGEOSET_EXPORT void SetPath(CurveSetPtr &path);\n\n\tATGEOSET_EXPORT bool SearchByDistanceFromPathStart\n\t(\n\t\tdouble targetDist,\n\t\tPathLocationDetail &detail\n\t) const;\n\n    ATGEOSET_EXPORT PathLocationDetail SearchClosestPointBounded\n    (\n    XPoint3dCR spacePoint,\n    bool computeDistAlong\n    ) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file IBasicCurve.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 基本线元类\n* @author SZEWC\n* @since 2022/04/28\n*/\nstruct IBasicCurve : public RefCountedBase\n{\nprivate: virtual void IAmAbstractClass() = 0;\n\npublic:\n\tenum BasicCurveType\n\t{\n\t\tBCURVE_TYPE_Invalid = 0,\n\t\tBCURVE_TYPE_Line = 1,\n\t\tBCURVE_TYPE_LineString = 2,\n\t\tBCURVE_TYPE_Arc = 3,\n\t\tBCURVE_TYPE_BsplineCurve = 4,\n\t\tBCURVE_TYPE_InterpolationCurve = 5,\n\t\tBCURVE_TYPE_AkimaCurve = 6,\n\t\tBCURVE_TYPE_PointString = 7,\n\t\tBCURVE_TYPE_CurveSet = 8,\n\t\tBCURVE_TYPE_Spiral = 9,\n\t\tBCURVE_TYPE_PartialCurve = 10,\n\t\tBCURVE_TYPE_NotClassified = -1,\n\t};\n\n\tATGEOSET_EXPORT int64_t GetTag() const;\n\n\tATGEOSET_EXPORT int GetIntTag() const;\n\n\tATGEOSET_EXPORT void SetTag(int64_t tag);\n\n\tATGEOSET_EXPORT void SetTag(int tag);\n\n\tATGEOSET_EXPORT CurveSetPtr GetChildCurveSetP();\n\npublic:\n\tATGEOSET_EXPORT xvector<XPoint3d> * GetLineStringP();\n\n\tATGEOSET_EXPORT BasicCurveType           GetBasicCurveType() const;\n\n\tATGEOSET_EXPORT bool TryGetLine(XSegment3dR segment) const;\n\n\tATGEOSET_EXPORT bool TryGetArc(XEllipse3dR arc) const;\n\n\tATGEOSET_EXPORT XSegment3dCP                 GetLineCP() const;\n\n\tATGEOSET_EXPORT xvector<XPoint3d> const* GetLineStringCP() const;\n\n\tATGEOSET_EXPORT bool TryGetSegmentInLineString(XSegment3dR segment, size_t startPointIndex) const;\n\n\tATGEOSET_EXPORT XEllipse3dCP                 GetArcCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurveCP             GetBsplineCurveCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr             GetBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr            GetProxyBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT XSpiral2dPlacementCP         GetSpiralPlacementCP() const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLine(XSegment3dCR segment);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(XPoint3dCP points, size_t nPoints);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(xvector<XPoint3d> const &points);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateArc(XEllipse3dCR ellipse);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurveCR curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurvePtr& curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiral(XSpiral2dBaseCR spiral, TransformCR frame,\n\t\tdouble fractionA, double fractionB);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusBearingRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble endRadians,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusLengthRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble length,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT IBasicCurvePtr Clone() const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneComponent(ptrdiff_t componentIndex) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneAsSingleOffsetPrimitiveXY(CurveOffsetOptionsCR options) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XRay3dR ray) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, CurveDescInfo &detail) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2, XVec3dR derivative3) const;\n\n\tATGEOSET_EXPORT bool FractionToFrenetFrame(double f, TransformR frame) const;\n\n\tATGEOSET_EXPORT bool Length(double &length) const;\n\n\tATGEOSET_EXPORT bool Length(XRotMatrixCP worldToLocal, double &length) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\tATGEOSET_EXPORT size_t NumComponent() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetATBsplineCurvePtr(double fraction0 = 0.0, double fraction1 = 1.0) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(XRotMatrixCP worldToView, double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool TrySetStart(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TrySetEnd(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\tATGEOSET_EXPORT void  AppendCurvePlaneIntersections\n\t(\n\t\tXPlane3dByVectorsCR plane,\n\t\tUVBoundarySelect   bounded,\n\t\txvector<CurveAndSolidDescInfo> &intersections\n\t) const;\n\n\tATGEOSET_EXPORT bool AddStrokes(xvector <XPoint3d> &points, IFacetOptionsR options,\n\t\tbool includeStartPoint = true,\n\t\tdouble startFraction = 0.0,\n\t\tdouble endFraction = 1.0\n\t) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, double &fraction, XPoint3dR curvePoint) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneBetweenFractions(double fractionA, double fractionB, bool allowExtrapolation) const;\n\n\tATGEOSET_EXPORT CurveSetCP            GetChildCurveSetCP() const;\n\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(double startFraction, double endFraction, double &signedDist) const;\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(XRotMatrixCP worldToLocal, double startFraction, double endFraction, double &signedDist) const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateRectangle(double x0, double y0, double x1, double y1, double z, int areaSignPref = 0);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateChildCurveSet(CurveSetPtr source);\n\n\tATGEOSET_EXPORT bool  TryGetPartialCurveData(double &fractionA, double &fractionB, IBasicCurvePtr &parentCurve, int64_t &tag) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file CreateGeometryExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};", "output": "\n\nvoid CreateGeometryExamples::CreateATBsplineCurves_FromControlPts()\n{\n\t//创建B样条曲线\n\tATBsplineCurvePtr bspine = GetBsplineCurves_FromControlPts(true);\n\n\tif (bspine.IsValid())\n\t{\n\t\tCurveSetPtr curve = CurveSet::Create(IBasicCurve::CreateBsplineCurve(bspine));\n\t\tAddGeometryToScene(curve);\n\t}\n}\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};. You need to implement the function GetBsplineCurves_FromThroughPts in the interface. Here are some apis that you can use and remember:\n code of file ATBsplineCurve.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\nstruct RefCountedATBsplineCurve;\ntypedef RefCountedPtr <RefCountedATBsplineCurve> ATBsplineCurvePtr;\ntypedef int ATBsplineStatus;\n /**\n * @brief B样条曲线\n * @author SZEWC\n * @since 2022/04/27\n*/\nstruct ATBsplineCurve\n{\npublic:\n\tint32_t             type;\n\tint32_t             rational;\n\tBsplineDisplay      display;\n\tBsplineParam        params;\n\tXPoint3d            *poles;\n\tdouble              *knots;\n\tdouble              *weights;\n\npublic:\n\n\t/**\n    * @brief 用直接提供的极点、系数和节点生成B样条曲线并返回智能指针\n\t* @return ATGEOSET_EXPORT ATBsplineCurvePtr\n\t* @param xvector<XPoint3d> const & poles\n\t* @param xvector<double> const * weights\n\t* @param xvector<double> const * knots\n\t* @param int order\n\t* @param bool closed\n\t* @param bool inputPolesAlreadyWeighted\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT static ATBsplineCurvePtr CreateFromPolesAndOrder\n\t(\n\t\txvector<XPoint3d> const &poles,\n\t\txvector<double> const *weights,\n\t\txvector<double> const *knots,\n\t\tint order,\n\t\tbool closed,\n\t\tbool inputPolesAlreadyWeighted\n\t);\n\n\t/**\n    * @brief 用直接提供的极点、系数和节点生成B样条曲线并返回智能指针\n\t* @return ATGEOSET_EXPORT ATBsplineCurvePtr\n\t* @param XPoint3dCP poles\n\t* @param int numPoles\n\t* @param int order\n\t* @param bool closed\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT static ATBsplineCurvePtr CreateFromPolesAndOrder\n\t(\n\t\tXPoint3dCP poles,\n\t\tint numPoles,\n\t\tint order,\n\t\tbool closed = false\n\t);\n\n\t/**\n    * @brief 用直接提供的极点、系数和节点生成B样条曲线并返回智能指针\n\t* @return ATGEOSET_EXPORT ATBsplineCurvePtr\n\t* @param XPoint2dCP poles\n\t* @param int numPoles\n\t* @param int order\n\t* @param bool closed\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT static ATBsplineCurvePtr CreateFromPolesAndOrder\n\t(\n\t\tXPoint2dCP poles,\n\t\tint numPoles,\n\t\tint order,\n\t\tbool closed = false\n\t);\n\n\t/**\n    * @brief 复制曲线指定分数参数之间的部分\n\t* @return ATGEOSET_EXPORT ATBsplineCurvePtr\n\t* @param double fraction0\n\t* @param double fraction1\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT ATBsplineCurvePtr CreateCopyBetweenFractions(double fraction0, double fraction1) const;\n\n\t/**\n    * @brief 创建一个近似于BasicCurve的样条曲线\n\t* @return ATGEOSET_EXPORT ATBsplineCurvePtr\n\t* @param IBasicCurveCR curve\n\t* @param size_t numPoles\n\t* @param int order\n\t* @param bool normalizeKnots\n\t* @param int knotSelector\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tstatic ATGEOSET_EXPORT ATBsplineCurvePtr CreateFromInterpolationAtGrevilleKnots\n\t(\n\t\tIBasicCurveCR curve,\n\t\tsize_t numPoles,\n\t\tint order,\n\t\tbool normalizeKnots,\n\t\tint knotSelector = 0\n\t);\n\n\t/**\n    * @brief B样条曲线上指定点的分数参数\n\t* @return ATGEOSET_EXPORT void\n\t* @param XPoint3dR xyz\n\t* @param double f\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT void FractionToPoint(XPoint3dR xyz, double f) const;\n\n\t/**\n    * @brief B样条曲线上指定点的分数参数\n\t* @return ATGEOSET_EXPORT void\n\t* @param XPoint3dR xyz\n\t* @param XVec3dR tangent\n\t* @param double f\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT void FractionToPoint(XPoint3dR xyz, XVec3dR tangent, double f) const;\n\n\t/**\n    * @brief 通过索引返回极点,如果超出范围返回0\n\t* @return ATGEOSET_EXPORT XPoint3d\n\t* @param size_t index\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT XPoint3d GetPole(size_t index) const;\n\n\t/**\n    * @brief 通过索引返回极点,如果超出范围返回0\n\t* @return ATGEOSET_EXPORT XPoint3d\n\t* @param int index\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT XPoint3d GetPole(int index) const;\n\n\t/**\n    * @brief 根据索引设定极点,如果索引超出范围,返回false\n\t* @return ATGEOSET_EXPORT bool\n\t* @param size_t index\n\t* @param XPoint3dCR value\n\t* @param bool reverse\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT bool SetReWeightedPole(size_t index, XPoint3dCR value, bool reverse = false);\n\n\t/**\n    * @brief 根据索引设定极点,如果索引超出范围,返回false\n\t* @return ATGEOSET_EXPORT bool\n\t* @param int index\n\t* @param XPoint3dCR value\n\t* @param bool reverse\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT bool SetReWeightedPole(int index, XPoint3dCR value, bool reverse = false);\n\n\t/**\n    * @brief 获取分离权重参数后的极点\n\t* @return ATGEOSET_EXPORT void\n\t* @param xvector<XPoint3d> & outData\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT void GetUnWeightedPoles(xvector<XPoint3d> &outData) const;\n\n\t/**\n    * @brief 获取所有极点\n\t* @return ATGEOSET_EXPORT void\n\t* @param xvector<XPoint3d> & outData\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT void GetPoles(xvector<XPoint3d> &outData) const;\n\n\t/**\n    * @brief 获取极点个数\n\t* @return ATGEOSET_EXPORT int\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT int GetIntNumPoles() const;\n\n\t/**\n    * @brief 计算B样条曲线的长度\n\t* @return ATGEOSET_EXPORT double\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT double Length() const;\n\n\t/**\n    * @brief 计算经过变换的曲线长度\n\t* @return ATGEOSET_EXPORT double\n\t* @param XRotMatrixCP worldToLocal\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT double Length(XRotMatrixCP worldToLocal) const;\n\n\t/**\n    * @brief 计算与平面的交点\n\t* @return ATGEOSET_EXPORT void\n\t* @param xvector<XPoint3d> * points\n\t* @param xvector<double> * fractionParameters\n\t* @param XPlane3dCR plane\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT void AddPlaneIntersections(xvector<XPoint3d>* points, xvector<double> *fractionParameters, XPlane3dCR plane) const;\n\n\t/**\n    * @brief 计算与平面的交点\n\t* @return ATGEOSET_EXPORT void\n\t* @param xvector<XPoint3d> * points\n\t* @param xvector<double> * fractionParameters\n\t* @param XPoint4dCR planeCoffs\n\t* @author SZEWEC\n\t* @since 2022/04/07\n\t*/\n\tATGEOSET_EXPORT void AddPlaneIntersections(xvector<XPoint3d>* points, xvector<double> *fractionParameters, XPoint4dCR planeCoffs) const;\n\n\t/**\n    * @brief 在XY方向上计算与直线的交点\n\t* @return ATGEOSET_EXPORT void\n\t* @param xvector<XPoint3d> * curvePoints\n\t* @param xvector<double> * curveFractions\n\t* @param xvector<XPoint3d> * linePoints\n\t* @param xvector<double> * lineFractions\n\t* @param XSegment3dCR segment\n\t* @param bool extendSegment\n\t* @param XMatrix4dCP matrix\n\t* @author SZEWEC\n\t* @since 2022/04/07\n\t*/\n\tATGEOSET_EXPORT void AddLineIntersectionsXY(xvector<XPoint3d> *curvePoints, xvector<double> *curveFractions,\n\t\txvector<XPoint3d> *linePoints, xvector<double> *lineFractions,\n\t\tXSegment3dCR segment, bool extendSeg, XMatrix4dCP matrix) const;\n\n\t/**\n    * @brief 获取B样条曲线的起始或终止端点\n\t* @return ATGEOSET_EXPORT void\n\t* @param XPoint3dR start\n\t* @param XPoint3dR end\n\t* @author SZEWEC\n\t* @since 2022/04/07\n\t*/\n\tATGEOSET_EXPORT void ExtractEndPoints(XPoint3dR start, XPoint3dR end) const;\n\n\t/**\n    * @brief 计算近似路径\n\t* @return ATGEOSET_EXPORT void\n\t* @param xvector <XPoint3d> & points\n\t* @param double chordTol\n\t* @param double angleTol\n\t* @param double maxEdgeLength\n\t* @param bool includeStartPoint\n\t* @author SZEWEC\n\t* @since 2022/04/07\n\t*/\n\tATGEOSET_EXPORT void AddStrokes(xvector <XPoint3d> &points,\n\t\tdouble chordTol = 0.0, double angleTol = 0.20, double maxEdgeLength = 0.0, bool includeStartPoint = true) const;\n\n\t/**\n    * @brief 计算在均分角度上的点\n\t* @return ATGEOSET_EXPORT bool\n\t* @param xvector <XPoint3d> & points\n\t* @param xvector<double> & fractions\n\t* @param size_t numPoints\n\t* @author SZEWEC\n\t* @since 2022/04/07\n\t*/\n\tATGEOSET_EXPORT bool PointsAtUniformArcLength(xvector <XPoint3d> &points, xvector<double> &fractions, size_t numPoints) const;\n\n\t/**\n    * @brief 获取曲线上离给定点最接近的点和对应的分数参数\n\t* @return ATGEOSET_EXPORT void\n\t* @param XPoint3dR curvePoint\n\t* @param double & fraction\n\t* @param XPoint3dCR spacePoint\n\t* @author SZEWEC\n\t* @since 2022/04/07\n\t*/\n\tATGEOSET_EXPORT void ClosestPoint(XPoint3dR curvePoint, double &fraction, XPoint3dCR spacePoint) const;\n\n\t/**\n\t* @brief 使用Lim拟合条件创建B样条曲线\n\t*\n\t* @param xvector<XPoint3d>const & xyz\t\t\t插值点\n\t* @param size_t order\t\t\t\t\t\t\tB样条阶数\n\t* @param int knotType\t\t\t\t\t\t\t节点类型,0为uniform、1为chord length、2为centripetal\n\t* @return ATGEOSET_EXPORT ATBsplineCurvePtr\tB样条曲线\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/29\n\t*/\n\tstatic ATGEOSET_EXPORT ATBsplineCurvePtr CreateFromInterpolationAtBasisFunctionPeaks(xvector<XPoint3d>const &xyz, size_t order, int knotType = 0);\n\t/**\n\t* @brief 返回曲线阶数\n\t* \n\t* @return ATGEOSET_EXPORT size_t 阶数\n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/30\n\t*/\n\tATGEOSET_EXPORT size_t GetOrder() const;\n\n\t/**\n\t* @brief 创建在不相交节点分割的各段的拷贝\n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/31\n\t*/\n\tATGEOSET_EXPORT void GetDisjointCurves(xvector<ATBsplineCurvePtr> &curves) const;\n\n\t/**\n\t* @brief 创建在点或切线变化处分割的各段的拷贝\n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/31\n\t*/\n\tATGEOSET_EXPORT void GetC1DiscontinuousCurves(xvector<double> &fractions, xvector<ATBsplineCurvePtr> &curves) const;\n\n    //! Create the B-spline curve from point array and order.\n    ATGEOSET_EXPORT ATBsplineStatus InitFromPoints(XPoint3dCP points, int nPoints);\n};\n\nstruct RefCountedATBsplineCurve : public ATBsplineCurve, RefCountedBase\n{\nprotected:\n\tRefCountedATBsplineCurve();\n\t~RefCountedATBsplineCurve();\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XPoint3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n /**\n * @brief 3D绌洪棿鐐圭被\n * @author SZEWC\n * @since 2022/04/13\n*/\nstruct ATGEOSET_EXPORT XPoint3d\n{\n\n\tdouble x;\n\n\tdouble y;\n\n\tdouble z;\n\n\tstatic XPoint3d From(double x, double y, double z = 0.0);\n\n\tstatic XPoint3d From(XPoint2dCR xy);\n\n\tstatic XPoint3d FromZero();\n\n\tstatic XPoint3d FromOne();\n\n\tstatic XPoint3d FromXYZ(double x, double y, double z);\n\n\tvoid Swap(XPoint3dR other);\n\n\tdouble DotDifference(XPoint3dCR origin, XVec3dCR vector) const;\n\n\tvoid Zero();\n\n\tvoid Init(XPoint2dCR source);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double ay);\n\n\tvoid SetComponent(double a, int index);\n\n\tdouble GetComponent(int index) const;\n\n\tvoid Interpolate(XPoint3dCR pnt0, double fractionParameter, XPoint3dCR point1);\n\n\tdouble Distance(XPoint3dCR point2) const;\n\n\tdouble DistanceXY(XPoint3dCR point2) const;\n\n\tbool DistanceXY(XPoint3dCR otherPoint, XMatrix4dCP matrix, double &distance) const;\n\n\tbool IsEqual(XPoint3dCR point2) const;\n\n\tbool IsEqual(XPoint3dCR point2, double tolerance) const;\n\n\tbool IsDisconnect() const;\n\n\tvoid InitDisconnect();\n\n\tvoid Init(XVec3dCR vector);\n\n\tvoid Subtract(XPoint3dCR base, XVec3dCR vector);\n\n\tvoid Add(XVec3dCR vector);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2, XVec3dCR point3, double scale3);\n\n\tvoid CrossProduct(XPoint3dCR point1, XPoint3dCR point2);\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble AngleTo(XPoint3dCR point2) const;\n\n\tvoid RotateXY(XPoint3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tdouble MagnitudeXY() const;\n\n\tvoid Scale(XPoint3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XPoint3dCR vector);\n\n\tvoid Negate();\n\n\tdouble Normalize(XPoint3dCR vector);\n\n\tdouble Normalize();\n\n\tvoid Subtract(XPoint3dCR point2);\n\n\tvoid DifferenceOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2, XPoint3dCR point3, double scale3);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2, XPoint3dCR point3, double a3);\n\n\tvoid Add(XPoint3dCR vector);\n\n\tvoid SumOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, XPoint3dCR point);\n\n\tstatic XPoint3d FromInterpolate(XPoint3dCR pntA, double fraction, XPoint3dCR pntB);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector, double scaleFactor);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1, XPoint3dCR point2, double scaleFactor2);\n\n\tstatic XPoint3d FromScale(XPoint3d point, double scale);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, XVec3dCR vector);\n\n\tbool AlmostEqual(XPoint3d const & dataB) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB) const;\n\n\tbool AlmostEqual(XPoint3d const & dataB, double abstol) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB, double abstol) const;\n\n\tstatic bool AlmostEqual(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tstatic bool AlmostEqualXY(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tdouble DistanceSquared(XPoint3dCR point2) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file ATEC.h: \n/**\n* @file ATEC.h\n*\n* @author SZEWC\n* @date 2022/04/28\n*/\n\n#pragma once\n\n#if !defined (__cplusplus)\n#error \"This file is for C++ compilands only\"\n#endif\n\n#if !defined (_WIN32)\n#error \"Windows is the only platform supported\"\n#endif\n#ifndef ATEC_WIN32\n#define ATEC_WIN32\n#endif\n\n#define ATECCONFIG_GRAPHICS_DIRECTX\n\n#if defined (__unix__)\n\n#include <stddef.h>     \n\n#define override\n#define _countof(_Array) (sizeof(_Array)/sizeof((_Array)[0]))\n#define _CRT_WIDE(A) L\"\" A\n\nextern void _wassert(wchar_t const*, wchar_t const*, int);\n\n#if defined (__MINGW32__)\n\n#define EXPORT_ATTRIBUTE        __declspec(dllexport)\n#define IMPORT_ATTRIBUTE        __declspec(dllimport)\n#define DLLPUBLIC_ATTRIBUTE\n#define DLLLOCAL_ATTRIBUTE\n#define EXPORT_VTABLE_ATTRIBUTE\n#define CDECL_ATTRIBUTE         __cdecl\n#define STDCALL_ATTRIBUTE       __stdcall\n#else\n\n#define _alloca(x)              __builtin_alloca((x))\n#define EXPORT_VTABLE_ATTRIBUTE     __attribute__((visibility (\"default\")))\n#define DLLPUBLIC_ATTRIBUTE     __attribute__((visibility (\"default\")))\n#define EXPORT_ATTRIBUTE        __attribute__((visibility (\"default\")))\n#define IMPORT_ATTRIBUTE        __attribute__((visibility (\"default\")))\n#define DLLLOCAL_ATTRIBUTE      __attribute__((visibility (\"hidden\")))\n#define CDECL_ATTRIBUTE\n#define STDCALL_ATTRIBUTE\n#endif \n\n#define ENUM_UNDERLYING_TYPE(T) \n\n#define STD_TR1 std\n\ntypedef void* ULONG_PTR;\n\n#define UNREACHABLE_CODE(stmt)\n\n#define DECLARE_KEY_METHOD __attribute__((visibility (\"default\"))) virtual void DummyKeyMethod() const;\n\n#elif defined (_WIN32)\n\n#include \"suppress_warnings.h\"\n\n#define DLLPUBLIC_ATTRIBUTE\n#define EXPORT_ATTRIBUTE        __declspec(dllexport)\n#define IMPORT_ATTRIBUTE        __declspec(dllimport)\n#define DLLLOCAL_ATTRIBUTE        \n#define DLLPUBLIC_ATTRIBUTE       \n#define EXPORT_VTABLE_ATTRIBUTE   \n#define CDECL_ATTRIBUTE         __cdecl\n#define STDCALL_ATTRIBUTE       __stdcall\n#define ENUM_UNDERLYING_TYPE(T)   : T\n\n#if (_MSC_VER < 1600) \n#include <limits.h>\n#if defined(_M_X64)\n#define INTPTR_MIN      _I64_MIN\n#define INTPTR_MAX      _I64_MAX\n#define UINTPTR_MAX     _UI64_MAX\n#else \n#define INTPTR_MIN      _I32_MIN\n#define INTPTR_MAX      _I32_MAX\n#define UINTPTR_MAX     _UI32_MAX\n#endif\n#endif\n\n#define HAVE_TR1\n#define STD_TR1 std::tr1\n\n#if defined(_M_X64)\ntypedef unsigned __int64    ULONG_PTR;\n#else \ntypedef __w64 unsigned long  ULONG_PTR;\n#endif \n\n#define DECLARE_KEY_METHOD\n\n#else\n#error unknown compiler\n#endif\n\n#ifdef CREATE_STATIC_LIBRARIES\n#undef EXPORT_ATTRIBUTE\n#undef IMPORT_ATTRIBUTE\n#define EXPORT_ATTRIBUTE\n#define IMPORT_ATTRIBUTE\n#endif\n\n#include \"ATEC.r.h\"\n\n#include <limits.h>\n\n#ifndef INT32_MAX\n#define INT32_MAX   INT_MAX\n#endif\n#ifndef UINT32_MAX\n#define UINT32_MAX  UINT_MAX\n#endif\n#ifndef INT64_MAX\n#define INT64_MAX   LLONG_MAX\n#endif\n#ifndef UINT64_MAX\n#define UINT64_MAX  ULLONG_MAX\n#endif\n#ifndef INT32_MIN\n#define INT32_MIN   INT_MIN\n#endif\n#ifndef INT64_MIN\n#define INT64_MIN   LLONG_MIN\n#endif\n\n#define USING_NAMESPACE_ATEC using namespace ATEC_NAMESPACE_NAME;\n\n#define GLOBAL_TYPEDEFS(_name_) \\\n        struct _name_; \\\n        typedef _name_*          _name_##P;  \\\n        typedef _name_&          _name_##R;  \\\n        typedef _name_ const*    _name_##CP; \\\n        typedef _name_ const&    _name_##CR; \\\n\n#define ADD_ATEC_TYPEDEFS1(_namespace_,_srcName_,_name_,structclass) \\\n    namespace ATEC_NAMESPACE_NAME {\\\n    typedef structclass _namespace_ :: _srcName_*          _name_##P, &_name_##R;  \\\n    typedef structclass _namespace_ :: _srcName_ const*    _name_##CP; \\\n    typedef structclass _namespace_ :: _srcName_ const&    _name_##CR; }\n\n#define ADD_ATEC_TYPEDEFS(_namespace_,_name_) ADD_ATEC_TYPEDEFS1(_namespace_,_name_,_name_,struct)\n#define ADD_ATEC_ENUM_TYPEDEF(_namespace_,_name_,_tEnum_) namespace ATEC_NAMESPACE_NAME {typedef enum _namespace_ :: _name_ _tEnum_;}\n#define ATEC_TYPEDEF(t,tP)    namespace ATEC_NAMESPACE_NAME {struct t; typedef struct ATEC_NAMESPACE_NAME::t*   tP;}\n#define ATEC_TYPEDEFS(_name_) namespace ATEC_NAMESPACE_NAME {struct _name_;} ADD_ATEC_TYPEDEFS(ATEC_NAMESPACE_NAME,_name_)\n#define ATEC_REF_COUNTED_PTR(_sname_) namespace ATEC_NAMESPACE_NAME {struct _sname_; typedef RefCountedPtr<_sname_> _sname_##Ptr;}\n\n#define ATEC_NAMESPACE_TYPEDEFS(_name_) ATEC_TYPEDEFS(_name_)\n\n#if !defined (NULL)\n#define NULL    0\n#endif\n\n#if !defined (NO_ATEC_PUBLIC)\n#define Public\n#endif\n\n#define BEGIN_EXTERN_C extern \"C\" {\n#define END_EXTERN_C              }\n#define ALLOW_NULL_OUTPUT(var,out) _t_##var, &var(out?*out:_t_##var)\n#define DEFINE_T_SUPER(B) private: typedef B T_Super; public:\n\n#if !defined (_WINGDI_)\n#define NOGDI       \n#endif                                            \n\n#ifdef  TRUE\n#undef TRUE\n#endif\n#ifdef  FALSE\n#undef FALSE\n#endif\n#ifdef  ERROR\n#undef ERROR\n#endif\n#ifdef  SUCCESS\n#undef SUCCESS\n#endif\n\nBEGIN_ATEC_NAMESPACE\nenum ATECTrueFalse\n{\n\tTRUE = 1,\n\tFALSE = 0\n};\n\nenum ATECStatus\n{\n\tSUCCESS = 0,\n\tATISUCCESS = 0,\n\tERROR = 0x8000,\n\tATIERROR = 0x8000,\n};\n\nenum class ATECCharEncoding\n{\n\tLocale = 0,\n\tUtf8 = 1\n};\n\ntypedef int                 StatusInt;\ntypedef wchar_t             WChar;\ntypedef wchar_t const*      WCharCP;\ntypedef wchar_t*            WCharP;\ntypedef char const*         CharCP;\ntypedef char*               CharP;\ntypedef Utf8Char*           Utf8P;\ntypedef Utf8Char const*     Utf8CP;\ntypedef Utf16Char*          Utf16P;\ntypedef Utf16Char const*    Utf16CP;\n\ntypedef void*               UserDataP;\ntypedef void const*         UserDataCP;\ntypedef void*               CallbackArgP;\n\nEND_ATEC_NAMESPACE\n\n#define TRUE ATEC::TRUE\n#define FALSE ATEC::FALSE\n\nATEC_TYPEDEFS(WString)\nATEC_TYPEDEFS(AString)\nATEC_TYPEDEFS(Utf8String)\nATEC_TYPEDEFS(AtProjectName)\nATEC_TYPEDEFS(AtTextFile)\nATEC_TYPEDEFS(AtIcon)\n\n#if defined (CREATE_STATIC_LIBRARIES)\n#undef ATECDLL_EXPORT    \n#define ATECDLL_EXPORT   \n#elif !defined (ATECDLL_EXPORT)\n#ifdef __ATECDLL_BUILD__\n#define ATECDLL_EXPORT EXPORT_ATTRIBUTE\n#else\n\n#define ATECDLL_EXPORT IMPORT_ATTRIBUTE\n\n#endif\n#else\n#undef ATECDLL_EXPORT    \n#define ATECDLL_EXPORT   \n#endif\n\n\n code of file CreateGeometryExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};", "output": "\nATEC::ATBsplineCurvePtr CreateGeometryExamples::GetBsplineCurves_FromThroughPts(bool isPrintPoints)\n{\n\t//从基函数峰值插值创建B样条曲线\n\tXPoint3d pnt1 = XPoint3d::From(-30, 50, 0);\n\tXPoint3d pnt2 = XPoint3d::From(0, -50, 0);\n\tXPoint3d pnt3 = XPoint3d::From(30, 50, 0);\n\tXPoint3d pnt4 = XPoint3d::From(60, -50, 0);\n\tXPoint3d pnt5 = XPoint3d::From(90, 50, 0);\n\txvector<XPoint3d> vPts = { pnt1, pnt2, pnt3, pnt4, pnt5 };\n\n\t//listPts 是插值点=通过点\n\tsize_t order = vPts.size();\n\tATBsplineCurvePtr bslpineCurve = ATBsplineCurve::CreateFromInterpolationAtBasisFunctionPeaks(vPts, order, 0);\n\n\tif (isPrintPoints)\n\t{\n\t\t//把点添加到视口--调试信息\n\t\tfor (int i = 0; i < vPts.size(); i++)\n\t\t{\n\t\t\tAddPointToScene(vPts[i], i + 1);\n\t\t}\n\t}\n\treturn bslpineCurve;\n}\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};. You need to implement the function CreateATBsplineCurves_FromThroughPts in the interface. Here are some apis that you can use and remember:\n code of file CurveSet.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 线串类\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct CurveSet : RefCountedBase, xvector<IBasicCurvePtr>\n{\n\n\tenum BoundaryType\n\t{\n\n\t\tBOUNDARY_TYPE_None = 0,\n\n\t\tBOUNDARY_TYPE_Open = 1,\n\n\t\tBOUNDARY_TYPE_Outer = 2,\n\n\t\tBOUNDARY_TYPE_Inner = 3,\n\n\t\tBOUNDARY_TYPE_ParityRegion = 4,\n\n\t\tBOUNDARY_TYPE_UnionRegion = 5,\n\t};\n\n\tenum InOutClassification\n\t{\n\t\tINOUT_Unknown = 0,\n\t\tINOUT_In = 1,\n\t\tINOUT_Out = 2,\n\t\tINOUT_On = 3\n\t};\n\nprotected:\n\tBoundaryType    m_boundaryType;\n\npublic:\n\t/**\n\t* @brief 设定边界\n\t* @details 设定曲线的边界类型\n\t* \n\t* @param BoundaryType BoundaryType\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void SetBoundaryType(BoundaryType BoundaryType);\n\n\t/**\n\t* @brief 获取叶节点\n\t* @details 通过只计算叶节点的索引深度搜索以获取目标叶节点\n\t* \n\t* @param size_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr FindIndexedLeaf(size_t index) const;\n\n\t/**\n\t* @brief 获取索引值\n\t* @details 深度搜索以获取给定叶节点的索引值\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @param size_t & index\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool LeafToIndex(IBasicCurveCP primitive, size_t &index) const;\n\n\t/**\n\t* @brief 获取叶节点个数\n\t* @details 获取曲线的叶节点个数\n\t* \n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesBelow() const;\n\n\texplicit CurveSet(BoundaryType boundaryType) { m_boundaryType = boundaryType; }\n\n\t/**\n\t* @brief 是否单元素曲线\n\t* @details 查询曲线是否只有一个基本元素\n\t* \n\t* @return IBasicCurve\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurve::BasicCurveType HasSingleBasicCurve() const;\n\n\t/**\n\t* @brief 获取边界类型\n\t* @details 获取曲线的边界类型\n\t* \n\t* @return BoundaryType\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT BoundaryType GetBoundaryType() const;\n\n\t/**\n\t* @brief 查询是否开\n\t* @details 查询是否开路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsOpenPath() const;\n\n\t/**\n\t* @brief 查询是否闭\n\t* @details 查询是否闭路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsClosedPath() const;\n\n\t/**\n\t* @brief 查询实际开闭\n\t* @details 查询是否名义上是开路径但起点和终点连接\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsPhysicallyClosedPath() const;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个带有给定边界类型没有成员的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个具有单个基本元素和给定边界类型的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @param IBasicCurvePtr primitive\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType, IBasicCurvePtr primitive);\n\n\t/**\n\t* @brief 拷贝\n\t* @details 返回一个深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr Clone() const;\n\n\t/**\n\t* @brief 倒角拷贝\n\t* @details 返回一个深度拷贝,在连续曲线之间插入圆角\n\t* \n\t* @param double radius\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithFillets(double radius) const;\n\n\t/**\n\t* @brief 闭合拷贝\n\t* @details 返回一个深度拷贝,闭合终端点的间隙\n\t* \n\t* @param CurveGapOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithGapsClosed(CurveGapOptionsCR options) const;\n\n\t/**\n\t* @brief 添加元素\n\t* @details 递归遍历source, 将所有叶节点添加到this, 返回添加的数量\n\t* \n\t* @param CurveSetCR source\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t AddPrimitives(CurveSetCR source);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 添加单个基本曲线\n\t* \n\t* @param IBasicCurvePtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(IBasicCurvePtr child);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 将chile的所有元素作为曲线成员添加\n\t* \n\t* @param CurveSetPtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(CurveSetPtr child);\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过XY方向的偏移后的深度拷贝\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneOffsetCurvesXY(CurveOffsetOptionsCR options);\n\n\t/**\n\t* @brief 获取叶节点数量\n\t* @details 计算指定类型的叶节点数量\n\t* \n\t* @param IBasicCurve::BasicCurveType targetType\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesOfType(IBasicCurve::BasicCurveType targetType) const;\n\n\t/**\n\t* @brief 用区域分割曲线\n\t* @details 用指定区域分割曲线,分别返回区域内、外和区域上的曲线\n\t* \n\t* @param CurveSetCR region\n\t* @param CurveSetP insideCollector\n\t* @param CurveSetP outsideCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByRegion(CurveSetCR region, CurveSetP insideCollector, CurveSetP outsideCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 用平面分割曲线\n\t* @details 用指定平面分割曲线,分别返回平面上方、下方和平面内的曲线\n\t* \n\t* @param XPlane3dCR plane\n\t* @param CurveSetP belowCollector\n\t* @param CurveSetP aboveCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByPlane(XPlane3dCR plane, CurveSetP belowCollector, CurveSetP aboveCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 拆分拷贝\n\t* @details 返回一个深度拷贝,但所有的多线段被拆分成单条线段\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithExplodedLinestrings() const;\n\n\t/**\n\t* @brief 获取质心\n\t* @details 返回包含曲线的质心(不考虑孤立点)\n\t* \n\t* @param double & length\n\t* @param XPoint3dR centroid\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  WireCentroid(double &length, XPoint3dR centroid) const;\n\n\t/**\n\t* @brief 获取质心、法向量和面积\n\t* @details 返回质心、法向量和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param XVec3dR normal\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CentroidNormalArea(XPoint3dR centroid, XVec3dR normal, double &area) const;\n\n\t/**\n\t* @brief 获取质心和面积\n\t* @details 返回XY平面方向上的质心和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  CentroidAreaXY(XPoint3dR centroid, double &area) const;\n\n\t/**\n\t* @brief 投影范围\n\t* @details 当投影到射线的时候,返回射线参数的范围\n\t* \n\t* @param XRay3dCR ray\n\t* @return XRange1d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT XRange1d ProjectedParameterRange(XRay3dCR ray) const;\n\n    /**\n    * @brief 局部坐标拷贝\n    * @details 返回曲线的深度复制并转换为与曲线相关联的局部坐标系统。\n    * \n    * @param LocalCoordinateSelect frameType\n    * @param TransformR localToWorld\n    * @param TransformR worldToLocal\n    * @param XRange3dR localRange\n    * @return CurveSetPtr\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT CurveSetPtr CloneInLocalCoordinates\n    (\n    LocalCoordinateSelect frameType,\n    TransformR localToWorld,\n    TransformR worldToLocal,\n    XRange3dR localRange\n    ) const;\n\n\t/**\n    * @brief 获取有坐标系的元素\n    * @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame) const;\n\n\t/**\n\t* @brief 获取有坐标系的元素\n\t* @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @param int searchPreference\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame, int srchPref) const;\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param xvector<XPoint3d> const & points\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(xvector<XPoint3d> const&points,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint3dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint3dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建多边形\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint2dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint2dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建矩形\n\t* @details 根据 XY 坐标创建矩形\n\t* \n\t* @param double x0\n\t* @param double y0\n\t* @param double x1\n\t* @param double y1\n\t* @param double z\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateRectangle(double x0, double y0, double x1, double y1, double z,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由给定线段创建边界类型为 BOUNDARY_TYPE_None 的曲线\n\t* \n\t* @param xvector<XSegment3d> const & segments\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(xvector<XSegment3d> const &segs);\n\n\t/**\n\t* @brief 创建圆盘\n\t* @details 为一个完整的椭圆(圆)盘创建一个曲线向量结构\n\t* \n\t* @param XEllipse3dCR arc\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateDisk(XEllipse3dCR arc, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer, bool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个仅有单一元素的曲线结构\n\t* \n\t* @param IBasicCurvePtr child\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(IBasicCurvePtr child, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open);\n\n\t/**\n\t* @brief B样条拷贝\n\t* @details 返回一个深度拷贝,作为B样条曲线\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneAsBsplines() const;\n\n\t/**\n\t* @brief 添加边缘点\n\t* @details 为所有的子节点添加边缘点\n\t* \n\t* @param xvector <XPoint3d> & points\n\t* @param IFacetOptionsR options\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AddStrokePoints(xvector <XPoint3d> &points, IFacetOptionsR options) const;\n\n    /**\n\t* @brief 添加面点\n\t* @details 沿着曲线计算指定距离的点\n\t* \n\t* @param xvector<double> const & distances\n\t* @param xvector<CurveDescInfo> & locations\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool AddSpacedPoints(xvector<double> const &distances, xvector<CurveDescInfo> &locations) const;\n\n\t/**\n\t* @brief 添加边缘\n\t* @details 在结构中添加所有边缘\n\t* \n\t* @param xvector <xvector<xvector<XPoint3d>>> & regionsPoints\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CollectLinearGeometry(xvector <xvector<xvector<XPoint3d>> > &regionsPoints) const;\n\n\t/**\n\t* @brief 获取B样条曲线\n\t* @details 将一个表示开放或闭合路径作为单个B样条曲线\n\t* \n\t* @return ATBsplineCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetBsplineCurve() const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n    /**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索最接近曲线的点。如果曲线是一个区域类型,同时要在该区域的内部寻找投影\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XPoint3dR curveOrRegionPoint\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification ClosestCurveOrRegionPoint(XPoint3dCR spacePoint, XPoint3dR curveOrRegionPoint) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点和终点\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点终点和他们的正切值\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @param XVec3dR unitTangentA\n\t* @param XVec3dR unitTangentB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\t/**\n\t* @brief 获取起点\n\t* @details 返回曲线的起点\n\t* \n\t* @param XPoint3dR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线总长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length() const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线经过变换后的总长度\n\t* \n\t* @param XRotMatrixCP worldToLocal\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length(XRotMatrixCP worldToLocal) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线的xyz范围\n\t* \n\t* @param XRange3dR range\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线经过变换后的范围\n\t* \n\t* @param XRange3dR range\n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\t/**\n\t* @brief 查询索引\n\t* @details 返回指定元素的索引\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t FindIndexOfPrimitive(IBasicCurveCP primitive) const;\n\n\t/**\n\t* @brief 复制曲线指定范围的曲线\n\t* @details 复制曲线指定索引和比例参数范围内的部分\n\t* \n\t* @param int index0\n\t* @param double fraction0\n\t* @param int index1\n\t* @param double fraction1\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n    ATGEOSET_EXPORT CurveSetPtr CloneBetweenCyclicIndexedFractions(int index0, double fraction0, int index1, double fraction1) const;\n\n\t/**\n\t* @brief 反转拷贝\n\t* @details 返回一个所有元素都被反转的深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneReversed() const;\n\n\t/**\n\t* @brief 查询是否包含非线性元素\n\t* @details 如果曲线有一个不非线性元素,则返回true。\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ContainsNonLinearPrimitive() const;\n\n\t/**\n\t* @brief 计算交点\n\t* @details 计算曲线与给定平面的交点\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 平面选中\n\t* @details 计算封闭曲线与平面的交叉点,并以奇偶性规则为设为起始对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param double tolerance\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr PlaneSection(XPlane3dCR plane, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 空间点位置情况\n\t* @details 当以XY平面视角看,测试给定点在曲线内、曲线上还是曲线外\n\t* \n\t* @param XPoint3dCR xyz\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification PointInOnOutXY(XPoint3dCR xyz) const;\n\n\t/**\n\t* @brief 射线击中情况\n\t* @details 测试射线击中曲线在区域内、区域上还是区域外\n\t* \n\t* @param XRay3dCR ray\n\t* @param SolidDescInfoR hitDetail\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification RayPierceInOnOut\n\t(\n\t\tXRay3dCR ray,\n\t\tSolidDescInfoR hitDetail\n\t) const;\n\n\t/**\n\t* @brief 原地变换\n\t* @details 应用给定变换并修改曲线\n\t* \n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\t/**\n\t* @brief 原地反转\n\t* @details 将所有元素进行反转\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串内的单个点被消除,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串相邻的空间点被消除（可选）,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @param bool doSimplifyLinestrings\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives(bool doSimplifyLinestrings);\n\n\t/**\n\t* @brief 原地修改以简化线串\n\t* @details 消除线串相邻的空间点\n\t* \n\t* @param double distanceTol\n\t* @param bool eliminateOverdraw\n\t* @param bool wrap\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void SimplifyLinestrings(double distTol, bool eliminateOverdraw, bool wrap);\n\n\t/**\n\t* @brief 重排元素\n\t* @details 将曲线元素重新排序以缩小元素首尾相连的间隙\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT double ReorderForSmallGaps();\n\n\t/**\n\t* @brief 链接元素\n\t* @details 将曲线的元素首尾相连\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AssembleChains();\n\n\t/**\n\t* @brief 区域相并\n\t* @details 返回给定两个区域的并\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaUnion(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相减\n\t* @details 返回给定两个区域的减\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaDifference(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相交\n\t* @details 返回给定两个区域的交\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaIntersection(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 循环索引\n\t* @details 返回给定索引值关于集合大小的模\n\t* \n\t* @param int index\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT size_t CyclicIndex(int index) const;\n\n\t/**\n\t* @brief 循环获取值\n\t* @details 根据给定索引的循环索引获取元素\n\t* \n\t* @param ptrdiff_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr GetCyclic(ptrdiff_t index) const;\n\n    /**\n    * @brief 获取索引\n    * @details 返回给定曲线元素的详细细节所对应的元素索引\n    * \n    * @param CurveDescInfo const & location\n    * @return size_t\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT size_t CurveDescInfoIndex(CurveDescInfo const& location) const;\n\n\t/**\n\t* @brief 与平面相交\n\t* @details 计算封闭曲线与平面的交叉点,返回以奇偶性规则构造的起止点对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool AppendClosedCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过给定偏移后的深度拷贝.\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AreaOffset(CurveOffsetOptionsCR options) const;\n\n\t/**\n\t* @brief 返回从index0,fraction0到index1,fraction1的曲线段\n\t* \n\t* @param int index0 \n\t* @param double fraction0 \n\t* @param int index1 \n\t* @param double fraction1 \n\t* @param bool allowExtrapolation \n\t* @return ATGEOSET_EXPORT CurveSetPtr \n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/17\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneBetweenDirectedFractions(int index0, double fraction0, int index1, double fraction1, bool allowExtrapolation) const;\n\n\t/**\n\t* @brief 返回输入的曲线的布尔奇运算结果（区域）\n\t*\n\t* @param CurveSetCR regionA\t\t\t\t\t左操作数\n\t* @param CurveSetCR regionB\t\t\t\t\t右操作数\n\t* @param BasicCurvePtrPairVector * newToOld\t（可选）包含新旧曲线的数组指针\n\t* @return ATGEOSET_EXPORT CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/07/22\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaParity(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n};\n\nstruct CurveCurve\n{\nprivate: CurveCurve();\npublic:\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tCurveSetR curveA,\n\t\tCurveSetR curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB,\n\t\tXMatrix4dCP    pWorldToLocal,\n\t\tbool         extend = false\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveR curveA,\n\t\tCurveSetR     curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tCurveSetCR chainA,\n\t\tCurveSetCR chainB\n\t);\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            double &fractionA,\n            XPoint3dR pntA,\n            double &fractionB,\n            XPoint3dR pntB\n            );\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            CurveDescInfoR detailA,\n            CurveDescInfoR detailB\n            );\n};\n\nstruct PathLocationDetail\n{\nprivate:\n\tCurveDescInfo m_curveDetail;\n\tint32_t m_pathIndex;\n\tdouble m_pathDistance;\npublic:\n\n\tATGEOSET_EXPORT PathLocationDetail();\n\n\tATGEOSET_EXPORT PathLocationDetail(PathLocationDetail const &other);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, int pathIndex = -1, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, size_t pathIndex, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(double distance);\n\n\tATGEOSET_EXPORT XPoint3d Point() const;\n\n\tATGEOSET_EXPORT CurveDescInfo GetCurveDescInfo() const;\n\n    ATGEOSET_EXPORT double DistanceFromPathStart() const;\n};\n\nstruct CurveSetWithDistanceIndex : RefCountedBase\n{\nprivate:\n\n\tstruct PathEntry : PathLocationDetail\n\t{\n\t\tdouble             m_projectedDistance;\n\t\tXRange3d           m_range;\n\t\tPathEntry(PathLocationDetail const &pathDetail, double projectedDist, XRange3dCR range)\n\t\t\t: PathLocationDetail(pathDetail),\n\t\t\tm_projectedDistance(projectedDist),\n\t\t\tm_range(range)\n\t\t{\n\t\t}\n\t\tPathEntry(double distance) : PathLocationDetail(distance), m_projectedDistance(distance) {}\n\n\t\tdouble GetDistance(bool projected) const;\n\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistanceXY(PathEntry const &dataA, PathEntry const &dataB);\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistance(PathEntry const &dataA, PathEntry const &dataB);\n\t};\n\n\tCurveSetPtr m_curveVector;\n\txvector<PathEntry> m_locations;\n\tCurveSetPtr m_savedPrimitives;\n\n\tXRotMatrix m_worldToViewRotMatrix;\n\tXRotMatrix m_viewToWorldRotMatrix;\n\tXRotMatrix m_flattenToView;\n\tXMatrix4d m_worldToView;\n\n\texplicit CurveSetWithDistanceIndex(XRotMatrix worldToView);\n\n\tCurveSetWithDistanceIndex();\n\npublic:\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create(XRotMatrix worldToView);\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create();\n\n\tATGEOSET_EXPORT void SetPath(CurveSetPtr &path);\n\n\tATGEOSET_EXPORT bool SearchByDistanceFromPathStart\n\t(\n\t\tdouble targetDist,\n\t\tPathLocationDetail &detail\n\t) const;\n\n    ATGEOSET_EXPORT PathLocationDetail SearchClosestPointBounded\n    (\n    XPoint3dCR spacePoint,\n    bool computeDistAlong\n    ) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file IBasicCurve.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 基本线元类\n* @author SZEWC\n* @since 2022/04/28\n*/\nstruct IBasicCurve : public RefCountedBase\n{\nprivate: virtual void IAmAbstractClass() = 0;\n\npublic:\n\tenum BasicCurveType\n\t{\n\t\tBCURVE_TYPE_Invalid = 0,\n\t\tBCURVE_TYPE_Line = 1,\n\t\tBCURVE_TYPE_LineString = 2,\n\t\tBCURVE_TYPE_Arc = 3,\n\t\tBCURVE_TYPE_BsplineCurve = 4,\n\t\tBCURVE_TYPE_InterpolationCurve = 5,\n\t\tBCURVE_TYPE_AkimaCurve = 6,\n\t\tBCURVE_TYPE_PointString = 7,\n\t\tBCURVE_TYPE_CurveSet = 8,\n\t\tBCURVE_TYPE_Spiral = 9,\n\t\tBCURVE_TYPE_PartialCurve = 10,\n\t\tBCURVE_TYPE_NotClassified = -1,\n\t};\n\n\tATGEOSET_EXPORT int64_t GetTag() const;\n\n\tATGEOSET_EXPORT int GetIntTag() const;\n\n\tATGEOSET_EXPORT void SetTag(int64_t tag);\n\n\tATGEOSET_EXPORT void SetTag(int tag);\n\n\tATGEOSET_EXPORT CurveSetPtr GetChildCurveSetP();\n\npublic:\n\tATGEOSET_EXPORT xvector<XPoint3d> * GetLineStringP();\n\n\tATGEOSET_EXPORT BasicCurveType           GetBasicCurveType() const;\n\n\tATGEOSET_EXPORT bool TryGetLine(XSegment3dR segment) const;\n\n\tATGEOSET_EXPORT bool TryGetArc(XEllipse3dR arc) const;\n\n\tATGEOSET_EXPORT XSegment3dCP                 GetLineCP() const;\n\n\tATGEOSET_EXPORT xvector<XPoint3d> const* GetLineStringCP() const;\n\n\tATGEOSET_EXPORT bool TryGetSegmentInLineString(XSegment3dR segment, size_t startPointIndex) const;\n\n\tATGEOSET_EXPORT XEllipse3dCP                 GetArcCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurveCP             GetBsplineCurveCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr             GetBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr            GetProxyBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT XSpiral2dPlacementCP         GetSpiralPlacementCP() const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLine(XSegment3dCR segment);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(XPoint3dCP points, size_t nPoints);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(xvector<XPoint3d> const &points);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateArc(XEllipse3dCR ellipse);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurveCR curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurvePtr& curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiral(XSpiral2dBaseCR spiral, TransformCR frame,\n\t\tdouble fractionA, double fractionB);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusBearingRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble endRadians,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusLengthRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble length,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT IBasicCurvePtr Clone() const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneComponent(ptrdiff_t componentIndex) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneAsSingleOffsetPrimitiveXY(CurveOffsetOptionsCR options) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XRay3dR ray) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, CurveDescInfo &detail) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2, XVec3dR derivative3) const;\n\n\tATGEOSET_EXPORT bool FractionToFrenetFrame(double f, TransformR frame) const;\n\n\tATGEOSET_EXPORT bool Length(double &length) const;\n\n\tATGEOSET_EXPORT bool Length(XRotMatrixCP worldToLocal, double &length) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\tATGEOSET_EXPORT size_t NumComponent() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetATBsplineCurvePtr(double fraction0 = 0.0, double fraction1 = 1.0) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(XRotMatrixCP worldToView, double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool TrySetStart(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TrySetEnd(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\tATGEOSET_EXPORT void  AppendCurvePlaneIntersections\n\t(\n\t\tXPlane3dByVectorsCR plane,\n\t\tUVBoundarySelect   bounded,\n\t\txvector<CurveAndSolidDescInfo> &intersections\n\t) const;\n\n\tATGEOSET_EXPORT bool AddStrokes(xvector <XPoint3d> &points, IFacetOptionsR options,\n\t\tbool includeStartPoint = true,\n\t\tdouble startFraction = 0.0,\n\t\tdouble endFraction = 1.0\n\t) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, double &fraction, XPoint3dR curvePoint) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneBetweenFractions(double fractionA, double fractionB, bool allowExtrapolation) const;\n\n\tATGEOSET_EXPORT CurveSetCP            GetChildCurveSetCP() const;\n\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(double startFraction, double endFraction, double &signedDist) const;\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(XRotMatrixCP worldToLocal, double startFraction, double endFraction, double &signedDist) const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateRectangle(double x0, double y0, double x1, double y1, double z, int areaSignPref = 0);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateChildCurveSet(CurveSetPtr source);\n\n\tATGEOSET_EXPORT bool  TryGetPartialCurveData(double &fractionA, double &fractionB, IBasicCurvePtr &parentCurve, int64_t &tag) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file CreateGeometryExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};", "output": "\nvoid CreateGeometryExamples::CreateATBsplineCurves_FromThroughPts()\n{\n\t//创建B样条曲线\n\tATBsplineCurvePtr bslpineCurve = GetBsplineCurves_FromThroughPts(true);\n\n\tif (bslpineCurve.IsValid())\n\t{\n\t\tCurveSetPtr curve = CurveSet::Create(IBasicCurve::CreateBsplineCurve(bslpineCurve));\n\t\tAddGeometryToScene(curve);\n\t}\n}\n\n#pragma endregion\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};. You need to implement the function GetComplexGeo in the interface. Here are some apis that you can use and remember:\n code of file CurveSet.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 线串类\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct CurveSet : RefCountedBase, xvector<IBasicCurvePtr>\n{\n\n\tenum BoundaryType\n\t{\n\n\t\tBOUNDARY_TYPE_None = 0,\n\n\t\tBOUNDARY_TYPE_Open = 1,\n\n\t\tBOUNDARY_TYPE_Outer = 2,\n\n\t\tBOUNDARY_TYPE_Inner = 3,\n\n\t\tBOUNDARY_TYPE_ParityRegion = 4,\n\n\t\tBOUNDARY_TYPE_UnionRegion = 5,\n\t};\n\n\tenum InOutClassification\n\t{\n\t\tINOUT_Unknown = 0,\n\t\tINOUT_In = 1,\n\t\tINOUT_Out = 2,\n\t\tINOUT_On = 3\n\t};\n\nprotected:\n\tBoundaryType    m_boundaryType;\n\npublic:\n\t/**\n\t* @brief 设定边界\n\t* @details 设定曲线的边界类型\n\t* \n\t* @param BoundaryType BoundaryType\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void SetBoundaryType(BoundaryType BoundaryType);\n\n\t/**\n\t* @brief 获取叶节点\n\t* @details 通过只计算叶节点的索引深度搜索以获取目标叶节点\n\t* \n\t* @param size_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr FindIndexedLeaf(size_t index) const;\n\n\t/**\n\t* @brief 获取索引值\n\t* @details 深度搜索以获取给定叶节点的索引值\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @param size_t & index\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool LeafToIndex(IBasicCurveCP primitive, size_t &index) const;\n\n\t/**\n\t* @brief 获取叶节点个数\n\t* @details 获取曲线的叶节点个数\n\t* \n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesBelow() const;\n\n\texplicit CurveSet(BoundaryType boundaryType) { m_boundaryType = boundaryType; }\n\n\t/**\n\t* @brief 是否单元素曲线\n\t* @details 查询曲线是否只有一个基本元素\n\t* \n\t* @return IBasicCurve\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurve::BasicCurveType HasSingleBasicCurve() const;\n\n\t/**\n\t* @brief 获取边界类型\n\t* @details 获取曲线的边界类型\n\t* \n\t* @return BoundaryType\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT BoundaryType GetBoundaryType() const;\n\n\t/**\n\t* @brief 查询是否开\n\t* @details 查询是否开路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsOpenPath() const;\n\n\t/**\n\t* @brief 查询是否闭\n\t* @details 查询是否闭路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsClosedPath() const;\n\n\t/**\n\t* @brief 查询实际开闭\n\t* @details 查询是否名义上是开路径但起点和终点连接\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsPhysicallyClosedPath() const;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个带有给定边界类型没有成员的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个具有单个基本元素和给定边界类型的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @param IBasicCurvePtr primitive\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType, IBasicCurvePtr primitive);\n\n\t/**\n\t* @brief 拷贝\n\t* @details 返回一个深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr Clone() const;\n\n\t/**\n\t* @brief 倒角拷贝\n\t* @details 返回一个深度拷贝,在连续曲线之间插入圆角\n\t* \n\t* @param double radius\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithFillets(double radius) const;\n\n\t/**\n\t* @brief 闭合拷贝\n\t* @details 返回一个深度拷贝,闭合终端点的间隙\n\t* \n\t* @param CurveGapOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithGapsClosed(CurveGapOptionsCR options) const;\n\n\t/**\n\t* @brief 添加元素\n\t* @details 递归遍历source, 将所有叶节点添加到this, 返回添加的数量\n\t* \n\t* @param CurveSetCR source\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t AddPrimitives(CurveSetCR source);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 添加单个基本曲线\n\t* \n\t* @param IBasicCurvePtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(IBasicCurvePtr child);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 将chile的所有元素作为曲线成员添加\n\t* \n\t* @param CurveSetPtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(CurveSetPtr child);\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过XY方向的偏移后的深度拷贝\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneOffsetCurvesXY(CurveOffsetOptionsCR options);\n\n\t/**\n\t* @brief 获取叶节点数量\n\t* @details 计算指定类型的叶节点数量\n\t* \n\t* @param IBasicCurve::BasicCurveType targetType\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesOfType(IBasicCurve::BasicCurveType targetType) const;\n\n\t/**\n\t* @brief 用区域分割曲线\n\t* @details 用指定区域分割曲线,分别返回区域内、外和区域上的曲线\n\t* \n\t* @param CurveSetCR region\n\t* @param CurveSetP insideCollector\n\t* @param CurveSetP outsideCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByRegion(CurveSetCR region, CurveSetP insideCollector, CurveSetP outsideCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 用平面分割曲线\n\t* @details 用指定平面分割曲线,分别返回平面上方、下方和平面内的曲线\n\t* \n\t* @param XPlane3dCR plane\n\t* @param CurveSetP belowCollector\n\t* @param CurveSetP aboveCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByPlane(XPlane3dCR plane, CurveSetP belowCollector, CurveSetP aboveCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 拆分拷贝\n\t* @details 返回一个深度拷贝,但所有的多线段被拆分成单条线段\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithExplodedLinestrings() const;\n\n\t/**\n\t* @brief 获取质心\n\t* @details 返回包含曲线的质心(不考虑孤立点)\n\t* \n\t* @param double & length\n\t* @param XPoint3dR centroid\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  WireCentroid(double &length, XPoint3dR centroid) const;\n\n\t/**\n\t* @brief 获取质心、法向量和面积\n\t* @details 返回质心、法向量和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param XVec3dR normal\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CentroidNormalArea(XPoint3dR centroid, XVec3dR normal, double &area) const;\n\n\t/**\n\t* @brief 获取质心和面积\n\t* @details 返回XY平面方向上的质心和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  CentroidAreaXY(XPoint3dR centroid, double &area) const;\n\n\t/**\n\t* @brief 投影范围\n\t* @details 当投影到射线的时候,返回射线参数的范围\n\t* \n\t* @param XRay3dCR ray\n\t* @return XRange1d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT XRange1d ProjectedParameterRange(XRay3dCR ray) const;\n\n    /**\n    * @brief 局部坐标拷贝\n    * @details 返回曲线的深度复制并转换为与曲线相关联的局部坐标系统。\n    * \n    * @param LocalCoordinateSelect frameType\n    * @param TransformR localToWorld\n    * @param TransformR worldToLocal\n    * @param XRange3dR localRange\n    * @return CurveSetPtr\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT CurveSetPtr CloneInLocalCoordinates\n    (\n    LocalCoordinateSelect frameType,\n    TransformR localToWorld,\n    TransformR worldToLocal,\n    XRange3dR localRange\n    ) const;\n\n\t/**\n    * @brief 获取有坐标系的元素\n    * @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame) const;\n\n\t/**\n\t* @brief 获取有坐标系的元素\n\t* @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @param int searchPreference\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame, int srchPref) const;\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param xvector<XPoint3d> const & points\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(xvector<XPoint3d> const&points,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint3dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint3dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建多边形\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint2dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint2dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建矩形\n\t* @details 根据 XY 坐标创建矩形\n\t* \n\t* @param double x0\n\t* @param double y0\n\t* @param double x1\n\t* @param double y1\n\t* @param double z\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateRectangle(double x0, double y0, double x1, double y1, double z,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由给定线段创建边界类型为 BOUNDARY_TYPE_None 的曲线\n\t* \n\t* @param xvector<XSegment3d> const & segments\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(xvector<XSegment3d> const &segs);\n\n\t/**\n\t* @brief 创建圆盘\n\t* @details 为一个完整的椭圆(圆)盘创建一个曲线向量结构\n\t* \n\t* @param XEllipse3dCR arc\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateDisk(XEllipse3dCR arc, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer, bool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个仅有单一元素的曲线结构\n\t* \n\t* @param IBasicCurvePtr child\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(IBasicCurvePtr child, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open);\n\n\t/**\n\t* @brief B样条拷贝\n\t* @details 返回一个深度拷贝,作为B样条曲线\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneAsBsplines() const;\n\n\t/**\n\t* @brief 添加边缘点\n\t* @details 为所有的子节点添加边缘点\n\t* \n\t* @param xvector <XPoint3d> & points\n\t* @param IFacetOptionsR options\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AddStrokePoints(xvector <XPoint3d> &points, IFacetOptionsR options) const;\n\n    /**\n\t* @brief 添加面点\n\t* @details 沿着曲线计算指定距离的点\n\t* \n\t* @param xvector<double> const & distances\n\t* @param xvector<CurveDescInfo> & locations\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool AddSpacedPoints(xvector<double> const &distances, xvector<CurveDescInfo> &locations) const;\n\n\t/**\n\t* @brief 添加边缘\n\t* @details 在结构中添加所有边缘\n\t* \n\t* @param xvector <xvector<xvector<XPoint3d>>> & regionsPoints\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CollectLinearGeometry(xvector <xvector<xvector<XPoint3d>> > &regionsPoints) const;\n\n\t/**\n\t* @brief 获取B样条曲线\n\t* @details 将一个表示开放或闭合路径作为单个B样条曲线\n\t* \n\t* @return ATBsplineCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetBsplineCurve() const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n    /**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索最接近曲线的点。如果曲线是一个区域类型,同时要在该区域的内部寻找投影\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XPoint3dR curveOrRegionPoint\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification ClosestCurveOrRegionPoint(XPoint3dCR spacePoint, XPoint3dR curveOrRegionPoint) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点和终点\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点终点和他们的正切值\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @param XVec3dR unitTangentA\n\t* @param XVec3dR unitTangentB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\t/**\n\t* @brief 获取起点\n\t* @details 返回曲线的起点\n\t* \n\t* @param XPoint3dR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线总长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length() const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线经过变换后的总长度\n\t* \n\t* @param XRotMatrixCP worldToLocal\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length(XRotMatrixCP worldToLocal) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线的xyz范围\n\t* \n\t* @param XRange3dR range\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线经过变换后的范围\n\t* \n\t* @param XRange3dR range\n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\t/**\n\t* @brief 查询索引\n\t* @details 返回指定元素的索引\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t FindIndexOfPrimitive(IBasicCurveCP primitive) const;\n\n\t/**\n\t* @brief 复制曲线指定范围的曲线\n\t* @details 复制曲线指定索引和比例参数范围内的部分\n\t* \n\t* @param int index0\n\t* @param double fraction0\n\t* @param int index1\n\t* @param double fraction1\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n    ATGEOSET_EXPORT CurveSetPtr CloneBetweenCyclicIndexedFractions(int index0, double fraction0, int index1, double fraction1) const;\n\n\t/**\n\t* @brief 反转拷贝\n\t* @details 返回一个所有元素都被反转的深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneReversed() const;\n\n\t/**\n\t* @brief 查询是否包含非线性元素\n\t* @details 如果曲线有一个不非线性元素,则返回true。\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ContainsNonLinearPrimitive() const;\n\n\t/**\n\t* @brief 计算交点\n\t* @details 计算曲线与给定平面的交点\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 平面选中\n\t* @details 计算封闭曲线与平面的交叉点,并以奇偶性规则为设为起始对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param double tolerance\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr PlaneSection(XPlane3dCR plane, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 空间点位置情况\n\t* @details 当以XY平面视角看,测试给定点在曲线内、曲线上还是曲线外\n\t* \n\t* @param XPoint3dCR xyz\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification PointInOnOutXY(XPoint3dCR xyz) const;\n\n\t/**\n\t* @brief 射线击中情况\n\t* @details 测试射线击中曲线在区域内、区域上还是区域外\n\t* \n\t* @param XRay3dCR ray\n\t* @param SolidDescInfoR hitDetail\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification RayPierceInOnOut\n\t(\n\t\tXRay3dCR ray,\n\t\tSolidDescInfoR hitDetail\n\t) const;\n\n\t/**\n\t* @brief 原地变换\n\t* @details 应用给定变换并修改曲线\n\t* \n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\t/**\n\t* @brief 原地反转\n\t* @details 将所有元素进行反转\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串内的单个点被消除,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串相邻的空间点被消除（可选）,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @param bool doSimplifyLinestrings\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives(bool doSimplifyLinestrings);\n\n\t/**\n\t* @brief 原地修改以简化线串\n\t* @details 消除线串相邻的空间点\n\t* \n\t* @param double distanceTol\n\t* @param bool eliminateOverdraw\n\t* @param bool wrap\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void SimplifyLinestrings(double distTol, bool eliminateOverdraw, bool wrap);\n\n\t/**\n\t* @brief 重排元素\n\t* @details 将曲线元素重新排序以缩小元素首尾相连的间隙\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT double ReorderForSmallGaps();\n\n\t/**\n\t* @brief 链接元素\n\t* @details 将曲线的元素首尾相连\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AssembleChains();\n\n\t/**\n\t* @brief 区域相并\n\t* @details 返回给定两个区域的并\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaUnion(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相减\n\t* @details 返回给定两个区域的减\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaDifference(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相交\n\t* @details 返回给定两个区域的交\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaIntersection(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 循环索引\n\t* @details 返回给定索引值关于集合大小的模\n\t* \n\t* @param int index\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT size_t CyclicIndex(int index) const;\n\n\t/**\n\t* @brief 循环获取值\n\t* @details 根据给定索引的循环索引获取元素\n\t* \n\t* @param ptrdiff_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr GetCyclic(ptrdiff_t index) const;\n\n    /**\n    * @brief 获取索引\n    * @details 返回给定曲线元素的详细细节所对应的元素索引\n    * \n    * @param CurveDescInfo const & location\n    * @return size_t\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT size_t CurveDescInfoIndex(CurveDescInfo const& location) const;\n\n\t/**\n\t* @brief 与平面相交\n\t* @details 计算封闭曲线与平面的交叉点,返回以奇偶性规则构造的起止点对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool AppendClosedCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过给定偏移后的深度拷贝.\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AreaOffset(CurveOffsetOptionsCR options) const;\n\n\t/**\n\t* @brief 返回从index0,fraction0到index1,fraction1的曲线段\n\t* \n\t* @param int index0 \n\t* @param double fraction0 \n\t* @param int index1 \n\t* @param double fraction1 \n\t* @param bool allowExtrapolation \n\t* @return ATGEOSET_EXPORT CurveSetPtr \n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/17\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneBetweenDirectedFractions(int index0, double fraction0, int index1, double fraction1, bool allowExtrapolation) const;\n\n\t/**\n\t* @brief 返回输入的曲线的布尔奇运算结果（区域）\n\t*\n\t* @param CurveSetCR regionA\t\t\t\t\t左操作数\n\t* @param CurveSetCR regionB\t\t\t\t\t右操作数\n\t* @param BasicCurvePtrPairVector * newToOld\t（可选）包含新旧曲线的数组指针\n\t* @return ATGEOSET_EXPORT CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/07/22\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaParity(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n};\n\nstruct CurveCurve\n{\nprivate: CurveCurve();\npublic:\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tCurveSetR curveA,\n\t\tCurveSetR curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB,\n\t\tXMatrix4dCP    pWorldToLocal,\n\t\tbool         extend = false\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveR curveA,\n\t\tCurveSetR     curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tCurveSetCR chainA,\n\t\tCurveSetCR chainB\n\t);\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            double &fractionA,\n            XPoint3dR pntA,\n            double &fractionB,\n            XPoint3dR pntB\n            );\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            CurveDescInfoR detailA,\n            CurveDescInfoR detailB\n            );\n};\n\nstruct PathLocationDetail\n{\nprivate:\n\tCurveDescInfo m_curveDetail;\n\tint32_t m_pathIndex;\n\tdouble m_pathDistance;\npublic:\n\n\tATGEOSET_EXPORT PathLocationDetail();\n\n\tATGEOSET_EXPORT PathLocationDetail(PathLocationDetail const &other);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, int pathIndex = -1, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, size_t pathIndex, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(double distance);\n\n\tATGEOSET_EXPORT XPoint3d Point() const;\n\n\tATGEOSET_EXPORT CurveDescInfo GetCurveDescInfo() const;\n\n    ATGEOSET_EXPORT double DistanceFromPathStart() const;\n};\n\nstruct CurveSetWithDistanceIndex : RefCountedBase\n{\nprivate:\n\n\tstruct PathEntry : PathLocationDetail\n\t{\n\t\tdouble             m_projectedDistance;\n\t\tXRange3d           m_range;\n\t\tPathEntry(PathLocationDetail const &pathDetail, double projectedDist, XRange3dCR range)\n\t\t\t: PathLocationDetail(pathDetail),\n\t\t\tm_projectedDistance(projectedDist),\n\t\t\tm_range(range)\n\t\t{\n\t\t}\n\t\tPathEntry(double distance) : PathLocationDetail(distance), m_projectedDistance(distance) {}\n\n\t\tdouble GetDistance(bool projected) const;\n\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistanceXY(PathEntry const &dataA, PathEntry const &dataB);\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistance(PathEntry const &dataA, PathEntry const &dataB);\n\t};\n\n\tCurveSetPtr m_curveVector;\n\txvector<PathEntry> m_locations;\n\tCurveSetPtr m_savedPrimitives;\n\n\tXRotMatrix m_worldToViewRotMatrix;\n\tXRotMatrix m_viewToWorldRotMatrix;\n\tXRotMatrix m_flattenToView;\n\tXMatrix4d m_worldToView;\n\n\texplicit CurveSetWithDistanceIndex(XRotMatrix worldToView);\n\n\tCurveSetWithDistanceIndex();\n\npublic:\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create(XRotMatrix worldToView);\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create();\n\n\tATGEOSET_EXPORT void SetPath(CurveSetPtr &path);\n\n\tATGEOSET_EXPORT bool SearchByDistanceFromPathStart\n\t(\n\t\tdouble targetDist,\n\t\tPathLocationDetail &detail\n\t) const;\n\n    ATGEOSET_EXPORT PathLocationDetail SearchClosestPointBounded\n    (\n    XPoint3dCR spacePoint,\n    bool computeDistAlong\n    ) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file IBasicCurve.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 基本线元类\n* @author SZEWC\n* @since 2022/04/28\n*/\nstruct IBasicCurve : public RefCountedBase\n{\nprivate: virtual void IAmAbstractClass() = 0;\n\npublic:\n\tenum BasicCurveType\n\t{\n\t\tBCURVE_TYPE_Invalid = 0,\n\t\tBCURVE_TYPE_Line = 1,\n\t\tBCURVE_TYPE_LineString = 2,\n\t\tBCURVE_TYPE_Arc = 3,\n\t\tBCURVE_TYPE_BsplineCurve = 4,\n\t\tBCURVE_TYPE_InterpolationCurve = 5,\n\t\tBCURVE_TYPE_AkimaCurve = 6,\n\t\tBCURVE_TYPE_PointString = 7,\n\t\tBCURVE_TYPE_CurveSet = 8,\n\t\tBCURVE_TYPE_Spiral = 9,\n\t\tBCURVE_TYPE_PartialCurve = 10,\n\t\tBCURVE_TYPE_NotClassified = -1,\n\t};\n\n\tATGEOSET_EXPORT int64_t GetTag() const;\n\n\tATGEOSET_EXPORT int GetIntTag() const;\n\n\tATGEOSET_EXPORT void SetTag(int64_t tag);\n\n\tATGEOSET_EXPORT void SetTag(int tag);\n\n\tATGEOSET_EXPORT CurveSetPtr GetChildCurveSetP();\n\npublic:\n\tATGEOSET_EXPORT xvector<XPoint3d> * GetLineStringP();\n\n\tATGEOSET_EXPORT BasicCurveType           GetBasicCurveType() const;\n\n\tATGEOSET_EXPORT bool TryGetLine(XSegment3dR segment) const;\n\n\tATGEOSET_EXPORT bool TryGetArc(XEllipse3dR arc) const;\n\n\tATGEOSET_EXPORT XSegment3dCP                 GetLineCP() const;\n\n\tATGEOSET_EXPORT xvector<XPoint3d> const* GetLineStringCP() const;\n\n\tATGEOSET_EXPORT bool TryGetSegmentInLineString(XSegment3dR segment, size_t startPointIndex) const;\n\n\tATGEOSET_EXPORT XEllipse3dCP                 GetArcCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurveCP             GetBsplineCurveCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr             GetBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr            GetProxyBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT XSpiral2dPlacementCP         GetSpiralPlacementCP() const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLine(XSegment3dCR segment);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(XPoint3dCP points, size_t nPoints);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(xvector<XPoint3d> const &points);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateArc(XEllipse3dCR ellipse);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurveCR curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurvePtr& curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiral(XSpiral2dBaseCR spiral, TransformCR frame,\n\t\tdouble fractionA, double fractionB);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusBearingRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble endRadians,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusLengthRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble length,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT IBasicCurvePtr Clone() const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneComponent(ptrdiff_t componentIndex) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneAsSingleOffsetPrimitiveXY(CurveOffsetOptionsCR options) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XRay3dR ray) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, CurveDescInfo &detail) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2, XVec3dR derivative3) const;\n\n\tATGEOSET_EXPORT bool FractionToFrenetFrame(double f, TransformR frame) const;\n\n\tATGEOSET_EXPORT bool Length(double &length) const;\n\n\tATGEOSET_EXPORT bool Length(XRotMatrixCP worldToLocal, double &length) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\tATGEOSET_EXPORT size_t NumComponent() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetATBsplineCurvePtr(double fraction0 = 0.0, double fraction1 = 1.0) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(XRotMatrixCP worldToView, double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool TrySetStart(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TrySetEnd(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\tATGEOSET_EXPORT void  AppendCurvePlaneIntersections\n\t(\n\t\tXPlane3dByVectorsCR plane,\n\t\tUVBoundarySelect   bounded,\n\t\txvector<CurveAndSolidDescInfo> &intersections\n\t) const;\n\n\tATGEOSET_EXPORT bool AddStrokes(xvector <XPoint3d> &points, IFacetOptionsR options,\n\t\tbool includeStartPoint = true,\n\t\tdouble startFraction = 0.0,\n\t\tdouble endFraction = 1.0\n\t) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, double &fraction, XPoint3dR curvePoint) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneBetweenFractions(double fractionA, double fractionB, bool allowExtrapolation) const;\n\n\tATGEOSET_EXPORT CurveSetCP            GetChildCurveSetCP() const;\n\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(double startFraction, double endFraction, double &signedDist) const;\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(XRotMatrixCP worldToLocal, double startFraction, double endFraction, double &signedDist) const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateRectangle(double x0, double y0, double x1, double y1, double z, int areaSignPref = 0);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateChildCurveSet(CurveSetPtr source);\n\n\tATGEOSET_EXPORT bool  TryGetPartialCurveData(double &fractionA, double &fractionB, IBasicCurvePtr &parentCurve, int64_t &tag) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XEllipse3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 椭圆弧\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct ATGEOSET_EXPORT XEllipse3d\n{\n\tXPoint3d center;\n\tXVec3d   vector0;\n\tXVec3d   vector90;\n\tdouble start;\n\tdouble sweep;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 返回由已有椭圆的起始和终止比例定义的椭圆弧\n\t* \n\t* @param XEllipse3dCR parent\n\t* @param double startFraction\n\t* @param double endFraction\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromFractionInterval\n\t(\n\t\tXEllipse3dCR parent,\n\t\tdouble startFraction,\n\t\tdouble endFraction\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 根据椭圆的中心点、角度为0度和90度的点,以及扫掠角度创建一个椭圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point90\n\t* @param double theta0\n\t* @param double sweep\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromPoints(XPoint3dCR center, XPoint3dCR pnt0, XPoint3dCR pnt90, double theta0, double sweep);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由起始点,起始切线,半径,扫掠角度和面法向量创建椭圆弧\n\t* \n\t* @param XPoint3dCR pointA\n\t* @param XVec3dCR tangent\n\t* @param XVec3dCR planeNormal\n\t* @param double radius\n\t* @param double sweepRadians\n\t* @return ValidatedXEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic ValidatedXEllipse3d FromStartTangentNormalRadiusSweep(\n\n\t\tXPoint3dCR pntA,\n\t\tXVec3dCR tangent,\n\t\tXVec3dCR planeNormal,\n\t\tdouble radius,\n\t\tdouble sweepRadians\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由弧上的点创建椭圆弧\n\t* \n\t* @param XPoint3dCR start\n\t* @param XPoint3dCR middle\n\t* @param XPoint3dCR end\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromPointsOnArc(XPoint3dCR start, XPoint3dCR middle, XPoint3dCR end);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、起始点和终止点的切线创建椭圆弧（扫掠角取较小的一个）\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endTarget\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromArcCenterStartEnd(XPoint3dCR center, XPoint3dCR startPoint, XPoint3dCR endTarget);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、半径和面法向量创建完整的圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param XVec3dCR normal\n\t* @param double radius\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromCenterNormalRadius(XPoint3dCR center, XVec3dCR normal, double radius);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、半径创建XY平面上完整的圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param double radius\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromCenterRadiusXY(XPoint3dCR center, double radius);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 返回给定椭圆弧以反方向扫掠得到的椭圆弧\n\t* \n\t* @param XEllipse3dCR source\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromReversed(XEllipse3dCR source);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由给定点和扫掠角初始化数据\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point90\n\t* @param double theta0\n\t* @param double sweep\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid InitFromPoints\n\t(\n\t\tXPoint3dCR      center,\n\t\tXPoint3dCR      pnt0,\n\t\tXPoint3dCR      pnt90,\n\t\tdouble          theta0,\n\t\tdouble          sweep\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由椭圆弧上的点初始化数据\n\t* \n\t* @param XPoint3dCR start\n\t* @param XPoint3dCR middle\n\t* @param XPoint3dCR end\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool InitFromPointsOnArc\n\t(\n\t\tXPoint3dCR      start,\n\t\tXPoint3dCR      middle,\n\t\tXPoint3dCR      end\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由中心点、起始点和终止点的切线初始化数据（扫掠角取较小的一个）\n\t* \n\t* @param XPoint3dCR centerIN\n\t* @param XPoint3dCR startIN\n\t* @param XPoint3dCR end\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool InitFromArcCenterStartEnd\n\t(\n\t\tXPoint3dCR      centerIN,\n\t\tXPoint3dCR      startIN,\n\t\tXPoint3dCR      end\n\t);\n\n\t/**\n\t* @brief 设置起始点\n\t* @details 修改椭圆弧的起点和终点\n\t* \n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endPoint\n\t* @param bool ccw\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool SetStartEnd\n\t(\n\t\tXPoint3dCR      startPoint,\n\t\tXPoint3dCR      endPoint,\n\t\tbool            ccw\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由中心点、半径和面法向量初始化数据\n\t* \n\t* @param XPoint3dCR centerIN\n\t* @param XVec3dCR normal\n\t* @param double radius\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid InitFromCenterNormalRadius\n\t(\n\t\tXPoint3dCR      centerIN,\n\t\tXVec3dCR      normal,\n\t\tdouble          radius\n\t);\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点\n\t* \n\t* @param XPoint3dR point\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       point,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 角到点\n\t* @details 返回椭圆弧给定参数角对应的空间点\n\t* \n\t* @param double theta\n\t* @return XPoint3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tXPoint3d RadiansToPoint(double theta) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 返回椭圆弧给定参数坐标对应的空间点\n\t* \n\t* @param XPoint3dR point\n\t* @param double xx\n\t* @param double yy\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       point,\n\t\tdouble          xx,\n\t\tdouble          yy\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点\n\t* \n\t* @param XPoint4dR point\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint4dR       point,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 获取椭圆弧的起点和终点\n\t* \n\t* @param XPoint3dR startPoint\n\t* @param XPoint3dR endPoint\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid EvaluateEndPoints\n\t(\n\t\tXPoint3dR       startPoint,\n\t\tXPoint3dR       endPoint\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点以及在参数值处的导数\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param XVec3dR dX\n\t* @param XVec3dR ddX\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tXVec3dR       dX,\n\t\tXVec3dR       ddX,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算给定的参数角比例对应的空间点\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param double fraction\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid FractionParameterToPoint\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tdouble          fraction\n\t) const;\n\n\t/**\n\t* @brief 比例到点\n\t* @details 返回给定的参数角比例对应的空间点\n\t* \n\t* @param double fraction\n\t* @return XPoint3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tXPoint3d FractionToPoint(double fraction) const;\n\n\t/**\n\t* @brief 比例到导数\n\t* @details 返回给定的参数角比例对应的空间点及在该点处的导数\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param XVec3dR dX\n\t* @param XVec3dR ddX\n\t* @param double fraction\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid FractionParameterToDerivatives\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tXVec3dR       dX,\n\t\tXVec3dR       ddX,\n\t\tdouble          fraction\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算给定的参数角比例对应的空间点及在该点处的导数,以数组形式返回\n\t* \n\t* @param XPoint3dP point3dX\n\t* @param int numDerivative\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dP       pnt3dX,\n\t\tint             numDerivative,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 点到角\n\t* @details 计算椭圆弧上的点对应的参数角\n\t* \n\t* @param XPoint3dCR point\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble PointToAngle(XPoint3dCR point) const;\n\n\t/**\n\t* @brief 投影点\n\t* @details 将给定点投影到椭圆弧所在的平面上\n\t* \n\t* @param XPoint3dR xYZNear\n\t* @param double & coff0\n\t* @param double & coff90\n\t* @param XPoint3dCR xYZ\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool ProjectPointToPlane\n\t(\n\t\tXPoint3dR       xYZNear,\n\t\tdouble          &coff0,\n\t\tdouble          &coff90,\n\t\tXPoint3dCR      xYZ\n\t) const;\n\n\t/**\n\t* @brief 角到比例\n\t* @details 计算给定参数角所对应椭圆弧上的比例\n\t* \n\t* @param double angle\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble AngleToFraction(double angle) const;\n\n\t/**\n\t* @brief 弧长\n\t* @details 返回椭圆弧的长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble ArcLength() const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 计算椭圆弧空间点的范围\n\t* \n\t* @param XRange3dR range\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief XY方向上与直线相交\n\t* @details 计算XY方向上与直线相交的交点,椭圆弧和直线都视为无界的\n\t* \n\t* @param XPoint3dP cartesianPoints\n\t* @param double * pLineParams\n\t* @param XPoint3dP ellipseCoffs\n\t* @param double * pEllipseAngle\n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endPoint\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectXYLine\n\t(\n\t\tXPoint3dP       cartesianPoints,\n\t\tdouble          *pLineParams,\n\t\tXPoint3dP       ellipseCoffs,\n\t\tdouble          *pEllipseAngle,\n\t\tXPoint3dCR      startPoint,\n\t\tXPoint3dCR      endPoint\n\t) const;\n\n\t/**\n\t* @brief 是否完整\n\t* @details 查询椭圆弧是否完整\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCircular() const;\n\n\t/**\n\t* @brief 是否完整\n\t* @details 查询椭圆弧是否完整\n\t* \n\t* @param double & radius\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCircular(double &radius) const;\n\n\t/**\n\t* @brief 是否逆时针\n\t* @details 查询椭圆弧在XY平面内的投影是否逆时针扫掠\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCCWSweepXY() const;\n\n\t/**\n\t* @brief 与线段相交\n\t* @details 计算与给定椭圆弧相交的交点,椭圆弧和线段都视为无界的\n\t* \n\t* @param XPoint3dP pointArray\n\t* @param XPoint3dP ellipseParams\n\t* @param double * pLineParams\n\t* @param XSegment3dCR segment\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectSweptXSegment3d\n\t(\n\t\tXPoint3dP       pntArray,\n\t\tXPoint3dP       ellipseParams,\n\t\tdouble          *pLineParams,\n\t\tXSegment3dCR    segment\n\t) const;\n\n\t/**\n\t* @brief 与线段相交\n\t* @details 计算与给定线段相交的交点,椭圆弧和线段都视为有界的\n\t* \n\t* @param XPoint3dP pointArray\n\t* @param XPoint3dP ellipseParams\n\t* @param double * pLineParams\n\t* @param XSegment3dCR segment\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectSweptXSegment3dBounded\n\t(\n\t\tXPoint3dP       pntArray,\n\t\tXPoint3dP       ellipseParams,\n\t\tdouble          *pLineParams,\n\t\tXSegment3dCR    segment\n\t) const;\n\n\t/**\n\t* @brief 转换为BR类型3D元素\n\t* @details 将椭圆弧转换为BR类型的3D元素\n\t* \n\t* @param XPoint3dR centerOUT\n\t* @param double * pQuatWXYZ\n\t* @param XVec3dR directionX\n\t* @param XVec3dR directionY\n\t* @param double & rx\n\t* @param double & ry\n\t* @param double & startAngle\n\t* @param double & sweepAngle\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetATFields3d\n\t(\n\t\tXPoint3dR       centerOUT,\n\t\tdouble *        pQuatWXYZ,\n\t\tXVec3dR         directionX,\n\t\tXVec3dR         directionY,\n\t\tdouble          &rx,\n\t\tdouble          &ry,\n\t\tdouble          &startAngle,\n\t\tdouble          &sweepAngle\n\t) const;\n\n\t/**\n\t* @brief 设置扫掠角\n\t* @details 设置椭圆弧的扫掠角\n\t* \n\t* @param double startAngle\n\t* @param double sweepIN\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid SetSweep\n\t(\n\t\tdouble          startAngle,\n\t\tdouble          sweepIN\n\t);\n\n\t/**\n    * @brief 获取扫掠角\n    * @details 获取椭圆弧的扫掠角\n\t* \n\t* @param double & startAngle\n\t* @param double & sweepAngle\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetSweep\n\t(\n\t\tdouble          &startAngle,\n\t\tdouble          &sweepAngle\n\t) const;\n\n\t/**\n\t* @brief 补全扫掠角\n\t* @details 根据当前的角度范围补全扫掠角\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid ComplementSweep();\n\n\t/**\n    * @brief 与弧相交\n    * @details 计算与给定椭圆弧相交的交点,椭圆弧都视为有界的\n\t* \n\t* @param XPoint3dP cartesianPoints\n\t* @param XPoint3dP ellipse0Coffs\n\t* @param double * pEllipse0Angle\n\t* @param XPoint3dP ellipse1Coffs\n\t* @param double * pEllipse1Angle\n\t* @param XEllipse3dCR ellipse1\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectXYXEllipse3dBounded\n\t(\n\t\tXPoint3dP       cartesianPoints,\n\t\tXPoint3dP       ellipse0Coffs,\n\t\tdouble          *pEllipse0Angle,\n\t\tXPoint3dP       ellipse1Coffs,\n\t\tdouble          *pEllipse1Angle,\n\t\tXEllipse3dCR    ellipse1\n\t) const;\n\n\t/**\n\t* @brief 比例到角\n\t* @details 计算给定比例参数对应的参数角\n\t* \n\t* @param double fraction\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble FractionToAngle(double fraction) const;\n\n\t/**\n\t* @brief 获取最近点\n\t* @details 获取有界椭圆弧在XY方向上离给定空间点最近的点\n\t* \n\t* @param double & minAngle\n\t* @param double & minDistanceSquared\n\t* @param XPoint3dR minPoint\n\t* @param XPoint3dCR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool ClosestPointXYBounded\n\t(\n\t\tdouble          &minAngle,\n\t\tdouble          &minDistSquared,\n\t\tXPoint3dR       minPoint,\n\t\tXPoint3dCR      point\n\t) const;\n\n\t/**\n\t* @brief 完全扫掠\n\t* @details 将椭圆弧以现有的方向扫掠完整的360°\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid MakeFullSweep();\n\n    /**\n    * @brief 获取最近点\n    * @details 在应用变换矩阵（可选）后,计算椭圆弧在XY方向上离给定点最近的点（投影或端点）\n    * \n    * @param XPoint3dR closePoint\n    * @param double & closeParam\n    * @param double & distanceXY\n    * @param XPoint3dCR spacePoint\n    * @param XMatrix4dCP worldToLocal\n    * @return bool\n    *\n    * @author SZEWEC\n    * @since 2022/04/22\n    */\n    bool ClosestPointBoundedXY\n    (\n    XPoint3dR   closePoint,\n    double&     closeParam,\n    double&     distXY,\n    XPoint3dCR  spacePoint,\n    XMatrix4dCP worldToLocal\n    ) const;\n\n    /**\n    * @brief 获取最近点\n    * @details 在应用变换矩阵（可选）后,计算椭圆弧在XY方向上离给定点最近的点（投影或端点）\n    * \n    * @param XPoint3dR closePoint\n    * @param double & closeParam\n    * @param double & distanceXY\n    * @param XPoint3dCR spacePoint\n    * @param XMatrix4dCP worldToLocal\n    * @param bool extend0\n    * @param bool extend1\n    * @return bool\n    *\n    * @author SZEWEC\n    * @since 2022/04/22\n    */\n    bool ClosestPointBoundedXY\n    (\n    XPoint3dR   closePoint,\n    double&     closeParam,\n    double&     distXY,\n    XPoint3dCR  spacePoint,\n    XMatrix4dCP worldToLocal,\n    bool extend0,\n    bool extend1\n    ) const;\n\n\t/**\n\t* @brief 获取椭圆弧的起始与终止角度\n\t*\n\t* @param double & startAngle 起始角度\n\t* @param double & endAngle 终止角度\n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/30\n\t*/\n\tvoid GetLimits\n\t(\n\t\tdouble &startAngle,\n\t\tdouble &endAngle\n\t) const;\n\n\t/**\n\t* @brief 给定0°和90°的向量创建椭圆弧\n\t*\n\t* @param XPoint3dCR center\t\t\t\t\t中心点\n\t* @param XVec3dCR vector0\t\t\t\t\t0°向量（通常为沿着主轴的方向）\n\t* @param XVec3dCR vector90\t\t\t\t\t90°向量（通常为沿着短轴的方向）\n\t* @param double theta0\t\t\t\t\t\t起始点对应的角度\n\t* @param double sweep\t\t\t\t\t\t扫掠角度\n\t* @return ATEC_NAMESPACE_NAME::XEllipse3d\t椭圆弧\n\t*\n\t* @author SZEWEC\n\t* @since 2022/06/20\n\t*/\n\tstatic XEllipse3d FromVectors\n\t(\n\t\tXPoint3dCR center,\n\t\tXVec3dCR vector0,\n\t\tXVec3dCR vector90,\n\t\tdouble theta0,\n\t\tdouble sweep\n\t);\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XVec3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\nstruct ATGEOSET_EXPORT XVec3d : public XPoint3d\n{\n\tstatic XVec3d FromInterpolate(XVec3dCR vector0, double fraction, XVec3dCR vector1);\n\n\tstatic XVec3d From(double ax, double ay, double az = 0.0);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double  ay);\n\n\tstatic XVec3d From(XPoint3dCR point);\n\n\tvoid Init(XPoint3dCR point);\n\n\tstatic XVec3d FromStartEnd(XPoint3dCR start, XPoint3dCR end);\n\n\tstatic XVec3d FromStartEndNormalize(XPoint3dCR start, XPoint3dCR end);\n\n\tstatic XVec3d FromCCWPerpendicularXY(XVec3d source);\n\n\tstatic XVec3d FromRotate90Towards(XVec3dCR source, XVec3dCR target);\n\n\tstatic XVec3d FromRotate90Around(XVec3dCR source, XVec3dCR axis);\n\n\tstatic ValidatedXVec3d FromRotateVectorAroundVector(XVec3dCR source, XVec3dCR axis, XAngle angle);\n\n\tstatic XVec3d FromZero();\n\n\tstatic XVec3d UnitX();\n\n\tstatic XVec3d UnitY();\n\n\tstatic XVec3d UnitZ();\n\n\tdouble Normalize(XVec3dCR vector);\n\n\tdouble Normalize();\n\n\tdouble ScaleToLength(XVec3dCR vector, double length);\n\n\tdouble ScaleToLength(double length);\n\n\tstatic XVec3d FromXYAngleAndMagnitude\n\t(\n\t\tdouble          theta,\n\t\tdouble          magnitude\n\t);\n\n\tvoid InitFromXYAngleAndMagnitude\n\t(\n\t\tdouble          theta,\n\t\tdouble          magnitude\n\t);\n\n\tstatic XVec3d FromColumn(XRotMatrixCR matrix, int i);\n\n\tvoid InitFromColumn\n\t(\n\t\tXRotMatrixCR     matrix,\n\t\tint             col\n\t);\n\n\tvoid MultiplyTranspose(XRotMatrixCR matrix, XVec3dCR vector);\n\n\tvoid MultiplyTranspose(XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XVec3d FromStartEnd(XPoint4dCR start, XPoint4dCR end);\n\n\tstatic XVec3d FromCrossProduct(XVec3dCR vector0, XVec3dCR vector1);\n\n\tvoid CrossProduct(XVec3dCR vector1, XVec3dCR vector2);\n\n\tvoid CrossProduct(XVec3dCR vector1, XPoint3dCR point2);\n\n\tvoid CrossProduct(XPoint3dCR point1, XVec3dCR vector2);\n\n\tstatic XVec3d FromNormalizedCrossProductToPoints(XPoint3dCR origin, XPoint3dCR target1, XPoint3dCR target2);\n\n\tstatic XVec3d FromNormalizedCrossProduct(XVec3dCR vector0, XVec3dCR vector1);\n\n\tdouble NormalizedCrossProduct(XVec3dCR  vector1, XVec3dCR vector2);\n\n\tstatic XVec3d FromCrossProduct(double x0, double y0, double z0, double x1, double y1, double z1);\n\n\tvoid RotateXY(XVec3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tbool UnitPerpendicularXY(XVec3dCR vector);\n\n\tstatic ValidatedXVec3d FromUnitPerpendicularXY(XVec3dCR vector);\n\n\tstatic XVec3d FromSumOf(XVec3dCR vector0, XVec3dCR vector1);\n\n\tstatic XVec3d FromSumOf(XVec3dCR vector0, double scale0, XVec3dCR vector1, double scale1);\n\n\tvoid SumOf(XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2);\n\n\tstatic XVec3d FromSumOf(XVec3dCR vector0, double scale0, XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2);\n\n\tvoid SumOf(XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2, XVec3dCR vector3, double scale3);\n\n\tvoid SumOf(XVec3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XVec3dCR origin, XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2);\n\n\tvoid SumOf(XVec3dCR origin, XVec3dCR vector1, double scale1, XVec3dCR vector2, double scale2, XVec3dCR vector3, double scale3);\n\n\tstatic XVec3d FromScale(XVec3dCR vector, double scale);\n\n\tvoid Scale(XVec3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XVec3dCR vector);\n\n\tvoid Negate();\n\n\tdouble DotProduct(XVec3dCR vector2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n    double DotProductXY(XVec3dCR vector2) const;\n\n\tdouble TripleProduct(XVec3dCR vector2, XVec3dCR vector3) const;\n\n\tdouble Magnitude() const;\n\n\tdouble AngleTo(XVec3dCR vector2) const;\n\n\tdouble AngleToXY(XVec3dCR vector2) const;\n\n\tdouble SignedAngleTo\n\t(\n\t\tXVec3dCR        vector2,\n\t\tXVec3dCR        orientationVector\n\t) const;\n\n\tbool IsParallelTo(XVec3dCR vector2) const;\n\n\tbool IsPerpendicularTo(XVec3dCR vector2) const;\n\n\tbool      IsZero();\n\n\tvoid Multiply(XRotMatrixCR matrix, XVec3dCR vector);\n\n\tvoid Multiply(XRotMatrixCR matrix, double x, double y, double z);\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XPoint3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n /**\n * @brief 3D绌洪棿鐐圭被\n * @author SZEWC\n * @since 2022/04/13\n*/\nstruct ATGEOSET_EXPORT XPoint3d\n{\n\n\tdouble x;\n\n\tdouble y;\n\n\tdouble z;\n\n\tstatic XPoint3d From(double x, double y, double z = 0.0);\n\n\tstatic XPoint3d From(XPoint2dCR xy);\n\n\tstatic XPoint3d FromZero();\n\n\tstatic XPoint3d FromOne();\n\n\tstatic XPoint3d FromXYZ(double x, double y, double z);\n\n\tvoid Swap(XPoint3dR other);\n\n\tdouble DotDifference(XPoint3dCR origin, XVec3dCR vector) const;\n\n\tvoid Zero();\n\n\tvoid Init(XPoint2dCR source);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double ay);\n\n\tvoid SetComponent(double a, int index);\n\n\tdouble GetComponent(int index) const;\n\n\tvoid Interpolate(XPoint3dCR pnt0, double fractionParameter, XPoint3dCR point1);\n\n\tdouble Distance(XPoint3dCR point2) const;\n\n\tdouble DistanceXY(XPoint3dCR point2) const;\n\n\tbool DistanceXY(XPoint3dCR otherPoint, XMatrix4dCP matrix, double &distance) const;\n\n\tbool IsEqual(XPoint3dCR point2) const;\n\n\tbool IsEqual(XPoint3dCR point2, double tolerance) const;\n\n\tbool IsDisconnect() const;\n\n\tvoid InitDisconnect();\n\n\tvoid Init(XVec3dCR vector);\n\n\tvoid Subtract(XPoint3dCR base, XVec3dCR vector);\n\n\tvoid Add(XVec3dCR vector);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2, XVec3dCR point3, double scale3);\n\n\tvoid CrossProduct(XPoint3dCR point1, XPoint3dCR point2);\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble AngleTo(XPoint3dCR point2) const;\n\n\tvoid RotateXY(XPoint3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tdouble MagnitudeXY() const;\n\n\tvoid Scale(XPoint3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XPoint3dCR vector);\n\n\tvoid Negate();\n\n\tdouble Normalize(XPoint3dCR vector);\n\n\tdouble Normalize();\n\n\tvoid Subtract(XPoint3dCR point2);\n\n\tvoid DifferenceOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2, XPoint3dCR point3, double scale3);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2, XPoint3dCR point3, double a3);\n\n\tvoid Add(XPoint3dCR vector);\n\n\tvoid SumOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, XPoint3dCR point);\n\n\tstatic XPoint3d FromInterpolate(XPoint3dCR pntA, double fraction, XPoint3dCR pntB);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector, double scaleFactor);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1, XPoint3dCR point2, double scaleFactor2);\n\n\tstatic XPoint3d FromScale(XPoint3d point, double scale);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, XVec3dCR vector);\n\n\tbool AlmostEqual(XPoint3d const & dataB) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB) const;\n\n\tbool AlmostEqual(XPoint3d const & dataB, double abstol) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB, double abstol) const;\n\n\tstatic bool AlmostEqual(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tstatic bool AlmostEqualXY(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tdouble DistanceSquared(XPoint3dCR point2) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file CreateGeometryExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};\n code of file ATBsplineCurve.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\nstruct RefCountedATBsplineCurve;\ntypedef RefCountedPtr <RefCountedATBsplineCurve> ATBsplineCurvePtr;\ntypedef int ATBsplineStatus;\n /**\n * @brief B样条曲线\n * @author SZEWC\n * @since 2022/04/27\n*/\nstruct ATBsplineCurve\n{\npublic:\n\tint32_t             type;\n\tint32_t             rational;\n\tBsplineDisplay      display;\n\tBsplineParam        params;\n\tXPoint3d            *poles;\n\tdouble              *knots;\n\tdouble              *weights;\n\npublic:\n\n\t/**\n    * @brief 用直接提供的极点、系数和节点生成B样条曲线并返回智能指针\n\t* @return ATGEOSET_EXPORT ATBsplineCurvePtr\n\t* @param xvector<XPoint3d> const & poles\n\t* @param xvector<double> const * weights\n\t* @param xvector<double> const * knots\n\t* @param int order\n\t* @param bool closed\n\t* @param bool inputPolesAlreadyWeighted\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT static ATBsplineCurvePtr CreateFromPolesAndOrder\n\t(\n\t\txvector<XPoint3d> const &poles,\n\t\txvector<double> const *weights,\n\t\txvector<double> const *knots,\n\t\tint order,\n\t\tbool closed,\n\t\tbool inputPolesAlreadyWeighted\n\t);\n\n\t/**\n    * @brief 用直接提供的极点、系数和节点生成B样条曲线并返回智能指针\n\t* @return ATGEOSET_EXPORT ATBsplineCurvePtr\n\t* @param XPoint3dCP poles\n\t* @param int numPoles\n\t* @param int order\n\t* @param bool closed\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT static ATBsplineCurvePtr CreateFromPolesAndOrder\n\t(\n\t\tXPoint3dCP poles,\n\t\tint numPoles,\n\t\tint order,\n\t\tbool closed = false\n\t);\n\n\t/**\n    * @brief 用直接提供的极点、系数和节点生成B样条曲线并返回智能指针\n\t* @return ATGEOSET_EXPORT ATBsplineCurvePtr\n\t* @param XPoint2dCP poles\n\t* @param int numPoles\n\t* @param int order\n\t* @param bool closed\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT static ATBsplineCurvePtr CreateFromPolesAndOrder\n\t(\n\t\tXPoint2dCP poles,\n\t\tint numPoles,\n\t\tint order,\n\t\tbool closed = false\n\t);\n\n\t/**\n    * @brief 复制曲线指定分数参数之间的部分\n\t* @return ATGEOSET_EXPORT ATBsplineCurvePtr\n\t* @param double fraction0\n\t* @param double fraction1\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT ATBsplineCurvePtr CreateCopyBetweenFractions(double fraction0, double fraction1) const;\n\n\t/**\n    * @brief 创建一个近似于BasicCurve的样条曲线\n\t* @return ATGEOSET_EXPORT ATBsplineCurvePtr\n\t* @param IBasicCurveCR curve\n\t* @param size_t numPoles\n\t* @param int order\n\t* @param bool normalizeKnots\n\t* @param int knotSelector\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tstatic ATGEOSET_EXPORT ATBsplineCurvePtr CreateFromInterpolationAtGrevilleKnots\n\t(\n\t\tIBasicCurveCR curve,\n\t\tsize_t numPoles,\n\t\tint order,\n\t\tbool normalizeKnots,\n\t\tint knotSelector = 0\n\t);\n\n\t/**\n    * @brief B样条曲线上指定点的分数参数\n\t* @return ATGEOSET_EXPORT void\n\t* @param XPoint3dR xyz\n\t* @param double f\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT void FractionToPoint(XPoint3dR xyz, double f) const;\n\n\t/**\n    * @brief B样条曲线上指定点的分数参数\n\t* @return ATGEOSET_EXPORT void\n\t* @param XPoint3dR xyz\n\t* @param XVec3dR tangent\n\t* @param double f\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT void FractionToPoint(XPoint3dR xyz, XVec3dR tangent, double f) const;\n\n\t/**\n    * @brief 通过索引返回极点,如果超出范围返回0\n\t* @return ATGEOSET_EXPORT XPoint3d\n\t* @param size_t index\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT XPoint3d GetPole(size_t index) const;\n\n\t/**\n    * @brief 通过索引返回极点,如果超出范围返回0\n\t* @return ATGEOSET_EXPORT XPoint3d\n\t* @param int index\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT XPoint3d GetPole(int index) const;\n\n\t/**\n    * @brief 根据索引设定极点,如果索引超出范围,返回false\n\t* @return ATGEOSET_EXPORT bool\n\t* @param size_t index\n\t* @param XPoint3dCR value\n\t* @param bool reverse\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT bool SetReWeightedPole(size_t index, XPoint3dCR value, bool reverse = false);\n\n\t/**\n    * @brief 根据索引设定极点,如果索引超出范围,返回false\n\t* @return ATGEOSET_EXPORT bool\n\t* @param int index\n\t* @param XPoint3dCR value\n\t* @param bool reverse\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT bool SetReWeightedPole(int index, XPoint3dCR value, bool reverse = false);\n\n\t/**\n    * @brief 获取分离权重参数后的极点\n\t* @return ATGEOSET_EXPORT void\n\t* @param xvector<XPoint3d> & outData\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT void GetUnWeightedPoles(xvector<XPoint3d> &outData) const;\n\n\t/**\n    * @brief 获取所有极点\n\t* @return ATGEOSET_EXPORT void\n\t* @param xvector<XPoint3d> & outData\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT void GetPoles(xvector<XPoint3d> &outData) const;\n\n\t/**\n    * @brief 获取极点个数\n\t* @return ATGEOSET_EXPORT int\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT int GetIntNumPoles() const;\n\n\t/**\n    * @brief 计算B样条曲线的长度\n\t* @return ATGEOSET_EXPORT double\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT double Length() const;\n\n\t/**\n    * @brief 计算经过变换的曲线长度\n\t* @return ATGEOSET_EXPORT double\n\t* @param XRotMatrixCP worldToLocal\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT double Length(XRotMatrixCP worldToLocal) const;\n\n\t/**\n    * @brief 计算与平面的交点\n\t* @return ATGEOSET_EXPORT void\n\t* @param xvector<XPoint3d> * points\n\t* @param xvector<double> * fractionParameters\n\t* @param XPlane3dCR plane\n\t* @author SZEWEC\n\t* @since 2022/04/06\n\t*/\n\tATGEOSET_EXPORT void AddPlaneIntersections(xvector<XPoint3d>* points, xvector<double> *fractionParameters, XPlane3dCR plane) const;\n\n\t/**\n    * @brief 计算与平面的交点\n\t* @return ATGEOSET_EXPORT void\n\t* @param xvector<XPoint3d> * points\n\t* @param xvector<double> * fractionParameters\n\t* @param XPoint4dCR planeCoffs\n\t* @author SZEWEC\n\t* @since 2022/04/07\n\t*/\n\tATGEOSET_EXPORT void AddPlaneIntersections(xvector<XPoint3d>* points, xvector<double> *fractionParameters, XPoint4dCR planeCoffs) const;\n\n\t/**\n    * @brief 在XY方向上计算与直线的交点\n\t* @return ATGEOSET_EXPORT void\n\t* @param xvector<XPoint3d> * curvePoints\n\t* @param xvector<double> * curveFractions\n\t* @param xvector<XPoint3d> * linePoints\n\t* @param xvector<double> * lineFractions\n\t* @param XSegment3dCR segment\n\t* @param bool extendSegment\n\t* @param XMatrix4dCP matrix\n\t* @author SZEWEC\n\t* @since 2022/04/07\n\t*/\n\tATGEOSET_EXPORT void AddLineIntersectionsXY(xvector<XPoint3d> *curvePoints, xvector<double> *curveFractions,\n\t\txvector<XPoint3d> *linePoints, xvector<double> *lineFractions,\n\t\tXSegment3dCR segment, bool extendSeg, XMatrix4dCP matrix) const;\n\n\t/**\n    * @brief 获取B样条曲线的起始或终止端点\n\t* @return ATGEOSET_EXPORT void\n\t* @param XPoint3dR start\n\t* @param XPoint3dR end\n\t* @author SZEWEC\n\t* @since 2022/04/07\n\t*/\n\tATGEOSET_EXPORT void ExtractEndPoints(XPoint3dR start, XPoint3dR end) const;\n\n\t/**\n    * @brief 计算近似路径\n\t* @return ATGEOSET_EXPORT void\n\t* @param xvector <XPoint3d> & points\n\t* @param double chordTol\n\t* @param double angleTol\n\t* @param double maxEdgeLength\n\t* @param bool includeStartPoint\n\t* @author SZEWEC\n\t* @since 2022/04/07\n\t*/\n\tATGEOSET_EXPORT void AddStrokes(xvector <XPoint3d> &points,\n\t\tdouble chordTol = 0.0, double angleTol = 0.20, double maxEdgeLength = 0.0, bool includeStartPoint = true) const;\n\n\t/**\n    * @brief 计算在均分角度上的点\n\t* @return ATGEOSET_EXPORT bool\n\t* @param xvector <XPoint3d> & points\n\t* @param xvector<double> & fractions\n\t* @param size_t numPoints\n\t* @author SZEWEC\n\t* @since 2022/04/07\n\t*/\n\tATGEOSET_EXPORT bool PointsAtUniformArcLength(xvector <XPoint3d> &points, xvector<double> &fractions, size_t numPoints) const;\n\n\t/**\n    * @brief 获取曲线上离给定点最接近的点和对应的分数参数\n\t* @return ATGEOSET_EXPORT void\n\t* @param XPoint3dR curvePoint\n\t* @param double & fraction\n\t* @param XPoint3dCR spacePoint\n\t* @author SZEWEC\n\t* @since 2022/04/07\n\t*/\n\tATGEOSET_EXPORT void ClosestPoint(XPoint3dR curvePoint, double &fraction, XPoint3dCR spacePoint) const;\n\n\t/**\n\t* @brief 使用Lim拟合条件创建B样条曲线\n\t*\n\t* @param xvector<XPoint3d>const & xyz\t\t\t插值点\n\t* @param size_t order\t\t\t\t\t\t\tB样条阶数\n\t* @param int knotType\t\t\t\t\t\t\t节点类型,0为uniform、1为chord length、2为centripetal\n\t* @return ATGEOSET_EXPORT ATBsplineCurvePtr\tB样条曲线\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/29\n\t*/\n\tstatic ATGEOSET_EXPORT ATBsplineCurvePtr CreateFromInterpolationAtBasisFunctionPeaks(xvector<XPoint3d>const &xyz, size_t order, int knotType = 0);\n\t/**\n\t* @brief 返回曲线阶数\n\t* \n\t* @return ATGEOSET_EXPORT size_t 阶数\n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/30\n\t*/\n\tATGEOSET_EXPORT size_t GetOrder() const;\n\n\t/**\n\t* @brief 创建在不相交节点分割的各段的拷贝\n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/31\n\t*/\n\tATGEOSET_EXPORT void GetDisjointCurves(xvector<ATBsplineCurvePtr> &curves) const;\n\n\t/**\n\t* @brief 创建在点或切线变化处分割的各段的拷贝\n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/31\n\t*/\n\tATGEOSET_EXPORT void GetC1DiscontinuousCurves(xvector<double> &fractions, xvector<ATBsplineCurvePtr> &curves) const;\n\n    //! Create the B-spline curve from point array and order.\n    ATGEOSET_EXPORT ATBsplineStatus InitFromPoints(XPoint3dCP points, int nPoints);\n};\n\nstruct RefCountedATBsplineCurve : public ATBsplineCurve, RefCountedBase\n{\nprotected:\n\tRefCountedATBsplineCurve();\n\t~RefCountedATBsplineCurve();\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XSegment3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n /**\n * @brief 三维线段类\n * @author SZEWC\n * @since 2022/04/14\n*/\nstruct ATGEOSET_EXPORT XSegment3d\n{\n\n\tXPoint3d point[2];\n\n\t/**\n\t* @brief 创建函数\n\t* @details 根据起点和延伸向量创建线段\n\t* \n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR tangent\n\t* @return XSegment3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic XSegment3d FromOriginAndDirection\n\t(\n\t\tXPoint3dCR      pnt0,\n\t\tXPoint3dCR      tangent\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个所有坐标都为零的线段\n\t* \n\t* @return XSegment3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic XSegment3d FromZero();\n\n\tvoid InitProduct(TransformCR transform, XSegment3dCR other);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由射线创建线段\n\t* \n\t* @param XRay3dCR ray\n\t* @return XSegment3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic XSegment3d From(XRay3dCR ray);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由起止点坐标创建线段\n\t* \n\t* @param double x0\n\t* @param double y0\n\t* @param double z0\n\t* @param double x1\n\t* @param double y1\n\t* @param double z1\n\t* @return XSegment3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic XSegment3d From\n\t(\n\t\tdouble          x0,\n\t\tdouble          y0,\n\t\tdouble          z0,\n\t\tdouble          x1,\n\t\tdouble          y1,\n\t\tdouble          z1\n\t);\n\n\t/**\n    * @brief 创建函数\n    * @details 由起止点创建线段\n\t* \n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point1\n\t* @return XSegment3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic XSegment3d From\n\t(\n\t\tXPoint3dCR      pnt0,\n\t\tXPoint3dCR      point1\n\t);\n\n\t/**\n    * @brief 创建函数\n    * @details 由2D起止点创建线段\n\t* \n\t* @param XPoint2dCR point0\n\t* @param XPoint2dCR point1\n\t* @return XSegment3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic XSegment3d From(XPoint2dCR pnt0, XPoint2dCR point1);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由起止点坐标创建初始化数据\n\t* \n\t* @param double x0\n\t* @param double y0\n\t* @param double z0\n\t* @param double x1\n\t* @param double y1\n\t* @param double z1\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid Init\n\t(\n\t\tdouble          x0,\n\t\tdouble          y0,\n\t\tdouble          z0,\n\t\tdouble          x1,\n\t\tdouble          y1,\n\t\tdouble          z1\n\t);\n\n\t/**\n    * @brief 初始化数据\n\t* @details 由起止点初始化数据\n\t* \n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point1\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid Init\n\t(\n\t\tXPoint3dCR      pnt0,\n\t\tXPoint3dCR      point1\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由2D起止点坐标初始化数据\n\t* \n\t* @param XPoint2dCR point0\n\t* @param XPoint2dCR point1\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid Init\n\t(\n\t\tXPoint2dCR      pnt0,\n\t\tXPoint2dCR      point1\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由起始点和延伸向量初始化数据\n\t* \n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR tangent\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid InitFromOriginAndDirection\n\t(\n\t\tXPoint3dCR      pnt0,\n\t\tXPoint3dCR      tangent\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由给定射线初始化数据\n\t* \n\t* @param XRay3dCR ray\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid InitFrom(XRay3dCR ray);\n\n\t/**\n\t* @brief 获取端点\n\t* @details 返回线段的两个端点\n\t* \n\t* @param XPoint3dR point0\n\t* @param XPoint3dR point1\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid GetEndPoints\n\t(\n\t\tXPoint3dR       pnt0,\n\t\tXPoint3dR       point1\n\t) const;\n\n\t/**\n\t* @brief 计算范围\n\t* @details 计算线段的范围盒,总是返回true\n\t* \n\t* @param XRange3dR range\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tbool GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief 投影点\n\t* @details 将给定点投影到延伸后的线段上\n\t* \n\t* @param XPoint3dR closestPoint\n\t* @param double & closestParam\n\t* @param XPoint3dCR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tbool ProjectPoint\n\t(\n\t\tXPoint3dR       closestPoint,\n\t\tdouble          &closestParam,\n\t\tXPoint3dCR      point\n\t) const;\n\n\t/**\n\t* @brief 投影点\n\t* @details 仅在XY方向上将给定点投影到延伸后的线段上\n\t* \n\t* @param XPoint3dR closestPoint\n\t* @param double & closestParam\n\t* @param XPoint3dCR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tbool ProjectPointXY\n\t(\n\t\tXPoint3dR       closestPoint,\n\t\tdouble          &closestParam,\n\t\tXPoint3dCR      point\n\t) const;\n\n\t/**\n\t* @brief 计算交点\n\t* @details 计算（无界）线段与平面的交点\n\t* \n\t* @param XPoint3dR intPoint\n\t* @param double & intParam\n\t* @param XPlane3dCR plane\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tbool Intersect\n\t(\n\t\tXPoint3dR       intPoint,\n\t\tdouble          &intParam,\n\t\tXPlane3dCR      plane\n\t) const;\n\n\t/**\n\t* @brief 获取起点\n\t* @details 返回线段的起点\n\t* \n\t* @param XPoint3dR pt\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid GetStartPoint(XPoint3dR pt) const;\n\n\t/**\n\t* @brief 获取终点\n\t* @details 返回线段的终点\n\t* \n\t* @param XPoint3dR pt\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid GetEndPoint(XPoint3dR pt) const;\n\n\t/**\n\t* @brief 设置起点\n\t* @details 设置线段的起点\n\t* \n\t* @param XPoint3dCR point\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid SetStartPoint(XPoint3dCR point);\n\n\t/**\n\t* @brief 设置终点\n\t* @details 设置线段的终点\n\t* \n\t* @param XPoint3dCR point\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tvoid SetEndPoint(XPoint3dCR point);\n\n\t/**\n\t* @brief 比例到点\n\t* @details 根据比例参数返回线段上的点\n\t* \n\t* @param double fraction\n\t* @return XPoint3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tXPoint3d FractionToPoint(double fraction) const;\n\n\t/**\n\t* @brief 点到比例\n\t* @details 返回空间点对应的比例参数,小于0或大于1意味着在线段外\n\t* \n\t* @param double & param\n\t* @param XPoint3dCR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tbool PointToFractionParameter\n\t(\n\t\tdouble          &param,\n\t\tXPoint3dCR      point\n\t) const;\n\n\t/**\n\t* @brief 比例到切线\n\t* @details 返回线段上给定比例参数对应点的切向量\n\t* \n\t* @param XPoint3dR point\n\t* @param XVec3dR tangent\n\t* @param double param\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tbool FractionParameterToTangent\n\t(\n\t\tXPoint3dR       point,\n\t\tXVec3dR       tangent,\n\t\tdouble          param\n\t) const;\n\n\t/**\n\t* @brief 长度\n\t* @details 计算线段的长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tdouble Length() const;\n\n    /**\n    * @brief 两条有界线段最近的点\n    * \n    * @param double & fraction0\n    * @param double & fraction1\n    * @param XPoint3dR point0\n    * @param XPoint3dR point1\n    * @param XSegment3dCR segment0\n    * @param XSegment3dCR segment1\n    * @return void\n    *\n    * @author SZEWEC\n    * @since 2022/04/27\n    */\n    static void   ClosestApproachBounded\n        (\n        double      &fraction0,\n        double      &fraction1,\n        XPoint3dR    pnt0,\n        XPoint3dR    point1,\n        XSegment3dCR seg0,\n        XSegment3dCR seg1\n        );\n\n\t/**\n\t* @brief 两条线段（视为无界）最近的点\n\t* \n\t* @param double & fraction0\n\t* @param double & fraction1\n\t* @param XPoint3dR point0\n\t* @param XPoint3dR point1\n\t* @param XSegment3dCR segment0\n\t* @param XSegment3dCR segment1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic bool ClosestApproachUnbounded\n\t(\n\t\tdouble      &fraction0,\n\t\tdouble      &fraction1,\n\t\tXPoint3dR    pnt0,\n\t\tXPoint3dR    point1,\n\t\tXSegment3dCR seg0,\n\t\tXSegment3dCR seg1\n\t);\n\n    /**\n    * @brief XY方向上两条有界线段最近的点\n    * \n    * @param double & fraction0\n    * @param double & fraction1\n    * @param XPoint3dR point0\n    * @param XPoint3dR point1\n    * @param XSegment3dCR segment0\n    * @param XSegment3dCR segment1\n    * @return void\n    *\n    * @author SZEWEC\n    * @since 2022/04/27\n    */\n    static void   ClosestApproachBoundedXY\n    (\n    double      &fraction0,\n    double      &fraction1,\n    XPoint3dR    pnt0,\n    XPoint3dR    point1,\n    XSegment3dCR seg0,\n    XSegment3dCR seg1\n    );\n\n\t/**\n\t* @brief XY相交\n\t* @details 计算两条（视为无界）线段仅在XY方向上的交点,当线段平行时返回false\n\t* \n\t* @param double & fractionA\n\t* @param double & fractionB\n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @param XSegment3dCR segmentA\n\t* @param XSegment3dCR segmentB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/14\n\t*/\n\tstatic bool IntersectXY\n\t(\n\t\tdouble          &fractionA,\n\t\tdouble          &fractionB,\n\t\tXPoint3dR       pntA,\n\t\tXPoint3dR       pntB,\n\t\tXSegment3dCR    segA,\n\t\tXSegment3dCR    segB\n\t);\n\n};\n\nEND_ATEC_NAMESPACE\n\n", "output": "\nCurveSetPtr CreateGeometryExamples::GetComplexGeo()\n{\n\t//1. 创建一个圆弧\n\tXPoint3d startPt = XPoint3d::From(-50, 0, 0);\n\tXPoint3d endPt = XPoint3d::From(50, 0, 0);\n\tXPoint3d midPt = XPoint3d::From(0, 50, 0);\n\tXEllipse3d arc = XEllipse3d::FromPointsOnArc(startPt, midPt, endPt);\n\n\t//2. 创建一个线段\n\tXPoint3d linePt = endPt + XVec3d::UnitX() * 100;\n\tXSegment3d line = XSegment3d::From(endPt, linePt);\n\n\t//3. 创建一个B样条曲线\n\tXPoint3d pt1 = linePt + XVec3d::UnitX() * 50;\n\tpt1.y += 50;\n\n\tXPoint3d pt2 = pt1 + XVec3d::UnitX() * 50;\n\txvector<XPoint3d> vPts = { linePt, pt1, pt2 };\n\n\tATBsplineCurvePtr bslpineCurve = ATBsplineCurve::CreateFromInterpolationAtBasisFunctionPeaks(vPts, 3, 0);\n\n\t//4. 创建一个LinString\n\tXPoint3d pt3 = pt2 - XVec3d::UnitY() * 150;\n\tXPoint3d pt4 = pt3 - XVec3d::UnitX() * 300;\n\txvector<XPoint3d> vPts2 = { pt2, pt3, pt4 , startPt };\n\t\n\tIBasicCurvePtr lineString = IBasicCurve::CreateLineString(vPts2);\n\n\t//5. 构造CurveSet--表示复杂对象\n\tCurveSetPtr curve = CurveSet::Create(IBasicCurve::CreateArc(arc));\n\tcurve->Add(IBasicCurve::CreateLine(line));\n\tcurve->Add(IBasicCurve::CreateBsplineCurve(bslpineCurve));\n\tcurve->Add(lineString);\n\tcurve->SetBoundaryType(CurveSet::BOUNDARY_TYPE_Outer);\n\treturn curve;\n}\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};. You need to implement the function CreateCurveSet_ComplexGeo in the interface. Here are some apis that you can use and remember:\n code of file CreateGeometryExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};", "output": "\nvoid CreateGeometryExamples::CreateCurveSet_ComplexGeo()\n{\n\tCurveSetPtr curve = GetComplexGeo();\n\n\tif (curve.IsValid())\n\t{\n\t\t//添加到视口\n\t\tAddGeometryToScene(curve, 4);\n\t}\n}\n"}, {"instruction": "Below is an interface you need to implement, along with some helpful APIs. Your task is to use these APIs to implement certain functions of the interface. It is important to remember these APIs so that you can use them in the future. \n Interface: #pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};. You need to implement the function GetRing in the interface. Here are some apis that you can use and remember:\n code of file IBasicCurve.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 基本线元类\n* @author SZEWC\n* @since 2022/04/28\n*/\nstruct IBasicCurve : public RefCountedBase\n{\nprivate: virtual void IAmAbstractClass() = 0;\n\npublic:\n\tenum BasicCurveType\n\t{\n\t\tBCURVE_TYPE_Invalid = 0,\n\t\tBCURVE_TYPE_Line = 1,\n\t\tBCURVE_TYPE_LineString = 2,\n\t\tBCURVE_TYPE_Arc = 3,\n\t\tBCURVE_TYPE_BsplineCurve = 4,\n\t\tBCURVE_TYPE_InterpolationCurve = 5,\n\t\tBCURVE_TYPE_AkimaCurve = 6,\n\t\tBCURVE_TYPE_PointString = 7,\n\t\tBCURVE_TYPE_CurveSet = 8,\n\t\tBCURVE_TYPE_Spiral = 9,\n\t\tBCURVE_TYPE_PartialCurve = 10,\n\t\tBCURVE_TYPE_NotClassified = -1,\n\t};\n\n\tATGEOSET_EXPORT int64_t GetTag() const;\n\n\tATGEOSET_EXPORT int GetIntTag() const;\n\n\tATGEOSET_EXPORT void SetTag(int64_t tag);\n\n\tATGEOSET_EXPORT void SetTag(int tag);\n\n\tATGEOSET_EXPORT CurveSetPtr GetChildCurveSetP();\n\npublic:\n\tATGEOSET_EXPORT xvector<XPoint3d> * GetLineStringP();\n\n\tATGEOSET_EXPORT BasicCurveType           GetBasicCurveType() const;\n\n\tATGEOSET_EXPORT bool TryGetLine(XSegment3dR segment) const;\n\n\tATGEOSET_EXPORT bool TryGetArc(XEllipse3dR arc) const;\n\n\tATGEOSET_EXPORT XSegment3dCP                 GetLineCP() const;\n\n\tATGEOSET_EXPORT xvector<XPoint3d> const* GetLineStringCP() const;\n\n\tATGEOSET_EXPORT bool TryGetSegmentInLineString(XSegment3dR segment, size_t startPointIndex) const;\n\n\tATGEOSET_EXPORT XEllipse3dCP                 GetArcCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurveCP             GetBsplineCurveCP() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr             GetBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr            GetProxyBsplineCurvePtr() const;\n\n\tATGEOSET_EXPORT XSpiral2dPlacementCP         GetSpiralPlacementCP() const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLine(XSegment3dCR segment);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(XPoint3dCP points, size_t nPoints);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateLineString(xvector<XPoint3d> const &points);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateArc(XEllipse3dCR ellipse);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurveCR curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateBsplineCurve(ATBsplineCurvePtr& curve);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiral(XSpiral2dBaseCR spiral, TransformCR frame,\n\t\tdouble fractionA, double fractionB);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusBearingRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble endRadians,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateSpiralBearingRadiusLengthRadius\n\t(\n\t\tint transitionType,\n\t\tdouble startRadians,\n\t\tdouble startRadius,\n\t\tdouble length,\n\t\tdouble endRadius,\n\t\tTransformCR frame,\n\t\tdouble fractionA,\n\t\tdouble fractionB\n\t);\n\n\tATGEOSET_EXPORT IBasicCurvePtr Clone() const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneComponent(ptrdiff_t componentIndex) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneAsSingleOffsetPrimitiveXY(CurveOffsetOptionsCR options) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool ComponentFractionToPoint(ptrdiff_t componentIndex, double f, XPoint3dR point, XVec3dR tangent) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XRay3dR ray) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, CurveDescInfo &detail) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2) const;\n\n\tATGEOSET_EXPORT bool FractionToPoint(double f, XPoint3dR point, XVec3dR tangent, XVec3dR derivative2, XVec3dR derivative3) const;\n\n\tATGEOSET_EXPORT bool FractionToFrenetFrame(double f, TransformR frame) const;\n\n\tATGEOSET_EXPORT bool Length(double &length) const;\n\n\tATGEOSET_EXPORT bool Length(XRotMatrixCP worldToLocal, double &length) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\tATGEOSET_EXPORT size_t NumComponent() const;\n\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetATBsplineCurvePtr(double fraction0 = 0.0, double fraction1 = 1.0) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool PointAtSignedDistanceFromFraction(XRotMatrixCP worldToView, double startFraction, double signedDist, bool allowExtension, CurveDescInfoR location) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\tATGEOSET_EXPORT bool TrySetStart(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TrySetEnd(XPoint3dCR xyz);\n\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\tATGEOSET_EXPORT void  AppendCurvePlaneIntersections\n\t(\n\t\tXPlane3dByVectorsCR plane,\n\t\tUVBoundarySelect   bounded,\n\t\txvector<CurveAndSolidDescInfo> &intersections\n\t) const;\n\n\tATGEOSET_EXPORT bool AddStrokes(xvector <XPoint3d> &points, IFacetOptionsR options,\n\t\tbool includeStartPoint = true,\n\t\tdouble startFraction = 0.0,\n\t\tdouble endFraction = 1.0\n\t) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, double &fraction, XPoint3dR curvePoint) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n    ATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\tATGEOSET_EXPORT IBasicCurvePtr CloneBetweenFractions(double fractionA, double fractionB, bool allowExtrapolation) const;\n\n\tATGEOSET_EXPORT CurveSetCP            GetChildCurveSetCP() const;\n\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(double startFraction, double endFraction, double &signedDist) const;\n\tATGEOSET_EXPORT bool SignedDistanceBetweenFractions(XRotMatrixCP worldToLocal, double startFraction, double endFraction, double &signedDist) const;\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateRectangle(double x0, double y0, double x1, double y1, double z, int areaSignPref = 0);\n\n\tATGEOSET_EXPORT static IBasicCurvePtr CreateChildCurveSet(CurveSetPtr source);\n\n\tATGEOSET_EXPORT bool  TryGetPartialCurveData(double &fractionA, double &fractionB, IBasicCurvePtr &parentCurve, int64_t &tag) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XEllipse3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 椭圆弧\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct ATGEOSET_EXPORT XEllipse3d\n{\n\tXPoint3d center;\n\tXVec3d   vector0;\n\tXVec3d   vector90;\n\tdouble start;\n\tdouble sweep;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 返回由已有椭圆的起始和终止比例定义的椭圆弧\n\t* \n\t* @param XEllipse3dCR parent\n\t* @param double startFraction\n\t* @param double endFraction\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromFractionInterval\n\t(\n\t\tXEllipse3dCR parent,\n\t\tdouble startFraction,\n\t\tdouble endFraction\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 根据椭圆的中心点、角度为0度和90度的点,以及扫掠角度创建一个椭圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point90\n\t* @param double theta0\n\t* @param double sweep\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromPoints(XPoint3dCR center, XPoint3dCR pnt0, XPoint3dCR pnt90, double theta0, double sweep);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由起始点,起始切线,半径,扫掠角度和面法向量创建椭圆弧\n\t* \n\t* @param XPoint3dCR pointA\n\t* @param XVec3dCR tangent\n\t* @param XVec3dCR planeNormal\n\t* @param double radius\n\t* @param double sweepRadians\n\t* @return ValidatedXEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic ValidatedXEllipse3d FromStartTangentNormalRadiusSweep(\n\n\t\tXPoint3dCR pntA,\n\t\tXVec3dCR tangent,\n\t\tXVec3dCR planeNormal,\n\t\tdouble radius,\n\t\tdouble sweepRadians\n\t);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由弧上的点创建椭圆弧\n\t* \n\t* @param XPoint3dCR start\n\t* @param XPoint3dCR middle\n\t* @param XPoint3dCR end\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromPointsOnArc(XPoint3dCR start, XPoint3dCR middle, XPoint3dCR end);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、起始点和终止点的切线创建椭圆弧（扫掠角取较小的一个）\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endTarget\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromArcCenterStartEnd(XPoint3dCR center, XPoint3dCR startPoint, XPoint3dCR endTarget);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、半径和面法向量创建完整的圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param XVec3dCR normal\n\t* @param double radius\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromCenterNormalRadius(XPoint3dCR center, XVec3dCR normal, double radius);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由中心点、半径创建XY平面上完整的圆弧\n\t* \n\t* @param XPoint3dCR center\n\t* @param double radius\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromCenterRadiusXY(XPoint3dCR center, double radius);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 返回给定椭圆弧以反方向扫掠得到的椭圆弧\n\t* \n\t* @param XEllipse3dCR source\n\t* @return XEllipse3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tstatic XEllipse3d FromReversed(XEllipse3dCR source);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由给定点和扫掠角初始化数据\n\t* \n\t* @param XPoint3dCR center\n\t* @param XPoint3dCR point0\n\t* @param XPoint3dCR point90\n\t* @param double theta0\n\t* @param double sweep\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid InitFromPoints\n\t(\n\t\tXPoint3dCR      center,\n\t\tXPoint3dCR      pnt0,\n\t\tXPoint3dCR      pnt90,\n\t\tdouble          theta0,\n\t\tdouble          sweep\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由椭圆弧上的点初始化数据\n\t* \n\t* @param XPoint3dCR start\n\t* @param XPoint3dCR middle\n\t* @param XPoint3dCR end\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool InitFromPointsOnArc\n\t(\n\t\tXPoint3dCR      start,\n\t\tXPoint3dCR      middle,\n\t\tXPoint3dCR      end\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由中心点、起始点和终止点的切线初始化数据（扫掠角取较小的一个）\n\t* \n\t* @param XPoint3dCR centerIN\n\t* @param XPoint3dCR startIN\n\t* @param XPoint3dCR end\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool InitFromArcCenterStartEnd\n\t(\n\t\tXPoint3dCR      centerIN,\n\t\tXPoint3dCR      startIN,\n\t\tXPoint3dCR      end\n\t);\n\n\t/**\n\t* @brief 设置起始点\n\t* @details 修改椭圆弧的起点和终点\n\t* \n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endPoint\n\t* @param bool ccw\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool SetStartEnd\n\t(\n\t\tXPoint3dCR      startPoint,\n\t\tXPoint3dCR      endPoint,\n\t\tbool            ccw\n\t);\n\n\t/**\n\t* @brief 初始化数据\n\t* @details 由中心点、半径和面法向量初始化数据\n\t* \n\t* @param XPoint3dCR centerIN\n\t* @param XVec3dCR normal\n\t* @param double radius\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid InitFromCenterNormalRadius\n\t(\n\t\tXPoint3dCR      centerIN,\n\t\tXVec3dCR      normal,\n\t\tdouble          radius\n\t);\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点\n\t* \n\t* @param XPoint3dR point\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       point,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 角到点\n\t* @details 返回椭圆弧给定参数角对应的空间点\n\t* \n\t* @param double theta\n\t* @return XPoint3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tXPoint3d RadiansToPoint(double theta) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 返回椭圆弧给定参数坐标对应的空间点\n\t* \n\t* @param XPoint3dR point\n\t* @param double xx\n\t* @param double yy\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       point,\n\t\tdouble          xx,\n\t\tdouble          yy\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点\n\t* \n\t* @param XPoint4dR point\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint4dR       point,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 获取椭圆弧的起点和终点\n\t* \n\t* @param XPoint3dR startPoint\n\t* @param XPoint3dR endPoint\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid EvaluateEndPoints\n\t(\n\t\tXPoint3dR       startPoint,\n\t\tXPoint3dR       endPoint\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算椭圆弧给定参数角对应的空间点以及在参数值处的导数\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param XVec3dR dX\n\t* @param XVec3dR ddX\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tXVec3dR       dX,\n\t\tXVec3dR       ddX,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算给定的参数角比例对应的空间点\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param double fraction\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid FractionParameterToPoint\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tdouble          fraction\n\t) const;\n\n\t/**\n\t* @brief 比例到点\n\t* @details 返回给定的参数角比例对应的空间点\n\t* \n\t* @param double fraction\n\t* @return XPoint3d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tXPoint3d FractionToPoint(double fraction) const;\n\n\t/**\n\t* @brief 比例到导数\n\t* @details 返回给定的参数角比例对应的空间点及在该点处的导数\n\t* \n\t* @param XPoint3dR point3dX\n\t* @param XVec3dR dX\n\t* @param XVec3dR ddX\n\t* @param double fraction\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid FractionParameterToDerivatives\n\t(\n\t\tXPoint3dR       pnt3dX,\n\t\tXVec3dR       dX,\n\t\tXVec3dR       ddX,\n\t\tdouble          fraction\n\t) const;\n\n\t/**\n\t* @brief 代入参数\n\t* @details 计算给定的参数角比例对应的空间点及在该点处的导数,以数组形式返回\n\t* \n\t* @param XPoint3dP point3dX\n\t* @param int numDerivative\n\t* @param double theta\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid Evaluate\n\t(\n\t\tXPoint3dP       pnt3dX,\n\t\tint             numDerivative,\n\t\tdouble          theta\n\t) const;\n\n\t/**\n\t* @brief 点到角\n\t* @details 计算椭圆弧上的点对应的参数角\n\t* \n\t* @param XPoint3dCR point\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble PointToAngle(XPoint3dCR point) const;\n\n\t/**\n\t* @brief 投影点\n\t* @details 将给定点投影到椭圆弧所在的平面上\n\t* \n\t* @param XPoint3dR xYZNear\n\t* @param double & coff0\n\t* @param double & coff90\n\t* @param XPoint3dCR xYZ\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool ProjectPointToPlane\n\t(\n\t\tXPoint3dR       xYZNear,\n\t\tdouble          &coff0,\n\t\tdouble          &coff90,\n\t\tXPoint3dCR      xYZ\n\t) const;\n\n\t/**\n\t* @brief 角到比例\n\t* @details 计算给定参数角所对应椭圆弧上的比例\n\t* \n\t* @param double angle\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble AngleToFraction(double angle) const;\n\n\t/**\n\t* @brief 弧长\n\t* @details 返回椭圆弧的长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble ArcLength() const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 计算椭圆弧空间点的范围\n\t* \n\t* @param XRange3dR range\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief XY方向上与直线相交\n\t* @details 计算XY方向上与直线相交的交点,椭圆弧和直线都视为无界的\n\t* \n\t* @param XPoint3dP cartesianPoints\n\t* @param double * pLineParams\n\t* @param XPoint3dP ellipseCoffs\n\t* @param double * pEllipseAngle\n\t* @param XPoint3dCR startPoint\n\t* @param XPoint3dCR endPoint\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectXYLine\n\t(\n\t\tXPoint3dP       cartesianPoints,\n\t\tdouble          *pLineParams,\n\t\tXPoint3dP       ellipseCoffs,\n\t\tdouble          *pEllipseAngle,\n\t\tXPoint3dCR      startPoint,\n\t\tXPoint3dCR      endPoint\n\t) const;\n\n\t/**\n\t* @brief 是否完整\n\t* @details 查询椭圆弧是否完整\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCircular() const;\n\n\t/**\n\t* @brief 是否完整\n\t* @details 查询椭圆弧是否完整\n\t* \n\t* @param double & radius\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCircular(double &radius) const;\n\n\t/**\n\t* @brief 是否逆时针\n\t* @details 查询椭圆弧在XY平面内的投影是否逆时针扫掠\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool IsCCWSweepXY() const;\n\n\t/**\n\t* @brief 与线段相交\n\t* @details 计算与给定椭圆弧相交的交点,椭圆弧和线段都视为无界的\n\t* \n\t* @param XPoint3dP pointArray\n\t* @param XPoint3dP ellipseParams\n\t* @param double * pLineParams\n\t* @param XSegment3dCR segment\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectSweptXSegment3d\n\t(\n\t\tXPoint3dP       pntArray,\n\t\tXPoint3dP       ellipseParams,\n\t\tdouble          *pLineParams,\n\t\tXSegment3dCR    segment\n\t) const;\n\n\t/**\n\t* @brief 与线段相交\n\t* @details 计算与给定线段相交的交点,椭圆弧和线段都视为有界的\n\t* \n\t* @param XPoint3dP pointArray\n\t* @param XPoint3dP ellipseParams\n\t* @param double * pLineParams\n\t* @param XSegment3dCR segment\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectSweptXSegment3dBounded\n\t(\n\t\tXPoint3dP       pntArray,\n\t\tXPoint3dP       ellipseParams,\n\t\tdouble          *pLineParams,\n\t\tXSegment3dCR    segment\n\t) const;\n\n\t/**\n\t* @brief 转换为BR类型3D元素\n\t* @details 将椭圆弧转换为BR类型的3D元素\n\t* \n\t* @param XPoint3dR centerOUT\n\t* @param double * pQuatWXYZ\n\t* @param XVec3dR directionX\n\t* @param XVec3dR directionY\n\t* @param double & rx\n\t* @param double & ry\n\t* @param double & startAngle\n\t* @param double & sweepAngle\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetATFields3d\n\t(\n\t\tXPoint3dR       centerOUT,\n\t\tdouble *        pQuatWXYZ,\n\t\tXVec3dR         directionX,\n\t\tXVec3dR         directionY,\n\t\tdouble          &rx,\n\t\tdouble          &ry,\n\t\tdouble          &startAngle,\n\t\tdouble          &sweepAngle\n\t) const;\n\n\t/**\n\t* @brief 设置扫掠角\n\t* @details 设置椭圆弧的扫掠角\n\t* \n\t* @param double startAngle\n\t* @param double sweepIN\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid SetSweep\n\t(\n\t\tdouble          startAngle,\n\t\tdouble          sweepIN\n\t);\n\n\t/**\n    * @brief 获取扫掠角\n    * @details 获取椭圆弧的扫掠角\n\t* \n\t* @param double & startAngle\n\t* @param double & sweepAngle\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid GetSweep\n\t(\n\t\tdouble          &startAngle,\n\t\tdouble          &sweepAngle\n\t) const;\n\n\t/**\n\t* @brief 补全扫掠角\n\t* @details 根据当前的角度范围补全扫掠角\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid ComplementSweep();\n\n\t/**\n    * @brief 与弧相交\n    * @details 计算与给定椭圆弧相交的交点,椭圆弧都视为有界的\n\t* \n\t* @param XPoint3dP cartesianPoints\n\t* @param XPoint3dP ellipse0Coffs\n\t* @param double * pEllipse0Angle\n\t* @param XPoint3dP ellipse1Coffs\n\t* @param double * pEllipse1Angle\n\t* @param XEllipse3dCR ellipse1\n\t* @return int\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tint IntersectXYXEllipse3dBounded\n\t(\n\t\tXPoint3dP       cartesianPoints,\n\t\tXPoint3dP       ellipse0Coffs,\n\t\tdouble          *pEllipse0Angle,\n\t\tXPoint3dP       ellipse1Coffs,\n\t\tdouble          *pEllipse1Angle,\n\t\tXEllipse3dCR    ellipse1\n\t) const;\n\n\t/**\n\t* @brief 比例到角\n\t* @details 计算给定比例参数对应的参数角\n\t* \n\t* @param double fraction\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tdouble FractionToAngle(double fraction) const;\n\n\t/**\n\t* @brief 获取最近点\n\t* @details 获取有界椭圆弧在XY方向上离给定空间点最近的点\n\t* \n\t* @param double & minAngle\n\t* @param double & minDistanceSquared\n\t* @param XPoint3dR minPoint\n\t* @param XPoint3dCR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tbool ClosestPointXYBounded\n\t(\n\t\tdouble          &minAngle,\n\t\tdouble          &minDistSquared,\n\t\tXPoint3dR       minPoint,\n\t\tXPoint3dCR      point\n\t) const;\n\n\t/**\n\t* @brief 完全扫掠\n\t* @details 将椭圆弧以现有的方向扫掠完整的360°\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tvoid MakeFullSweep();\n\n    /**\n    * @brief 获取最近点\n    * @details 在应用变换矩阵（可选）后,计算椭圆弧在XY方向上离给定点最近的点（投影或端点）\n    * \n    * @param XPoint3dR closePoint\n    * @param double & closeParam\n    * @param double & distanceXY\n    * @param XPoint3dCR spacePoint\n    * @param XMatrix4dCP worldToLocal\n    * @return bool\n    *\n    * @author SZEWEC\n    * @since 2022/04/22\n    */\n    bool ClosestPointBoundedXY\n    (\n    XPoint3dR   closePoint,\n    double&     closeParam,\n    double&     distXY,\n    XPoint3dCR  spacePoint,\n    XMatrix4dCP worldToLocal\n    ) const;\n\n    /**\n    * @brief 获取最近点\n    * @details 在应用变换矩阵（可选）后,计算椭圆弧在XY方向上离给定点最近的点（投影或端点）\n    * \n    * @param XPoint3dR closePoint\n    * @param double & closeParam\n    * @param double & distanceXY\n    * @param XPoint3dCR spacePoint\n    * @param XMatrix4dCP worldToLocal\n    * @param bool extend0\n    * @param bool extend1\n    * @return bool\n    *\n    * @author SZEWEC\n    * @since 2022/04/22\n    */\n    bool ClosestPointBoundedXY\n    (\n    XPoint3dR   closePoint,\n    double&     closeParam,\n    double&     distXY,\n    XPoint3dCR  spacePoint,\n    XMatrix4dCP worldToLocal,\n    bool extend0,\n    bool extend1\n    ) const;\n\n\t/**\n\t* @brief 获取椭圆弧的起始与终止角度\n\t*\n\t* @param double & startAngle 起始角度\n\t* @param double & endAngle 终止角度\n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/30\n\t*/\n\tvoid GetLimits\n\t(\n\t\tdouble &startAngle,\n\t\tdouble &endAngle\n\t) const;\n\n\t/**\n\t* @brief 给定0°和90°的向量创建椭圆弧\n\t*\n\t* @param XPoint3dCR center\t\t\t\t\t中心点\n\t* @param XVec3dCR vector0\t\t\t\t\t0°向量（通常为沿着主轴的方向）\n\t* @param XVec3dCR vector90\t\t\t\t\t90°向量（通常为沿着短轴的方向）\n\t* @param double theta0\t\t\t\t\t\t起始点对应的角度\n\t* @param double sweep\t\t\t\t\t\t扫掠角度\n\t* @return ATEC_NAMESPACE_NAME::XEllipse3d\t椭圆弧\n\t*\n\t* @author SZEWEC\n\t* @since 2022/06/20\n\t*/\n\tstatic XEllipse3d FromVectors\n\t(\n\t\tXPoint3dCR center,\n\t\tXVec3dCR vector0,\n\t\tXVec3dCR vector90,\n\t\tdouble theta0,\n\t\tdouble sweep\n\t);\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file XPoint3d.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n /**\n * @brief 3D绌洪棿鐐圭被\n * @author SZEWC\n * @since 2022/04/13\n*/\nstruct ATGEOSET_EXPORT XPoint3d\n{\n\n\tdouble x;\n\n\tdouble y;\n\n\tdouble z;\n\n\tstatic XPoint3d From(double x, double y, double z = 0.0);\n\n\tstatic XPoint3d From(XPoint2dCR xy);\n\n\tstatic XPoint3d FromZero();\n\n\tstatic XPoint3d FromOne();\n\n\tstatic XPoint3d FromXYZ(double x, double y, double z);\n\n\tvoid Swap(XPoint3dR other);\n\n\tdouble DotDifference(XPoint3dCR origin, XVec3dCR vector) const;\n\n\tvoid Zero();\n\n\tvoid Init(XPoint2dCR source);\n\n\tvoid Init(double ax, double ay, double az);\n\n\tvoid Init(double ax, double ay);\n\n\tvoid SetComponent(double a, int index);\n\n\tdouble GetComponent(int index) const;\n\n\tvoid Interpolate(XPoint3dCR pnt0, double fractionParameter, XPoint3dCR point1);\n\n\tdouble Distance(XPoint3dCR point2) const;\n\n\tdouble DistanceXY(XPoint3dCR point2) const;\n\n\tbool DistanceXY(XPoint3dCR otherPoint, XMatrix4dCP matrix, double &distance) const;\n\n\tbool IsEqual(XPoint3dCR point2) const;\n\n\tbool IsEqual(XPoint3dCR point2, double tolerance) const;\n\n\tbool IsDisconnect() const;\n\n\tvoid InitDisconnect();\n\n\tvoid Init(XVec3dCR vector);\n\n\tvoid Subtract(XPoint3dCR base, XVec3dCR vector);\n\n\tvoid Add(XVec3dCR vector);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XVec3dCR point1, double scale1, XVec3dCR point2, double scale2, XVec3dCR point3, double scale3);\n\n\tvoid CrossProduct(XPoint3dCR point1, XPoint3dCR point2);\n\n\tdouble DotProduct(XPoint3dCR point2) const;\n\n\tdouble DotProduct(double ax, double ay, double az) const;\n\n\tdouble AngleTo(XPoint3dCR point2) const;\n\n\tvoid RotateXY(XPoint3dCR vector, double theta);\n\n\tvoid RotateXY(double theta);\n\n\tdouble MagnitudeXY() const;\n\n\tvoid Scale(XPoint3dCR vector, double scale);\n\n\tvoid Scale(double scale);\n\n\tvoid Negate(XPoint3dCR vector);\n\n\tvoid Negate();\n\n\tdouble Normalize(XPoint3dCR vector);\n\n\tdouble Normalize();\n\n\tvoid Subtract(XPoint3dCR point2);\n\n\tvoid DifferenceOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR vector, double scale);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tvoid SumOf(XPoint3dCR origin, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2, XPoint3dCR point3, double scale3);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2);\n\n\tvoid SumOf(XPoint3dCR point1, double a1, XPoint3dCR point2, double a2, XPoint3dCR point3, double a3);\n\n\tvoid Add(XPoint3dCR vector);\n\n\tvoid SumOf(XPoint3dCR point1, XPoint3dCR point2);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(TransformCR transform, XPoint3dCR point);\n\n\tstatic XPoint3d FromInterpolate(XPoint3dCR pntA, double fraction, XPoint3dCR pntB);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR vector, double scaleFactor);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR origin, XPoint3dCR pnt0, double scaleFactor0, XPoint3dCR point1, double scaleFactor1, XPoint3dCR point2, double scaleFactor2);\n\n\tstatic XPoint3d FromScale(XPoint3d point, double scale);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1);\n\n\tstatic XPoint3d FromSumOf(XPoint3dCR pnt0, double scale0, XPoint3dCR point1, double scale1, XPoint3dCR point2, double scale2);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, double x, double y, double z);\n\n\tstatic XPoint3d FromProduct(XPoint3dCR point, XRotMatrixCR matrix, XVec3dCR vector);\n\n\tbool AlmostEqual(XPoint3d const & dataB) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB) const;\n\n\tbool AlmostEqual(XPoint3d const & dataB, double abstol) const;\n\n\tbool AlmostEqualXY(XPoint3d const & dataB, double abstol) const;\n\n\tstatic bool AlmostEqual(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tstatic bool AlmostEqualXY(xvector<XPoint3d> const &left, xvector<XPoint3d> const &right, double tolerance = 0.0);\n\n\tdouble DistanceSquared(XPoint3dCR point2) const;\n};\n\nEND_ATEC_NAMESPACE\n\n\n code of file CreateGeometryExamples.h: \n#pragma once\n#pragma region Include_Platform\n#include <ATECCore\\ATECCoreAPI.h>\n#include <EntityUtl/EntityUtlAPI.h>\n#include \"SSDATLoadMacroDef.h\"\n\nUSING_NAMESPACE_ATEC\nUSING_NAMESPACE_ATEC_ATDATACORE\nUSING_NAMESPACE_ATEC_RATCORE\nUSING_NAMESPACE_ATEC_ATCCLOBJECT\n#pragma endregion Include_Platform\n\nclass CreateGeometryExamples\n{\npublic:\n\n\t/************************************\n\t* Desc: 创建线段\n\t** [return] void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXSegment();\n\n\t/************************************\n\t* Desc: 通过圆心,半径,法向量创建整圆\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse_FromCenterNormalRadius();\n\t/************************************\n\t* Desc: 通过圆心,圆弧上的起终点创建圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromCenterStartEndPts();\n\t/************************************\n\t* Desc: 通过point0,point90和扫掠角创建椭圆弧\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateXEllipse3d_FromPoints();\n\n\t/************************************\n\t* Desc: 创建线串\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tSSDPATLoad_EXPORT static void CreateLineString();\n\n\t/************************************\n\t* Desc: 根据控制点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromControlPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromControlPts();\n\t/************************************\n\t* Desc: 根据通过点创建B样条曲线\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic ATBsplineCurvePtr GetBsplineCurves_FromThroughPts(bool isPrintPoints);\n\tSSDPATLoad_EXPORT static void CreateATBsplineCurves_FromThroughPts();\n\n\t/************************************\n\t* Desc: CurveSet表示复杂图形\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetComplexGeo();\n\n\tSSDPATLoad_EXPORT static void CreateCurveSet_ComplexGeo();\n\n\t/************************************\n\t* Desc: CurveSet表示圆环\n\t** [return] SSDPATLoad_EXPORT void\n\t* SZEWEC      2023/07/20\n\t************************************/\n\tstatic CurveSetPtr GetRing();\n\tSSDPATLoad_EXPORT static void CreateCurveSet_Ring();\n\n};\n code of file CurveSet.h: \n\n#pragma once\n\nBEGIN_ATEC_NAMESPACE\n\n/**\n* @brief 线串类\n* @author SZEWC\n* @since 2022/04/27\n*/\nstruct CurveSet : RefCountedBase, xvector<IBasicCurvePtr>\n{\n\n\tenum BoundaryType\n\t{\n\n\t\tBOUNDARY_TYPE_None = 0,\n\n\t\tBOUNDARY_TYPE_Open = 1,\n\n\t\tBOUNDARY_TYPE_Outer = 2,\n\n\t\tBOUNDARY_TYPE_Inner = 3,\n\n\t\tBOUNDARY_TYPE_ParityRegion = 4,\n\n\t\tBOUNDARY_TYPE_UnionRegion = 5,\n\t};\n\n\tenum InOutClassification\n\t{\n\t\tINOUT_Unknown = 0,\n\t\tINOUT_In = 1,\n\t\tINOUT_Out = 2,\n\t\tINOUT_On = 3\n\t};\n\nprotected:\n\tBoundaryType    m_boundaryType;\n\npublic:\n\t/**\n\t* @brief 设定边界\n\t* @details 设定曲线的边界类型\n\t* \n\t* @param BoundaryType BoundaryType\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void SetBoundaryType(BoundaryType BoundaryType);\n\n\t/**\n\t* @brief 获取叶节点\n\t* @details 通过只计算叶节点的索引深度搜索以获取目标叶节点\n\t* \n\t* @param size_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr FindIndexedLeaf(size_t index) const;\n\n\t/**\n\t* @brief 获取索引值\n\t* @details 深度搜索以获取给定叶节点的索引值\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @param size_t & index\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool LeafToIndex(IBasicCurveCP primitive, size_t &index) const;\n\n\t/**\n\t* @brief 获取叶节点个数\n\t* @details 获取曲线的叶节点个数\n\t* \n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesBelow() const;\n\n\texplicit CurveSet(BoundaryType boundaryType) { m_boundaryType = boundaryType; }\n\n\t/**\n\t* @brief 是否单元素曲线\n\t* @details 查询曲线是否只有一个基本元素\n\t* \n\t* @return IBasicCurve\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurve::BasicCurveType HasSingleBasicCurve() const;\n\n\t/**\n\t* @brief 获取边界类型\n\t* @details 获取曲线的边界类型\n\t* \n\t* @return BoundaryType\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT BoundaryType GetBoundaryType() const;\n\n\t/**\n\t* @brief 查询是否开\n\t* @details 查询是否开路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsOpenPath() const;\n\n\t/**\n\t* @brief 查询是否闭\n\t* @details 查询是否闭路径\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsClosedPath() const;\n\n\t/**\n\t* @brief 查询实际开闭\n\t* @details 查询是否名义上是开路径但起点和终点连接\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool IsPhysicallyClosedPath() const;\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个带有给定边界类型没有成员的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个具有单个基本元素和给定边界类型的曲线\n\t* \n\t* @param BoundaryType boundaryType\n\t* @param IBasicCurvePtr primitive\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(BoundaryType boundaryType, IBasicCurvePtr primitive);\n\n\t/**\n\t* @brief 拷贝\n\t* @details 返回一个深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr Clone() const;\n\n\t/**\n\t* @brief 倒角拷贝\n\t* @details 返回一个深度拷贝,在连续曲线之间插入圆角\n\t* \n\t* @param double radius\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithFillets(double radius) const;\n\n\t/**\n\t* @brief 闭合拷贝\n\t* @details 返回一个深度拷贝,闭合终端点的间隙\n\t* \n\t* @param CurveGapOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithGapsClosed(CurveGapOptionsCR options) const;\n\n\t/**\n\t* @brief 添加元素\n\t* @details 递归遍历source, 将所有叶节点添加到this, 返回添加的数量\n\t* \n\t* @param CurveSetCR source\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t AddPrimitives(CurveSetCR source);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 添加单个基本曲线\n\t* \n\t* @param IBasicCurvePtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(IBasicCurvePtr child);\n\n\t/**\n\t* @brief 添加元素\n\t* @details 将chile的所有元素作为曲线成员添加\n\t* \n\t* @param CurveSetPtr child\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void Add(CurveSetPtr child);\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过XY方向的偏移后的深度拷贝\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneOffsetCurvesXY(CurveOffsetOptionsCR options);\n\n\t/**\n\t* @brief 获取叶节点数量\n\t* @details 计算指定类型的叶节点数量\n\t* \n\t* @param IBasicCurve::BasicCurveType targetType\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t CountPrimitivesOfType(IBasicCurve::BasicCurveType targetType) const;\n\n\t/**\n\t* @brief 用区域分割曲线\n\t* @details 用指定区域分割曲线,分别返回区域内、外和区域上的曲线\n\t* \n\t* @param CurveSetCR region\n\t* @param CurveSetP insideCollector\n\t* @param CurveSetP outsideCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByRegion(CurveSetCR region, CurveSetP insideCollector, CurveSetP outsideCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 用平面分割曲线\n\t* @details 用指定平面分割曲线,分别返回平面上方、下方和平面内的曲线\n\t* \n\t* @param XPlane3dCR plane\n\t* @param CurveSetP belowCollector\n\t* @param CurveSetP aboveCollector\n\t* @param CurveSetP onCollector\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendSplitCurvesByPlane(XPlane3dCR plane, CurveSetP belowCollector, CurveSetP aboveCollector, CurveSetP onCollector);\n\n\t/**\n\t* @brief 拆分拷贝\n\t* @details 返回一个深度拷贝,但所有的多线段被拆分成单条线段\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneWithExplodedLinestrings() const;\n\n\t/**\n\t* @brief 获取质心\n\t* @details 返回包含曲线的质心(不考虑孤立点)\n\t* \n\t* @param double & length\n\t* @param XPoint3dR centroid\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  WireCentroid(double &length, XPoint3dR centroid) const;\n\n\t/**\n\t* @brief 获取质心、法向量和面积\n\t* @details 返回质心、法向量和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param XVec3dR normal\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CentroidNormalArea(XPoint3dR centroid, XVec3dR normal, double &area) const;\n\n\t/**\n\t* @brief 获取质心和面积\n\t* @details 返回XY平面方向上的质心和面积\n\t* \n\t* @param XPoint3dR centroid\n\t* @param double & area\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool  CentroidAreaXY(XPoint3dR centroid, double &area) const;\n\n\t/**\n\t* @brief 投影范围\n\t* @details 当投影到射线的时候,返回射线参数的范围\n\t* \n\t* @param XRay3dCR ray\n\t* @return XRange1d\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT XRange1d ProjectedParameterRange(XRay3dCR ray) const;\n\n    /**\n    * @brief 局部坐标拷贝\n    * @details 返回曲线的深度复制并转换为与曲线相关联的局部坐标系统。\n    * \n    * @param LocalCoordinateSelect frameType\n    * @param TransformR localToWorld\n    * @param TransformR worldToLocal\n    * @param XRange3dR localRange\n    * @return CurveSetPtr\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT CurveSetPtr CloneInLocalCoordinates\n    (\n    LocalCoordinateSelect frameType,\n    TransformR localToWorld,\n    TransformR worldToLocal,\n    XRange3dR localRange\n    ) const;\n\n\t/**\n    * @brief 获取有坐标系的元素\n    * @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame) const;\n\n\t/**\n\t* @brief 获取有坐标系的元素\n\t* @details 深度搜索以获取任一有完好定义坐标系的曲线元素\n\t* \n\t* @param TransformR frame\n\t* @param int searchPreference\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetAnyFrenetFrame(TransformR frame, int srchPref) const;\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param xvector<XPoint3d> const & points\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(xvector<XPoint3d> const&points,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建线\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint3dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint3dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建多边形\n\t* @details 由坐标点创建线或多边形\n\t* \n\t* @param XPoint2dCP points\n\t* @param size_t numPoints\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateLinear(\n\t\tXPoint2dCP points,\n\t\tsize_t numPoints,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open,\n\t\tbool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建矩形\n\t* @details 根据 XY 坐标创建矩形\n\t* \n\t* @param double x0\n\t* @param double y0\n\t* @param double x1\n\t* @param double y1\n\t* @param double z\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateRectangle(double x0, double y0, double x1, double y1, double z,\n\t\tBoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 由给定线段创建边界类型为 BOUNDARY_TYPE_None 的曲线\n\t* \n\t* @param xvector<XSegment3d> const & segments\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(xvector<XSegment3d> const &segs);\n\n\t/**\n\t* @brief 创建圆盘\n\t* @details 为一个完整的椭圆(圆)盘创建一个曲线向量结构\n\t* \n\t* @param XEllipse3dCR arc\n\t* @param BoundaryType boundaryType\n\t* @param bool forceXYOrientation\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr CreateDisk(XEllipse3dCR arc, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Outer, bool forceXYOrientation = false);\n\n\t/**\n\t* @brief 创建函数\n\t* @details 创建一个仅有单一元素的曲线结构\n\t* \n\t* @param IBasicCurvePtr child\n\t* @param BoundaryType boundaryType\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr Create(IBasicCurvePtr child, BoundaryType boundaryType = CurveSet::BOUNDARY_TYPE_Open);\n\n\t/**\n\t* @brief B样条拷贝\n\t* @details 返回一个深度拷贝,作为B样条曲线\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneAsBsplines() const;\n\n\t/**\n\t* @brief 添加边缘点\n\t* @details 为所有的子节点添加边缘点\n\t* \n\t* @param xvector <XPoint3d> & points\n\t* @param IFacetOptionsR options\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AddStrokePoints(xvector <XPoint3d> &points, IFacetOptionsR options) const;\n\n    /**\n\t* @brief 添加面点\n\t* @details 沿着曲线计算指定距离的点\n\t* \n\t* @param xvector<double> const & distances\n\t* @param xvector<CurveDescInfo> & locations\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool AddSpacedPoints(xvector<double> const &distances, xvector<CurveDescInfo> &locations) const;\n\n\t/**\n\t* @brief 添加边缘\n\t* @details 在结构中添加所有边缘\n\t* \n\t* @param xvector <xvector<xvector<XPoint3d>>> & regionsPoints\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool CollectLinearGeometry(xvector <xvector<xvector<XPoint3d>> > &regionsPoints) const;\n\n\t/**\n\t* @brief 获取B样条曲线\n\t* @details 将一个表示开放或闭合路径作为单个B样条曲线\n\t* \n\t* @return ATBsplineCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT ATBsplineCurvePtr GetBsplineCurve() const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBounded(XPoint3dCR spacePoint, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n    /**\n\t* @brief 搜索最近点\n\t* @details 搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 允许延长的情况下搜索任一包含曲线上最近的点,只考虑XY坐标\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XMatrix4dCP worldToLocal\n\t* @param CurveDescInfoR location\n\t* @param bool extend0\n\t* @param bool extend1\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ClosestPointBoundedXY(XPoint3dCR spacePoint, XMatrix4dCP worldToLocal, CurveDescInfoR location, bool extend0, bool extend1) const;\n\n\t/**\n\t* @brief 搜索最近点\n\t* @details 搜索最接近曲线的点。如果曲线是一个区域类型,同时要在该区域的内部寻找投影\n\t* \n\t* @param XPoint3dCR spacePoint\n\t* @param XPoint3dR curveOrRegionPoint\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification ClosestCurveOrRegionPoint(XPoint3dCR spacePoint, XPoint3dR curveOrRegionPoint) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点和终点\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB) const;\n\n\t/**\n\t* @brief 获取起止点\n\t* @details 返回起点终点和他们的正切值\n\t* \n\t* @param XPoint3dR pointA\n\t* @param XPoint3dR pointB\n\t* @param XVec3dR unitTangentA\n\t* @param XVec3dR unitTangentB\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartEnd(XPoint3dR pntA, XPoint3dR pntB, XVec3dR unitTangentA, XVec3dR unitTangentB) const;\n\n\t/**\n\t* @brief 获取起点\n\t* @details 返回曲线的起点\n\t* \n\t* @param XPoint3dR point\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetStartPoint(XPoint3dR point) const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线总长度\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length() const;\n\n\t/**\n\t* @brief 获取长度\n\t* @details 返回曲线经过变换后的总长度\n\t* \n\t* @param XRotMatrixCP worldToLocal\n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT double Length(XRotMatrixCP worldToLocal) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线的xyz范围\n\t* \n\t* @param XRange3dR range\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range) const;\n\n\t/**\n\t* @brief 获取范围\n\t* @details 返回曲线经过变换后的范围\n\t* \n\t* @param XRange3dR range\n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool GetRange(XRange3dR range, TransformCR transform) const;\n\n\t/**\n\t* @brief 查询索引\n\t* @details 返回指定元素的索引\n\t* \n\t* @param IBasicCurveCP primitive\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT size_t FindIndexOfPrimitive(IBasicCurveCP primitive) const;\n\n\t/**\n\t* @brief 复制曲线指定范围的曲线\n\t* @details 复制曲线指定索引和比例参数范围内的部分\n\t* \n\t* @param int index0\n\t* @param double fraction0\n\t* @param int index1\n\t* @param double fraction1\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n    ATGEOSET_EXPORT CurveSetPtr CloneBetweenCyclicIndexedFractions(int index0, double fraction0, int index1, double fraction1) const;\n\n\t/**\n\t* @brief 反转拷贝\n\t* @details 返回一个所有元素都被反转的深度拷贝\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneReversed() const;\n\n\t/**\n\t* @brief 查询是否包含非线性元素\n\t* @details 如果曲线有一个不非线性元素,则返回true。\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool ContainsNonLinearPrimitive() const;\n\n\t/**\n\t* @brief 计算交点\n\t* @details 计算曲线与给定平面的交点\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT void AppendCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 平面选中\n\t* @details 计算封闭曲线与平面的交叉点,并以奇偶性规则为设为起始对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param double tolerance\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr PlaneSection(XPlane3dCR plane, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 空间点位置情况\n\t* @details 当以XY平面视角看,测试给定点在曲线内、曲线上还是曲线外\n\t* \n\t* @param XPoint3dCR xyz\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification PointInOnOutXY(XPoint3dCR xyz) const;\n\n\t/**\n\t* @brief 射线击中情况\n\t* @details 测试射线击中曲线在区域内、区域上还是区域外\n\t* \n\t* @param XRay3dCR ray\n\t* @param SolidDescInfoR hitDetail\n\t* @return CurveSet\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT CurveSet::InOutClassification RayPierceInOnOut\n\t(\n\t\tXRay3dCR ray,\n\t\tSolidDescInfoR hitDetail\n\t) const;\n\n\t/**\n\t* @brief 原地变换\n\t* @details 应用给定变换并修改曲线\n\t* \n\t* @param TransformCR transform\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/11\n\t*/\n\tATGEOSET_EXPORT bool TransformInPlace(TransformCR transform);\n\n\t/**\n\t* @brief 原地反转\n\t* @details 将所有元素进行反转\n\t* \n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool ReverseCurvesInPlace();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串内的单个点被消除,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives();\n\n\t/**\n\t* @brief 原地修改以连接相邻部分\n\t* @details 相邻的线和线串合并成单个线串,线串相邻的空间点被消除（可选）,相邻的和兼容的圆弧合并成一条圆弧\n\t* \n\t* @param bool doSimplifyLinestrings\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void ConsolidateAdjacentPrimitives(bool doSimplifyLinestrings);\n\n\t/**\n\t* @brief 原地修改以简化线串\n\t* @details 消除线串相邻的空间点\n\t* \n\t* @param double distanceTol\n\t* @param bool eliminateOverdraw\n\t* @param bool wrap\n\t* @return void\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT void SimplifyLinestrings(double distTol, bool eliminateOverdraw, bool wrap);\n\n\t/**\n\t* @brief 重排元素\n\t* @details 将曲线元素重新排序以缩小元素首尾相连的间隙\n\t* \n\t* @return double\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT double ReorderForSmallGaps();\n\n\t/**\n\t* @brief 链接元素\n\t* @details 将曲线的元素首尾相连\n\t* \n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AssembleChains();\n\n\t/**\n\t* @brief 区域相并\n\t* @details 返回给定两个区域的并\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaUnion(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相减\n\t* @details 返回给定两个区域的减\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaDifference(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 区域相交\n\t* @details 返回给定两个区域的交\n\t* \n\t* @param CurveSetCR regionA\n\t* @param CurveSetCR regionB\n\t* @param BasicCurvePtrPairVector * newToOld\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaIntersection(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n\n\t/**\n\t* @brief 循环索引\n\t* @details 返回给定索引值关于集合大小的模\n\t* \n\t* @param int index\n\t* @return size_t\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT size_t CyclicIndex(int index) const;\n\n\t/**\n\t* @brief 循环获取值\n\t* @details 根据给定索引的循环索引获取元素\n\t* \n\t* @param ptrdiff_t index\n\t* @return IBasicCurvePtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT IBasicCurvePtr GetCyclic(ptrdiff_t index) const;\n\n    /**\n    * @brief 获取索引\n    * @details 返回给定曲线元素的详细细节所对应的元素索引\n    * \n    * @param CurveDescInfo const & location\n    * @return size_t\n    *\n    * @author SZEWEC\n    * @since 2022/04/13\n    */\n    ATGEOSET_EXPORT size_t CurveDescInfoIndex(CurveDescInfo const& location) const;\n\n\t/**\n\t* @brief 与平面相交\n\t* @details 计算封闭曲线与平面的交叉点,返回以奇偶性规则构造的起止点对\n\t* \n\t* @param XPlane3dCR plane\n\t* @param xvector<CurveDescInfoPair> & intersections\n\t* @param double tolerance\n\t* @return bool\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT bool AppendClosedCurvePlaneIntersections(XPlane3dCR plane, xvector<CurveDescInfoPair> &intersections, double tolerance = 0.0) const;\n\n\t/**\n\t* @brief 偏移拷贝\n\t* @details 返回所有曲线经过给定偏移后的深度拷贝.\n\t* \n\t* @param CurveOffsetOptionsCR options\n\t* @return CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/04/13\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr AreaOffset(CurveOffsetOptionsCR options) const;\n\n\t/**\n\t* @brief 返回从index0,fraction0到index1,fraction1的曲线段\n\t* \n\t* @param int index0 \n\t* @param double fraction0 \n\t* @param int index1 \n\t* @param double fraction1 \n\t* @param bool allowExtrapolation \n\t* @return ATGEOSET_EXPORT CurveSetPtr \n\t*\n\t* @author SZEWEC\n\t* @since 2022/05/17\n\t*/\n\tATGEOSET_EXPORT CurveSetPtr CloneBetweenDirectedFractions(int index0, double fraction0, int index1, double fraction1, bool allowExtrapolation) const;\n\n\t/**\n\t* @brief 返回输入的曲线的布尔奇运算结果（区域）\n\t*\n\t* @param CurveSetCR regionA\t\t\t\t\t左操作数\n\t* @param CurveSetCR regionB\t\t\t\t\t右操作数\n\t* @param BasicCurvePtrPairVector * newToOld\t（可选）包含新旧曲线的数组指针\n\t* @return ATGEOSET_EXPORT CurveSetPtr\n\t*\n\t* @author SZEWEC\n\t* @since 2022/07/22\n\t*/\n\tATGEOSET_EXPORT static CurveSetPtr AreaParity(CurveSetCR regionA, CurveSetCR regionB, BasicCurvePtrPairVector *newToOld = NULL);\n};\n\nstruct CurveCurve\n{\nprivate: CurveCurve();\npublic:\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tCurveSetR curveA,\n\t\tCurveSetR curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB,\n\t\tXMatrix4dCP    pWorldToLocal,\n\t\tbool         extend = false\n\t);\n\n\tstatic ATGEOSET_EXPORT void IntersectionsXY\n\t(\n\t\tCurveSetR intersectionA,\n\t\tCurveSetR intersectionB,\n\t\tIBasicCurveR curveA,\n\t\tCurveSetR     curveB,\n\t\tXMatrix4dCP    pWorldToLocal\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tIBasicCurveP curveA,\n\t\tIBasicCurveP curveB\n\t);\n\n\tstatic ATGEOSET_EXPORT bool ClosestApproach\n\t(\n\t\tCurveDescInfoR pntOnA,\n\t\tCurveDescInfoR pntOnB,\n\t\tCurveSetCR chainA,\n\t\tCurveSetCR chainB\n\t);\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            double &fractionA,\n            XPoint3dR pntA,\n            double &fractionB,\n            XPoint3dR pntB\n            );\n\n    static ATGEOSET_EXPORT bool IsSinglePointPair\n        (\n            CurveSetR intersectionA,\n            CurveSetR intersectionB,\n            size_t i,\n            CurveDescInfoR detailA,\n            CurveDescInfoR detailB\n            );\n};\n\nstruct PathLocationDetail\n{\nprivate:\n\tCurveDescInfo m_curveDetail;\n\tint32_t m_pathIndex;\n\tdouble m_pathDistance;\npublic:\n\n\tATGEOSET_EXPORT PathLocationDetail();\n\n\tATGEOSET_EXPORT PathLocationDetail(PathLocationDetail const &other);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, int pathIndex = -1, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(CurveDescInfoCR curveDetail, size_t pathIndex, double distance = DBL_MAX);\n\n\tATGEOSET_EXPORT PathLocationDetail(double distance);\n\n\tATGEOSET_EXPORT XPoint3d Point() const;\n\n\tATGEOSET_EXPORT CurveDescInfo GetCurveDescInfo() const;\n\n    ATGEOSET_EXPORT double DistanceFromPathStart() const;\n};\n\nstruct CurveSetWithDistanceIndex : RefCountedBase\n{\nprivate:\n\n\tstruct PathEntry : PathLocationDetail\n\t{\n\t\tdouble             m_projectedDistance;\n\t\tXRange3d           m_range;\n\t\tPathEntry(PathLocationDetail const &pathDetail, double projectedDist, XRange3dCR range)\n\t\t\t: PathLocationDetail(pathDetail),\n\t\t\tm_projectedDistance(projectedDist),\n\t\t\tm_range(range)\n\t\t{\n\t\t}\n\t\tPathEntry(double distance) : PathLocationDetail(distance), m_projectedDistance(distance) {}\n\n\t\tdouble GetDistance(bool projected) const;\n\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistanceXY(PathEntry const &dataA, PathEntry const &dataB);\n\t\tstatic ATGEOSET_EXPORT bool IsLessThan_ByPathDistance(PathEntry const &dataA, PathEntry const &dataB);\n\t};\n\n\tCurveSetPtr m_curveVector;\n\txvector<PathEntry> m_locations;\n\tCurveSetPtr m_savedPrimitives;\n\n\tXRotMatrix m_worldToViewRotMatrix;\n\tXRotMatrix m_viewToWorldRotMatrix;\n\tXRotMatrix m_flattenToView;\n\tXMatrix4d m_worldToView;\n\n\texplicit CurveSetWithDistanceIndex(XRotMatrix worldToView);\n\n\tCurveSetWithDistanceIndex();\n\npublic:\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create(XRotMatrix worldToView);\n\n\tstatic ATGEOSET_EXPORT CurveSetWithDistanceIndexPtr Create();\n\n\tATGEOSET_EXPORT void SetPath(CurveSetPtr &path);\n\n\tATGEOSET_EXPORT bool SearchByDistanceFromPathStart\n\t(\n\t\tdouble targetDist,\n\t\tPathLocationDetail &detail\n\t) const;\n\n    ATGEOSET_EXPORT PathLocationDetail SearchClosestPointBounded\n    (\n    XPoint3dCR spacePoint,\n    bool computeDistAlong\n    ) const;\n};\n\nEND_ATEC_NAMESPACE\n\n", "output": "\nCurveSetPtr CreateGeometryExamples::GetRing()\n{\n\t//1. 创建外侧的圆,边界类型设置为Outer\n\tXPoint3d center = XPoint3d::FromZero();\n\tdouble radiusBig = 100;\n\n\tXEllipse3d arc = XEllipse3d::FromCenterRadiusXY(center, radiusBig);\n\tCurveSetPtr arcBig = CurveSet::Create(IBasicCurve::CreateArc(arc), CurveSet::BOUNDARY_TYPE_Outer);\n\n\t//2. 创建内侧的圆,边界类型设置为Inner\n\tdouble radiusSmall = 80;\n\n\tXEllipse3d arc2 = XEllipse3d::FromCenterRadiusXY(center, radiusSmall);\n\tCurveSetPtr arcSmall = CurveSet::Create(IBasicCurve::CreateArc(arc2), CurveSet::BOUNDARY_TYPE_Inner);\n\n\t//3. 创建圆环\n\tCurveSetPtr ring = CurveSet::Create(CurveSet::BOUNDARY_TYPE_ParityRegion);\n\tring->Add(arcBig);\n\tring->Add(arcSmall);\n\treturn ring;\n}\n"}]